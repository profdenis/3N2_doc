{"config":{"indexing":"full","lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programmation Android Auteur : Denis Rinfret Ressources Logiciels IntelliJ Android Studio Recommendation : installer Android Studio \u00e0 l'aide de Jetbrains Toolbox Formations en ligne Kotlin pour les d\u00e9veloppeurs Java Principes de base d'Android avec Compose R\u00e9f\u00e9rences D\u00e9velopper pour Android Material Theme Builder Ic\u00f4nes Material","title":"Programmation Android"},{"location":"#programmation-android","text":"Auteur : Denis Rinfret","title":"Programmation Android"},{"location":"#ressources","text":"","title":"Ressources"},{"location":"#logiciels","text":"IntelliJ Android Studio Recommendation : installer Android Studio \u00e0 l'aide de Jetbrains Toolbox","title":"Logiciels"},{"location":"#formations-en-ligne","text":"Kotlin pour les d\u00e9veloppeurs Java Principes de base d'Android avec Compose","title":"Formations en ligne"},{"location":"#references","text":"D\u00e9velopper pour Android Material Theme Builder Ic\u00f4nes Material","title":"R\u00e9f\u00e9rences"},{"location":"1.%20Kotlin/01-kotlin/","text":"Le langage de programmation Kotlin Kotlin est un langage de programmation moderne \u00e0 typage statique utilis\u00e9 par plus de 60 % des d\u00e9veloppeurs Android professionnels, qui permet d'am\u00e9liorer la productivit\u00e9, la satisfaction des d\u00e9veloppeurs et la s\u00e9curit\u00e9 du code. https://developer.android.com/kotlin?hl=fr Depuis Google I/O en 2019, Google a d\u00e9clar\u00e9 que le d\u00e9veloppement mobile Android est Kotlin-first . Cela signifie que Google recommande aux d\u00e9veloppeurs d'Android d'utiliser Kotlin comme premier choix de langage de programmation pour le d\u00e9veloppement de nouvelles applications Android. Kotlin offre de nombreux avantages pour le d\u00e9veloppement Android, y compris la \"null safety\" (la s\u00e9curit\u00e9 contre valeurs nulles), la clart\u00e9 et la concision du code, et une interop\u00e9rabilit\u00e9 compl\u00e8te avec Java, qui \u00e9tait auparavant le langage recommand\u00e9 pour le d\u00e9veloppement Android. Android\u2019s commitment to Kotlin Documentation de Kotlin Kotlin n'est pas seulement utilis\u00e9 pour d\u00e9velopper des applications Android, mais aussi du c\u00f4t\u00e9 serveur, pour les applications multi-plateformes et l'analyse de donn\u00e9es. D\u00e9tails","title":"Le langage de programmation Kotlin"},{"location":"1.%20Kotlin/01-kotlin/#le-langage-de-programmation-kotlin","text":"Kotlin est un langage de programmation moderne \u00e0 typage statique utilis\u00e9 par plus de 60 % des d\u00e9veloppeurs Android professionnels, qui permet d'am\u00e9liorer la productivit\u00e9, la satisfaction des d\u00e9veloppeurs et la s\u00e9curit\u00e9 du code. https://developer.android.com/kotlin?hl=fr Depuis Google I/O en 2019, Google a d\u00e9clar\u00e9 que le d\u00e9veloppement mobile Android est Kotlin-first . Cela signifie que Google recommande aux d\u00e9veloppeurs d'Android d'utiliser Kotlin comme premier choix de langage de programmation pour le d\u00e9veloppement de nouvelles applications Android. Kotlin offre de nombreux avantages pour le d\u00e9veloppement Android, y compris la \"null safety\" (la s\u00e9curit\u00e9 contre valeurs nulles), la clart\u00e9 et la concision du code, et une interop\u00e9rabilit\u00e9 compl\u00e8te avec Java, qui \u00e9tait auparavant le langage recommand\u00e9 pour le d\u00e9veloppement Android. Android\u2019s commitment to Kotlin Documentation de Kotlin Kotlin n'est pas seulement utilis\u00e9 pour d\u00e9velopper des applications Android, mais aussi du c\u00f4t\u00e9 serveur, pour les applications multi-plateformes et l'analyse de donn\u00e9es. D\u00e9tails","title":"Le langage de programmation Kotlin"},{"location":"1.%20Kotlin/02-kotlin-android/","text":"Kotlin pour Android Source Le d\u00e9veloppement mobile Android est Kotlin-first depuis Google I/O en 2019. Plus de 50% des d\u00e9veloppeurs Android professionnels utilisent Kotlin comme leur langage principal, tandis que seulement 30% utilisent Java comme leur langage principal. 70% des d\u00e9veloppeurs dont le langage principal est Kotlin disent que Kotlin les rend plus productifs. En utilisant Kotlin pour le d\u00e9veloppement Android, vous pouvez b\u00e9n\u00e9ficier de : Moins de code combin\u00e9 \u00e0 une plus grande lisibilit\u00e9 . Passez moins de temps \u00e0 \u00e9crire votre code et \u00e0 essayer de comprendre le code des autres. Moins d'erreurs communes . Les applications construites avec Kotlin ont 20% moins de chances de planter en se basant sur les donn\u00e9es internes de Google . Support de Kotlin dans les biblioth\u00e8ques Jetpack . Jetpack Compose est la bo\u00eete \u00e0 outils moderne recommand\u00e9e par Android pour la construction de l'interface utilisateur native en Kotlin. Les extensions KTX ajoutent les fonctionnalit\u00e9s du langage Kotlin, comme les coroutines, les fonctions d'extension, les lambdas et les param\u00e8tres nomm\u00e9s aux biblioth\u00e8ques Android existantes. Support pour le d\u00e9veloppement multiplateforme . Kotlin Multiplatform permet le d\u00e9veloppement non seulement pour Android, mais aussi pour iOS , le backend, et les applications web. Certaines biblioth\u00e8ques Jetpack sont d\u00e9j\u00e0 multiplateformes. Compose Multiplatform , le cadre d'interface utilisateur d\u00e9claratif de JetBrains bas\u00e9 sur Kotlin et Jetpack Compose, rend possible le partage des interfaces utilisateur entre les plates-formes - iOS, Android, desktop et web. Langage et environnement matures . Depuis sa cr\u00e9ation en 2011, Kotlin s'est d\u00e9velopp\u00e9 continuellement, non seulement en tant que langage, mais aussi en tant qu'\u00e9cosyst\u00e8me tout entier avec un outillage robuste. Aujourd'hui, il est int\u00e9gr\u00e9 de mani\u00e8re transparente dans Android Studio et est activement utilis\u00e9 par de nombreuses entreprises pour d\u00e9velopper des applications Android. Interop\u00e9rabilit\u00e9 avec Java . Vous pouvez utiliser Kotlin en combinaison avec le langage de programmation Java dans vos applications sans avoir \u00e0 migrer tout votre code vers Kotlin. Apprentissage facile . Kotlin est tr\u00e8s facile \u00e0 apprendre, surtout pour les d\u00e9veloppeurs Java. Grande communaut\u00e9 . Kotlin b\u00e9n\u00e9ficie d'un grand soutien et de nombreuses contributions de la part de la communaut\u00e9 qui s'\u00e9tend dans le monde entier. Plus de 95% des mille meilleures applications Android utilisent Kotlin. De nombreuses startups et entreprises du Fortune 500 ont d\u00e9j\u00e0 d\u00e9velopp\u00e9 des applications Android en utilisant Kotlin, voir la liste sur le site web de Google pour les d\u00e9veloppeurs Android .","title":"Kotlin pour Android"},{"location":"1.%20Kotlin/02-kotlin-android/#kotlin-pour-android","text":"Source Le d\u00e9veloppement mobile Android est Kotlin-first depuis Google I/O en 2019. Plus de 50% des d\u00e9veloppeurs Android professionnels utilisent Kotlin comme leur langage principal, tandis que seulement 30% utilisent Java comme leur langage principal. 70% des d\u00e9veloppeurs dont le langage principal est Kotlin disent que Kotlin les rend plus productifs. En utilisant Kotlin pour le d\u00e9veloppement Android, vous pouvez b\u00e9n\u00e9ficier de : Moins de code combin\u00e9 \u00e0 une plus grande lisibilit\u00e9 . Passez moins de temps \u00e0 \u00e9crire votre code et \u00e0 essayer de comprendre le code des autres. Moins d'erreurs communes . Les applications construites avec Kotlin ont 20% moins de chances de planter en se basant sur les donn\u00e9es internes de Google . Support de Kotlin dans les biblioth\u00e8ques Jetpack . Jetpack Compose est la bo\u00eete \u00e0 outils moderne recommand\u00e9e par Android pour la construction de l'interface utilisateur native en Kotlin. Les extensions KTX ajoutent les fonctionnalit\u00e9s du langage Kotlin, comme les coroutines, les fonctions d'extension, les lambdas et les param\u00e8tres nomm\u00e9s aux biblioth\u00e8ques Android existantes. Support pour le d\u00e9veloppement multiplateforme . Kotlin Multiplatform permet le d\u00e9veloppement non seulement pour Android, mais aussi pour iOS , le backend, et les applications web. Certaines biblioth\u00e8ques Jetpack sont d\u00e9j\u00e0 multiplateformes. Compose Multiplatform , le cadre d'interface utilisateur d\u00e9claratif de JetBrains bas\u00e9 sur Kotlin et Jetpack Compose, rend possible le partage des interfaces utilisateur entre les plates-formes - iOS, Android, desktop et web. Langage et environnement matures . Depuis sa cr\u00e9ation en 2011, Kotlin s'est d\u00e9velopp\u00e9 continuellement, non seulement en tant que langage, mais aussi en tant qu'\u00e9cosyst\u00e8me tout entier avec un outillage robuste. Aujourd'hui, il est int\u00e9gr\u00e9 de mani\u00e8re transparente dans Android Studio et est activement utilis\u00e9 par de nombreuses entreprises pour d\u00e9velopper des applications Android. Interop\u00e9rabilit\u00e9 avec Java . Vous pouvez utiliser Kotlin en combinaison avec le langage de programmation Java dans vos applications sans avoir \u00e0 migrer tout votre code vers Kotlin. Apprentissage facile . Kotlin est tr\u00e8s facile \u00e0 apprendre, surtout pour les d\u00e9veloppeurs Java. Grande communaut\u00e9 . Kotlin b\u00e9n\u00e9ficie d'un grand soutien et de nombreuses contributions de la part de la communaut\u00e9 qui s'\u00e9tend dans le monde entier. Plus de 95% des mille meilleures applications Android utilisent Kotlin. De nombreuses startups et entreprises du Fortune 500 ont d\u00e9j\u00e0 d\u00e9velopp\u00e9 des applications Android en utilisant Kotlin, voir la liste sur le site web de Google pour les d\u00e9veloppeurs Android .","title":"Kotlin pour Android"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/01-survol/","text":"Survol de Kotlin Source Ce parcours couvre les fondamentaux du langage de programmation Kotlin et peut \u00eatre compl\u00e8tement r\u00e9alis\u00e9 dans votre navigateur. Aucune installation n'est n\u00e9cessaire. Chaque chapitre de ce parcours contient : De la th\u00e9orie pour introduire les concepts cl\u00e9s du langage avec des exemples. De la pratique avec des exercices pour tester votre compr\u00e9hension de ce que vous avez appris. Des solutions pour votre r\u00e9f\u00e9rence. Dans ce parcours, vous apprendrez \u00e0 propos de : Variables Types de base Collections Flux de commande Fonctions Classes Securit\u00e9 Null Pour avoir la meilleure exp\u00e9rience, nous recommandons que vous lisiez ces chapitres dans l'ordre. Mais si vous le souhaitez, vous pouvez choisir les chapitres que vous voulez lire.","title":"Survol de Kotlin"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/01-survol/#survol-de-kotlin","text":"Source Ce parcours couvre les fondamentaux du langage de programmation Kotlin et peut \u00eatre compl\u00e8tement r\u00e9alis\u00e9 dans votre navigateur. Aucune installation n'est n\u00e9cessaire. Chaque chapitre de ce parcours contient : De la th\u00e9orie pour introduire les concepts cl\u00e9s du langage avec des exemples. De la pratique avec des exercices pour tester votre compr\u00e9hension de ce que vous avez appris. Des solutions pour votre r\u00e9f\u00e9rence. Dans ce parcours, vous apprendrez \u00e0 propos de : Variables Types de base Collections Flux de commande Fonctions Classes Securit\u00e9 Null Pour avoir la meilleure exp\u00e9rience, nous recommandons que vous lisiez ces chapitres dans l'ordre. Mais si vous le souhaitez, vous pouvez choisir les chapitres que vous voulez lire.","title":"Survol de Kotlin"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/02-variables/","text":"Variables Source Voici un programme simple qui imprime \"Hello, world!\" : fun main() { println(\"Hello, world!\") // Hello, world! } En Kotlin : fun est utilis\u00e9 pour d\u00e9clarer une fonction la fonction main() est le point de d\u00e9part de votre programme le corps d'une fonction est \u00e9crit entre accolades {} les fonctions println() et print() affichent leurs arguments en sortie standard Les fonctions sont discut\u00e9es plus en d\u00e9tail dans quelques chapitres. Jusque-l\u00e0, tous les exemples utilisent la fonction main() . Variables Tous les programmes doivent \u00eatre capables de stocker des donn\u00e9es, et les variables vous aident \u00e0 faire justement cela. En Kotlin, vous pouvez d\u00e9clarer : des variables en lecture seule avec val des variables modifiables avec var Pour attribuer une valeur, utilisez l'op\u00e9rateur d'affectation = . Par exemple : fun main() { //sampleStart val popcorn = 5 // Il y a 5 bo\u00eetes de popcorn val hotdog = 7 // Il y a 7 hot-dogs var clients = 10 // Il y a 10 clients dans la queue // Certains clients quittent la queue clients = 8 println(clients) // 8 //sampleEnd } Les variables peuvent \u00eatre d\u00e9clar\u00e9es en dehors de la fonction main() au d\u00e9but de votre programme. On dit que les variables d\u00e9clar\u00e9es de cette mani\u00e8re sont d\u00e9clar\u00e9es au niveau sup\u00e9rieur . Comme clients est une variable modifiable, sa valeur peut \u00eatre r\u00e9attribu\u00e9e apr\u00e8s la d\u00e9claration. Nous recommandons que vous d\u00e9clariez toutes les variables en lecture seule ( val ) par d\u00e9faut. D\u00e9clarez des variables modifiables ( var ) seulement si n\u00e9cessaire. Gabarits de cha\u00eene Il est utile de savoir comment imprimer le contenu des variables en sortie standard. Vous pouvez le faire avec les gabarits de cha\u00eene . Vous pouvez utiliser des expressions de mod\u00e8le pour acc\u00e9der aux donn\u00e9es stock\u00e9es dans les variables et d'autres objets, et les convertir en cha\u00eenes. Une valeur de cha\u00eene est une s\u00e9quence de caract\u00e8res entre guillemets doubles \" . Les expressions de gabarit commencent toujours par un signe dollar $ . Pour \u00e9valuer un bout de code dans une expression de gabarit, placez le code entre accolades {} apr\u00e8s le signe dollar $ . Par exemple : fun main() { //sampleStart val clients = 10 println(\"Il y a $clients clients\") // Il y a 10 clients println(\"Il y a ${clients + 1} clients\") // Il y a 11 clients //sampleEnd } Pour plus d'informations, voir Gabarits de cha\u00eene . Vous remarquerez qu'il n'y a pas de types d\u00e9clar\u00e9s pour les variables. Kotlin a inf\u00e9r\u00e9 le type lui-m\u00eame : Int . Ce parcours explique les diff\u00e9rents types de base de Kotlin et comment les d\u00e9clarer dans le chapitre suivant . Pratique Exercice Compl\u00e9tez le code pour que le programme imprime \"Mary a 20 ans\" en sortie standard : fun main() { val nom = \"Mary\" val age = 20 // Ecrivez votre code ici } R\u00e9ponse fun main() { val nom = \"Mary\" val age = 20 println(\"$nom a $age ans\") }","title":"Variables"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/02-variables/#variables","text":"Source Voici un programme simple qui imprime \"Hello, world!\" : fun main() { println(\"Hello, world!\") // Hello, world! } En Kotlin : fun est utilis\u00e9 pour d\u00e9clarer une fonction la fonction main() est le point de d\u00e9part de votre programme le corps d'une fonction est \u00e9crit entre accolades {} les fonctions println() et print() affichent leurs arguments en sortie standard Les fonctions sont discut\u00e9es plus en d\u00e9tail dans quelques chapitres. Jusque-l\u00e0, tous les exemples utilisent la fonction main() .","title":"Variables"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/02-variables/#variables_1","text":"Tous les programmes doivent \u00eatre capables de stocker des donn\u00e9es, et les variables vous aident \u00e0 faire justement cela. En Kotlin, vous pouvez d\u00e9clarer : des variables en lecture seule avec val des variables modifiables avec var Pour attribuer une valeur, utilisez l'op\u00e9rateur d'affectation = . Par exemple : fun main() { //sampleStart val popcorn = 5 // Il y a 5 bo\u00eetes de popcorn val hotdog = 7 // Il y a 7 hot-dogs var clients = 10 // Il y a 10 clients dans la queue // Certains clients quittent la queue clients = 8 println(clients) // 8 //sampleEnd } Les variables peuvent \u00eatre d\u00e9clar\u00e9es en dehors de la fonction main() au d\u00e9but de votre programme. On dit que les variables d\u00e9clar\u00e9es de cette mani\u00e8re sont d\u00e9clar\u00e9es au niveau sup\u00e9rieur . Comme clients est une variable modifiable, sa valeur peut \u00eatre r\u00e9attribu\u00e9e apr\u00e8s la d\u00e9claration. Nous recommandons que vous d\u00e9clariez toutes les variables en lecture seule ( val ) par d\u00e9faut. D\u00e9clarez des variables modifiables ( var ) seulement si n\u00e9cessaire.","title":"Variables"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/02-variables/#gabarits-de-chaine","text":"Il est utile de savoir comment imprimer le contenu des variables en sortie standard. Vous pouvez le faire avec les gabarits de cha\u00eene . Vous pouvez utiliser des expressions de mod\u00e8le pour acc\u00e9der aux donn\u00e9es stock\u00e9es dans les variables et d'autres objets, et les convertir en cha\u00eenes. Une valeur de cha\u00eene est une s\u00e9quence de caract\u00e8res entre guillemets doubles \" . Les expressions de gabarit commencent toujours par un signe dollar $ . Pour \u00e9valuer un bout de code dans une expression de gabarit, placez le code entre accolades {} apr\u00e8s le signe dollar $ . Par exemple : fun main() { //sampleStart val clients = 10 println(\"Il y a $clients clients\") // Il y a 10 clients println(\"Il y a ${clients + 1} clients\") // Il y a 11 clients //sampleEnd } Pour plus d'informations, voir Gabarits de cha\u00eene . Vous remarquerez qu'il n'y a pas de types d\u00e9clar\u00e9s pour les variables. Kotlin a inf\u00e9r\u00e9 le type lui-m\u00eame : Int . Ce parcours explique les diff\u00e9rents types de base de Kotlin et comment les d\u00e9clarer dans le chapitre suivant .","title":"Gabarits de cha\u00eene"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/02-variables/#pratique","text":"","title":"Pratique"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/02-variables/#exercice","text":"Compl\u00e9tez le code pour que le programme imprime \"Mary a 20 ans\" en sortie standard : fun main() { val nom = \"Mary\" val age = 20 // Ecrivez votre code ici } R\u00e9ponse fun main() { val nom = \"Mary\" val age = 20 println(\"$nom a $age ans\") }","title":"Exercice"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/03-types/","text":"Types de base Source Chaque variable et structure de donn\u00e9es en Kotlin ont un type de donn\u00e9es. Les types de donn\u00e9es sont importants, car ils indiquent au compilateur ce que vous avez le droit de faire avec cette variable ou structure de donn\u00e9es. En d'autres termes, quelles fonctions et propri\u00e9t\u00e9s, elles poss\u00e8dent. Dans le dernier chapitre, Kotlin a pu d\u00e9duire dans l'exemple pr\u00e9c\u00e9dent que customers est de type : Int . La capacit\u00e9 de Kotlin \u00e0 d\u00e9duire le type de donn\u00e9es est appel\u00e9e inf\u00e9rence de type . customers se voit attribuer une valeur enti\u00e8re. De cela, Kotlin d\u00e9duit que customers a un type de donn\u00e9es num\u00e9rique : Int . Par cons\u00e9quent, le compilateur sait que vous pouvez effectuer des op\u00e9rations arithm\u00e9tiques avec customers : fun main() { //sampleStart var customers = 10 // Certains clients quittent la file d'attente customers = 8 customers = customers + 3 // Exemple d'addition : 11 customers += 7 // Exemple d'addition : 18 customers -= 3 // Exemple de soustraction : 15 customers *= 2 // Exemple de multiplication : 30 customers /= 3 // Exemple de division : 10 println(customers) // 10 //sampleEnd } += , -= , *= , /= , et %= sont des op\u00e9rateurs d'affectation augment\u00e9s. Pour plus d'informations, voir Affectations augment\u00e9es . Au total, Kotlin a les types de base suivants : Cat\u00e9gorie Types de base Entiers Byte , Short , Int , Long Entiers non sign\u00e9s UByte , UShort , UInt , ULong Nombres \u00e0 virgule flottante Float , Double Bool\u00e9ens Boolean Caract\u00e8res Char Cha\u00eenes String Pour plus d'informations sur les types de base et leurs propri\u00e9t\u00e9s, voir Types de base . Avec ces connaissances, vous pouvez d\u00e9clarer des variables et les initialiser plus tard. Kotlin peut g\u00e9rer cela tant que les variables sont initialis\u00e9es avant la premi\u00e8re lecture. Pour d\u00e9clarer une variable sans l'initialiser, sp\u00e9cifiez son type avec : . Par exemple : fun main() { //sampleStart // Variable d\u00e9clar\u00e9e sans initialisation val d: Int // Variable initialis\u00e9e d = 3 // Variable de type explicite et initialis\u00e9e val e: String = \"hello\" // Les variables peuvent \u00eatre lues car elles ont \u00e9t\u00e9 initialis\u00e9es println(d) // 3 println(e) // hello //sampleEnd } Maintenant que vous savez comment d\u00e9clarer des types de base, il est temps d'en savoir plus sur les collections . Pratique Exercice D\u00e9clarez explicitement le type correct pour chaque variable : fun main() { val a = 1000 val b = \"log message\" val c = 3.14 val d = 100_000_000_000_000 val e = false val f = '\\n' } R\u00e9ponse fun main() { val a: Int = 1000 val b: String = \"log message\" val c: Double = 3.14 val d: Long = 100_000_000_000 val e: Boolean = false val f: Char = '\\n' }","title":"Types de base"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/03-types/#types-de-base","text":"Source Chaque variable et structure de donn\u00e9es en Kotlin ont un type de donn\u00e9es. Les types de donn\u00e9es sont importants, car ils indiquent au compilateur ce que vous avez le droit de faire avec cette variable ou structure de donn\u00e9es. En d'autres termes, quelles fonctions et propri\u00e9t\u00e9s, elles poss\u00e8dent. Dans le dernier chapitre, Kotlin a pu d\u00e9duire dans l'exemple pr\u00e9c\u00e9dent que customers est de type : Int . La capacit\u00e9 de Kotlin \u00e0 d\u00e9duire le type de donn\u00e9es est appel\u00e9e inf\u00e9rence de type . customers se voit attribuer une valeur enti\u00e8re. De cela, Kotlin d\u00e9duit que customers a un type de donn\u00e9es num\u00e9rique : Int . Par cons\u00e9quent, le compilateur sait que vous pouvez effectuer des op\u00e9rations arithm\u00e9tiques avec customers : fun main() { //sampleStart var customers = 10 // Certains clients quittent la file d'attente customers = 8 customers = customers + 3 // Exemple d'addition : 11 customers += 7 // Exemple d'addition : 18 customers -= 3 // Exemple de soustraction : 15 customers *= 2 // Exemple de multiplication : 30 customers /= 3 // Exemple de division : 10 println(customers) // 10 //sampleEnd } += , -= , *= , /= , et %= sont des op\u00e9rateurs d'affectation augment\u00e9s. Pour plus d'informations, voir Affectations augment\u00e9es . Au total, Kotlin a les types de base suivants : Cat\u00e9gorie Types de base Entiers Byte , Short , Int , Long Entiers non sign\u00e9s UByte , UShort , UInt , ULong Nombres \u00e0 virgule flottante Float , Double Bool\u00e9ens Boolean Caract\u00e8res Char Cha\u00eenes String Pour plus d'informations sur les types de base et leurs propri\u00e9t\u00e9s, voir Types de base . Avec ces connaissances, vous pouvez d\u00e9clarer des variables et les initialiser plus tard. Kotlin peut g\u00e9rer cela tant que les variables sont initialis\u00e9es avant la premi\u00e8re lecture. Pour d\u00e9clarer une variable sans l'initialiser, sp\u00e9cifiez son type avec : . Par exemple : fun main() { //sampleStart // Variable d\u00e9clar\u00e9e sans initialisation val d: Int // Variable initialis\u00e9e d = 3 // Variable de type explicite et initialis\u00e9e val e: String = \"hello\" // Les variables peuvent \u00eatre lues car elles ont \u00e9t\u00e9 initialis\u00e9es println(d) // 3 println(e) // hello //sampleEnd } Maintenant que vous savez comment d\u00e9clarer des types de base, il est temps d'en savoir plus sur les collections .","title":"Types de base"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/03-types/#pratique","text":"","title":"Pratique"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/03-types/#exercice","text":"D\u00e9clarez explicitement le type correct pour chaque variable : fun main() { val a = 1000 val b = \"log message\" val c = 3.14 val d = 100_000_000_000_000 val e = false val f = '\\n' } R\u00e9ponse fun main() { val a: Int = 1000 val b: String = \"log message\" val c: Double = 3.14 val d: Long = 100_000_000_000 val e: Boolean = false val f: Char = '\\n' }","title":"Exercice"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/04-collections/","text":"Collections Source Lors de la programmation, il est utile de pouvoir regrouper des donn\u00e9es dans des structures pour un traitement ult\u00e9rieur. Kotlin fournit des collections pour cet exact propos. Kotlin a les collections suivantes pour regrouper les \u00e9l\u00e9ments : Type de collection Description Listes Collections ordonn\u00e9es d'\u00e9l\u00e9ments Ensembles Collections non ordonn\u00e9es uniques d'\u00e9l\u00e9ments Mappes Ensembles de paires cl\u00e9-valeur o\u00f9 les cl\u00e9s sont uniques et associent \u00e0 une seule valeur Chaque type de collection peut \u00eatre modifiable ou en lecture seule. Liste Les listes stockent les \u00e9l\u00e9ments dans l'ordre dans lequel ils sont ajout\u00e9s, et autorisent des \u00e9l\u00e9ments en double. Pour cr\u00e9er une liste en lecture seule ( List ), utilisez la fonction listOf() . Pour cr\u00e9er une liste modifiable ( MutableList ), utilisez la fonction mutableListOf() . Lors de la cr\u00e9ation de listes, Kotlin peut inf\u00e9rer le type des \u00e9l\u00e9ments stock\u00e9s. Pour d\u00e9clarer le type explicitement, ajoutez le type entre des crochets <> apr\u00e8s la d\u00e9claration de liste : fun main() { //sampleStart // Liste en lecture seule val formesLectureSeule = listOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(formesLectureSeule) // [triangle, carr\u00e9, cercle] // Liste modifiable avec d\u00e9claration de type explicite val formes: MutableList<String> = mutableListOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(formes) // [triangle, carr\u00e9, cercle] //sampleEnd } Pour pr\u00e9venir les modifications ind\u00e9sirables, vous pouvez obtenir des vues en lecture seule de listes modifiables en les affectant \u00e0 une List : val formes: MutableList<String> = mutableListOf(\"triangle\", \"carr\u00e9\", \"cercle\") val formesVerrouill\u00e9es: List<String> = formes Ceci est \u00e9galement appel\u00e9 casting en anglais. Les listes sont ordonn\u00e9es donc pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment dans une liste, utilisez l' op\u00e9rateur d'acc\u00e8s index\u00e9 [] : fun main() { //sampleStart val formesLectureSeule = listOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(\"Le premier \u00e9l\u00e9ment de la liste est : ${formesLectureSeule[0]}\") // Le premier \u00e9l\u00e9ment de la liste est: triangle //sampleEnd } Pour obtenir le premier ou le dernier \u00e9l\u00e9ment d'une liste, utilisez respectivement les fonctions .first() et .last() : fun main() { //sampleStart val formesLectureSeule = listOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(\"Le premier \u00e9l\u00e9ment de la liste est : ${formesLectureSeule.first()}\") // Le premier \u00e9l\u00e9ment de la liste est: triangle //sampleEnd } Les fonctions .first() et .last() sont des exemples de fonctions d'extension . Pour appeler une fonction d'extension sur un objet, \u00e9crivez le nom de la fonction apr\u00e8s l'objet en l'appendant avec un point . Pour plus d'informations sur les fonctions d'extension, voir Fonctions d'extensions . Pour les objectifs de cette visite, vous avez juste besoin de savoir comment les appeler. Pour obtenir le nombre d'\u00e9l\u00e9ments dans une liste, utilisez la fonction .count() : fun main() { //sampleStart val formesLectureSeule = listOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(\"Cette liste contient ${formesLectureSeule.count()} \u00e9l\u00e9ments\") // Cette liste contient 3 \u00e9l\u00e9ments //sampleEnd } Pour v\u00e9rifier qu'un \u00e9l\u00e9ment se trouve dans une liste, utilisez l' op\u00e9rateur in : fun main() { //sampleStart val formesLectureSeule = listOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(\"cercle\" in formesLectureSeule) // true //sampleEnd } Pour ajouter ou supprimer des \u00e9l\u00e9ments d'une liste modifiable, utilisez respectivement les fonctions .add() et .remove() : fun main() { //sampleStart val formes: MutableList<String> = mutableListOf(\"triangle\", \"carr\u00e9\", \"cercle\") // Ajoute \"pentagone\" \u00e0 la liste formes.add(\"pentagone\") println(formes) // [triangle, carr\u00e9, cercle, pentagone] // Supprime le premier \"pentagone\" de la liste formes.remove(\"pentagone\") println(formes) // [triangle, carr\u00e9, cercle] //sampleEnd } Ensemble Alors que les listes sont ordonn\u00e9es et autorisent des \u00e9l\u00e9ments en double, les ensembles sont non ordonn\u00e9s et stockent uniquement des \u00e9l\u00e9ments uniques . Pour cr\u00e9er un ensemble en lecture seule ( Set ), utilisez la fonction setOf() . Pour cr\u00e9er un ensemble modifiable ( MutableSet ), utilisez la fonction mutableSetOf() . Lors de la cr\u00e9ation des ensembles, Kotlin peut inf\u00e9rer le type des \u00e9l\u00e9ments stock\u00e9s. Pour d\u00e9clarer explicitement le type, ajoutez le type entre des crochets <> apr\u00e8s la d\u00e9claration de l'ensemble : fun main() { //sampleStart // Ensemble en lecture seule val fruitsLectureSeule = setOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") // Ensemble modifiable avec d\u00e9claration de type explicite val fruits: MutableSet<String> = mutableSetOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") println(fruitsLectureSeule) // [pomme, banane, cerise] //sampleEnd } Vous pouvez voir dans l'exemple pr\u00e9c\u00e9dent que comme les ensembles ne contiennent que des \u00e9l\u00e9ments uniques, l'\u00e9l\u00e9ment \"cerise\" en double est supprim\u00e9. Pour pr\u00e9venir les modifications ind\u00e9sirables, obtenez des vues en lecture seule des ensembles modifiables en les affectant \u00e0 Set : kotlin val fruits: MutableSet<String> = mutableSetOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") val fruitsVerrouill\u00e9s: Set<String> = fruits Comme les ensembles sont non ordonn\u00e9s , vous ne pouvez pas acc\u00e9der \u00e0 un \u00e9l\u00e9ment \u00e0 un index particulier. Pour obtenir le nombre d'\u00e9l\u00e9ments dans un ensemble, utilisez la fonction .count() : fun main() { //sampleStart val fruitsLectureSeule = setOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") println(\"Cet ensemble contient ${fruitsLectureSeule.count()} \u00e9l\u00e9ments\") // Cet ensemble contient 3 \u00e9l\u00e9ments //sampleEnd } Pour v\u00e9rifier qu'un \u00e9l\u00e9ment se trouve dans un ensemble, utilisez l' op\u00e9rateur in : fun main() { //sampleStart val fruitsLectureSeule = setOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") println(\"banane\" in fruitsLectureSeule) // true //sampleEnd } Pour ajouter ou supprimer des \u00e9l\u00e9ments d'un ensemble modifiable, utilisez respectivement les fonctions .add() et .remove() : fun main() { //sampleStart val fruits: MutableSet<String> = mutableSetOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") fruits.add(\"dragonfruit\") // Ajoute \"dragonfruit\" \u00e0 l'ensemble println(fruits) // [pomme, banane, cerise, dragonfruit] fruits.remove(\"dragonfruit\") // Supprime \"dragonfruit\" de l'ensemble println(fruits) // [pomme, banane, cerise] //sampleEnd } Pour obtenir une collection des cl\u00e9s ou des valeurs d'une mappe, utilisez les propri\u00e9t\u00e9s keys et values respectivement : fun main() { //sampleStart val menuJusLectureSeule = mapOf(\"pomme\" to 100, \"kiwi\" to 190, \"orange\" to 100) println(menuJusLectureSeule.keys) // [pomme, kiwi, orange] println(menuJusLectureSeule.values) // [100, 190, 100] //sampleEnd } keys et values sont des exemples de * propri\u00e9t\u00e9s * d'un objet. Pour acc\u00e9der \u00e0 la propri\u00e9t\u00e9 d'un objet, \u00e9crivez le nom de la propri\u00e9t\u00e9 apr\u00e8s l'objet, en ajoutant un point . . Les propri\u00e9t\u00e9s sont discut\u00e9es plus en d\u00e9tail dans le chapitre Classes . \u00c0 ce stade de la visite, vous devez seulement savoir comment y acc\u00e9der. Pour v\u00e9rifier qu'une cl\u00e9 ou une valeur est dans une mappe, utilisez l' op\u00e9rateur in : fun main() { //sampleStart val menuJusLectureSeule = mapOf(\"pomme\" to 100, \"kiwi\" to 190, \"orange\" to 100) println(\"orange\" in menuJusLectureSeule.keys) // true println(200 in menuJusLectureSeule.values) // false //sampleEnd } Pour plus d'informations sur ce que vous pouvez faire avec les collections, voir Collections . Maintenant que vous connaissez les types de base et comment g\u00e9rer les collections, il est temps d'explorer la logique de contr\u00f4le que vous pouvez utiliser dans vos programmes. Pratique Exercice 1 Vous disposez d'une liste de nombres \"verts\" et d'une liste de nombres \"rouges\". Compl\u00e9tez le code pour imprimer combien de nombres il y a en tout. fun main() { val nombresVerts = listOf(1, 4, 23) val nombresRouges = listOf(17, 2) // \u00c9crivez votre code ici } R\u00e9ponse fun main() { val nombresVerts = listOf(1, 4, 23) val nombresRouges = listOf(17, 2) val totalCount = nombresVerts.count() + nombresRouges.count() println(totalCount) } Exercice 2 Vous avez un ensemble de protocoles pris en charge par votre serveur. Un utilisateur demande \u00e0 utiliser un protocole particulier. Compl\u00e9tez le programme pour v\u00e9rifier si le protocole demand\u00e9 est pris en charge ou non ( isSupported doit \u00eatre une valeur bool\u00e9enne). fun main() { val SUPPORTED = setOf(\"HTTP\", \"HTTPS\", \"FTP\") val requested = \"smtp\" val isSupported = // \u00c9crivez votre code ici println(\"Support pour $requested: $isSupported\") } Astuce Assurez-vous de v\u00e9rifier le protocole demand\u00e9 en majuscule. Vous pouvez utiliser la fonction .uppercase() pour vous aider. R\u00e9ponse fun main() { val SUPPORTED = setOf(\"HTTP\", \"HTTPS\", \"FTP\") val requested = \"smtp\" val isSupported = requested.uppercase() in SUPPORTED println(\"Support pour $requested: $isSupported\") } Exercice 3 D\u00e9finissez une mappe qui relie les nombres entiers de 1 \u00e0 3 \u00e0 leur orthographe correspondante. Utilisez cette mappe pour \u00e9peler le nombre donn\u00e9. fun main() { val number2word = // \u00c9crivez votre code ici val n = 2 println(\"$n est \u00e9pel\u00e9 comme '${<\u00c9crivez votre code ici>}'\") } R\u00e9ponse fun main() { val number2word = mapOf(1 to \"un\", 2 to \"deux\", 3 to \"trois\") val n = 2 println(\"$n est \u00e9pel\u00e9 comme '${number2word[n]}'\") }","title":"Collections"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/04-collections/#collections","text":"Source Lors de la programmation, il est utile de pouvoir regrouper des donn\u00e9es dans des structures pour un traitement ult\u00e9rieur. Kotlin fournit des collections pour cet exact propos. Kotlin a les collections suivantes pour regrouper les \u00e9l\u00e9ments : Type de collection Description Listes Collections ordonn\u00e9es d'\u00e9l\u00e9ments Ensembles Collections non ordonn\u00e9es uniques d'\u00e9l\u00e9ments Mappes Ensembles de paires cl\u00e9-valeur o\u00f9 les cl\u00e9s sont uniques et associent \u00e0 une seule valeur Chaque type de collection peut \u00eatre modifiable ou en lecture seule.","title":"Collections"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/04-collections/#liste","text":"Les listes stockent les \u00e9l\u00e9ments dans l'ordre dans lequel ils sont ajout\u00e9s, et autorisent des \u00e9l\u00e9ments en double. Pour cr\u00e9er une liste en lecture seule ( List ), utilisez la fonction listOf() . Pour cr\u00e9er une liste modifiable ( MutableList ), utilisez la fonction mutableListOf() . Lors de la cr\u00e9ation de listes, Kotlin peut inf\u00e9rer le type des \u00e9l\u00e9ments stock\u00e9s. Pour d\u00e9clarer le type explicitement, ajoutez le type entre des crochets <> apr\u00e8s la d\u00e9claration de liste : fun main() { //sampleStart // Liste en lecture seule val formesLectureSeule = listOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(formesLectureSeule) // [triangle, carr\u00e9, cercle] // Liste modifiable avec d\u00e9claration de type explicite val formes: MutableList<String> = mutableListOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(formes) // [triangle, carr\u00e9, cercle] //sampleEnd } Pour pr\u00e9venir les modifications ind\u00e9sirables, vous pouvez obtenir des vues en lecture seule de listes modifiables en les affectant \u00e0 une List : val formes: MutableList<String> = mutableListOf(\"triangle\", \"carr\u00e9\", \"cercle\") val formesVerrouill\u00e9es: List<String> = formes Ceci est \u00e9galement appel\u00e9 casting en anglais. Les listes sont ordonn\u00e9es donc pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment dans une liste, utilisez l' op\u00e9rateur d'acc\u00e8s index\u00e9 [] : fun main() { //sampleStart val formesLectureSeule = listOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(\"Le premier \u00e9l\u00e9ment de la liste est : ${formesLectureSeule[0]}\") // Le premier \u00e9l\u00e9ment de la liste est: triangle //sampleEnd } Pour obtenir le premier ou le dernier \u00e9l\u00e9ment d'une liste, utilisez respectivement les fonctions .first() et .last() : fun main() { //sampleStart val formesLectureSeule = listOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(\"Le premier \u00e9l\u00e9ment de la liste est : ${formesLectureSeule.first()}\") // Le premier \u00e9l\u00e9ment de la liste est: triangle //sampleEnd } Les fonctions .first() et .last() sont des exemples de fonctions d'extension . Pour appeler une fonction d'extension sur un objet, \u00e9crivez le nom de la fonction apr\u00e8s l'objet en l'appendant avec un point . Pour plus d'informations sur les fonctions d'extension, voir Fonctions d'extensions . Pour les objectifs de cette visite, vous avez juste besoin de savoir comment les appeler. Pour obtenir le nombre d'\u00e9l\u00e9ments dans une liste, utilisez la fonction .count() : fun main() { //sampleStart val formesLectureSeule = listOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(\"Cette liste contient ${formesLectureSeule.count()} \u00e9l\u00e9ments\") // Cette liste contient 3 \u00e9l\u00e9ments //sampleEnd } Pour v\u00e9rifier qu'un \u00e9l\u00e9ment se trouve dans une liste, utilisez l' op\u00e9rateur in : fun main() { //sampleStart val formesLectureSeule = listOf(\"triangle\", \"carr\u00e9\", \"cercle\") println(\"cercle\" in formesLectureSeule) // true //sampleEnd } Pour ajouter ou supprimer des \u00e9l\u00e9ments d'une liste modifiable, utilisez respectivement les fonctions .add() et .remove() : fun main() { //sampleStart val formes: MutableList<String> = mutableListOf(\"triangle\", \"carr\u00e9\", \"cercle\") // Ajoute \"pentagone\" \u00e0 la liste formes.add(\"pentagone\") println(formes) // [triangle, carr\u00e9, cercle, pentagone] // Supprime le premier \"pentagone\" de la liste formes.remove(\"pentagone\") println(formes) // [triangle, carr\u00e9, cercle] //sampleEnd }","title":"Liste"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/04-collections/#ensemble","text":"Alors que les listes sont ordonn\u00e9es et autorisent des \u00e9l\u00e9ments en double, les ensembles sont non ordonn\u00e9s et stockent uniquement des \u00e9l\u00e9ments uniques . Pour cr\u00e9er un ensemble en lecture seule ( Set ), utilisez la fonction setOf() . Pour cr\u00e9er un ensemble modifiable ( MutableSet ), utilisez la fonction mutableSetOf() . Lors de la cr\u00e9ation des ensembles, Kotlin peut inf\u00e9rer le type des \u00e9l\u00e9ments stock\u00e9s. Pour d\u00e9clarer explicitement le type, ajoutez le type entre des crochets <> apr\u00e8s la d\u00e9claration de l'ensemble : fun main() { //sampleStart // Ensemble en lecture seule val fruitsLectureSeule = setOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") // Ensemble modifiable avec d\u00e9claration de type explicite val fruits: MutableSet<String> = mutableSetOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") println(fruitsLectureSeule) // [pomme, banane, cerise] //sampleEnd } Vous pouvez voir dans l'exemple pr\u00e9c\u00e9dent que comme les ensembles ne contiennent que des \u00e9l\u00e9ments uniques, l'\u00e9l\u00e9ment \"cerise\" en double est supprim\u00e9. Pour pr\u00e9venir les modifications ind\u00e9sirables, obtenez des vues en lecture seule des ensembles modifiables en les affectant \u00e0 Set : kotlin val fruits: MutableSet<String> = mutableSetOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") val fruitsVerrouill\u00e9s: Set<String> = fruits Comme les ensembles sont non ordonn\u00e9s , vous ne pouvez pas acc\u00e9der \u00e0 un \u00e9l\u00e9ment \u00e0 un index particulier. Pour obtenir le nombre d'\u00e9l\u00e9ments dans un ensemble, utilisez la fonction .count() : fun main() { //sampleStart val fruitsLectureSeule = setOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") println(\"Cet ensemble contient ${fruitsLectureSeule.count()} \u00e9l\u00e9ments\") // Cet ensemble contient 3 \u00e9l\u00e9ments //sampleEnd } Pour v\u00e9rifier qu'un \u00e9l\u00e9ment se trouve dans un ensemble, utilisez l' op\u00e9rateur in : fun main() { //sampleStart val fruitsLectureSeule = setOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") println(\"banane\" in fruitsLectureSeule) // true //sampleEnd } Pour ajouter ou supprimer des \u00e9l\u00e9ments d'un ensemble modifiable, utilisez respectivement les fonctions .add() et .remove() : fun main() { //sampleStart val fruits: MutableSet<String> = mutableSetOf(\"pomme\", \"banane\", \"cerise\", \"cerise\") fruits.add(\"dragonfruit\") // Ajoute \"dragonfruit\" \u00e0 l'ensemble println(fruits) // [pomme, banane, cerise, dragonfruit] fruits.remove(\"dragonfruit\") // Supprime \"dragonfruit\" de l'ensemble println(fruits) // [pomme, banane, cerise] //sampleEnd } Pour obtenir une collection des cl\u00e9s ou des valeurs d'une mappe, utilisez les propri\u00e9t\u00e9s keys et values respectivement : fun main() { //sampleStart val menuJusLectureSeule = mapOf(\"pomme\" to 100, \"kiwi\" to 190, \"orange\" to 100) println(menuJusLectureSeule.keys) // [pomme, kiwi, orange] println(menuJusLectureSeule.values) // [100, 190, 100] //sampleEnd } keys et values sont des exemples de * propri\u00e9t\u00e9s * d'un objet. Pour acc\u00e9der \u00e0 la propri\u00e9t\u00e9 d'un objet, \u00e9crivez le nom de la propri\u00e9t\u00e9 apr\u00e8s l'objet, en ajoutant un point . . Les propri\u00e9t\u00e9s sont discut\u00e9es plus en d\u00e9tail dans le chapitre Classes . \u00c0 ce stade de la visite, vous devez seulement savoir comment y acc\u00e9der. Pour v\u00e9rifier qu'une cl\u00e9 ou une valeur est dans une mappe, utilisez l' op\u00e9rateur in : fun main() { //sampleStart val menuJusLectureSeule = mapOf(\"pomme\" to 100, \"kiwi\" to 190, \"orange\" to 100) println(\"orange\" in menuJusLectureSeule.keys) // true println(200 in menuJusLectureSeule.values) // false //sampleEnd } Pour plus d'informations sur ce que vous pouvez faire avec les collections, voir Collections . Maintenant que vous connaissez les types de base et comment g\u00e9rer les collections, il est temps d'explorer la logique de contr\u00f4le que vous pouvez utiliser dans vos programmes.","title":"Ensemble"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/04-collections/#pratique","text":"","title":"Pratique"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/04-collections/#exercice-1","text":"Vous disposez d'une liste de nombres \"verts\" et d'une liste de nombres \"rouges\". Compl\u00e9tez le code pour imprimer combien de nombres il y a en tout. fun main() { val nombresVerts = listOf(1, 4, 23) val nombresRouges = listOf(17, 2) // \u00c9crivez votre code ici } R\u00e9ponse fun main() { val nombresVerts = listOf(1, 4, 23) val nombresRouges = listOf(17, 2) val totalCount = nombresVerts.count() + nombresRouges.count() println(totalCount) }","title":"Exercice 1"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/04-collections/#exercice-2","text":"Vous avez un ensemble de protocoles pris en charge par votre serveur. Un utilisateur demande \u00e0 utiliser un protocole particulier. Compl\u00e9tez le programme pour v\u00e9rifier si le protocole demand\u00e9 est pris en charge ou non ( isSupported doit \u00eatre une valeur bool\u00e9enne). fun main() { val SUPPORTED = setOf(\"HTTP\", \"HTTPS\", \"FTP\") val requested = \"smtp\" val isSupported = // \u00c9crivez votre code ici println(\"Support pour $requested: $isSupported\") } Astuce Assurez-vous de v\u00e9rifier le protocole demand\u00e9 en majuscule. Vous pouvez utiliser la fonction .uppercase() pour vous aider. R\u00e9ponse fun main() { val SUPPORTED = setOf(\"HTTP\", \"HTTPS\", \"FTP\") val requested = \"smtp\" val isSupported = requested.uppercase() in SUPPORTED println(\"Support pour $requested: $isSupported\") }","title":"Exercice 2"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/04-collections/#exercice-3","text":"D\u00e9finissez une mappe qui relie les nombres entiers de 1 \u00e0 3 \u00e0 leur orthographe correspondante. Utilisez cette mappe pour \u00e9peler le nombre donn\u00e9. fun main() { val number2word = // \u00c9crivez votre code ici val n = 2 println(\"$n est \u00e9pel\u00e9 comme '${<\u00c9crivez votre code ici>}'\") } R\u00e9ponse fun main() { val number2word = mapOf(1 to \"un\", 2 to \"deux\", 3 to \"trois\") val n = 2 println(\"$n est \u00e9pel\u00e9 comme '${number2word[n]}'\") }","title":"Exercice 3"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/","text":"Flot de contr\u00f4le Source Comme les autres langages de programmation, Kotlin est capable de prendre des d\u00e9cisions en fonction de l'\u00e9valuation d'un fragment de code \u00e0 vrai. De tels fragments de code sont appel\u00e9s expressions conditionnelles . Kotlin est \u00e9galement capable de cr\u00e9er et naviguer \u00e0 travers des boucles. Expressions conditionnelles Kotlin propose if et when pour v\u00e9rifier des expressions conditionnelles. Si vous devez choisir entre if et when , nous vous recommandons d'utiliser when , car cela conduit \u00e0 des programmes plus robustes et plus s\u00fbrs. If Pour utiliser if , ajoutez l'expression conditionnelle entre parenth\u00e8ses () et l'action \u00e0 effectuer si le r\u00e9sultat est vrai \u00e0 l'int\u00e9rieur des accolades {} : fun main() { //sampleStart val d: Int val check = true if (check) { d = 1 } else { d = 2 } println(d) // 1 //sampleEnd } Il n'y a pas d'op\u00e9rateur ternaire condition ? then : else en Kotlin. En revanche, if peut \u00eatre utilis\u00e9 comme une expression. S'il n'y a qu'une seule ligne de code par action, les accolades {} sont facultatives : fun main() { //sampleStart val a = 1 val b = 2 println(if (a > b) a else b) // Returns a value: 2 //sampleEnd } When Utilisez when lorsque vous avez une expression conditionnelle avec plusieurs branches. when peut \u00eatre utilis\u00e9 soit comme une instruction, soit comme une expression. Voici un exemple d'utilisation de when en tant qu'instruction : Placez l'expression conditionnelle entre parenth\u00e8ses () et les actions \u00e0 effectuer \u00e0 l'int\u00e9rieur des accolades {} . Utilisez -> dans chaque branche pour s\u00e9parer chaque condition de chaque action. fun main() { //sampleStart val obj = \"Hello\" when (obj) { // V\u00e9rifie si obj est \u00e9gal \u00e0 \"1\" \"1\" -> println(\"Un\") // V\u00e9rifie si obj est \u00e9gal \u00e0 \"Hello\" \"Hello\" -> println(\"Salutation\") // Instruction par d\u00e9faut else -> println(\"Inconnu\") } // Salutation //sampleEnd } Notez que toutes les conditions des branches sont v\u00e9rifi\u00e9es s\u00e9quentiellement jusqu'\u00e0 ce que l'une d'entre elles soit satisfaite. Seule la premi\u00e8re branche ad\u00e9quate est donc ex\u00e9cut\u00e9e. Voici un exemple d'utilisation de when en tant qu'expression. La syntaxe when est imm\u00e9diatement assign\u00e9e \u00e0 une variable : fun main() { //sampleStart val obj = \"Hello\" val result = when (obj) { // Si obj est \u00e9gal \u00e0 \"1\", assigne \"Un\" \u00e0 result \"1\" -> \"Un\" // Si obj est \u00e9gal \u00e0 \"Hello\", assigne \"Salutation\" \u00e0 result \"Hello\" -> \"Salutation\" // Assign \"Inconnu\" \u00e0 result si aucune des conditions pr\u00e9c\u00e9dentes n'est satisfaite else -> \"Inconnu\" } println(result) // Salutation //sampleEnd } Si when est utilis\u00e9 comme une expression, la branche else est obligatoire, \u00e0 moins que le compilateur puisse d\u00e9tecter que tous les cas possibles sont couverts par les conditions des branches. L'exemple pr\u00e9c\u00e9dent a montr\u00e9 que when est utile pour faire correspondre une variable. when est \u00e9galement utile lorsque vous avez besoin de v\u00e9rifier une cha\u00eene d'expressions bool\u00e9ennes : fun main() { //sampleStart val temp = 18 val description = when { // Si temp < 0 est vrai, assigne \"voir froid\" \u00e0 description temp < 0 -> \"tr\u00e8s froid\" // Si temp < 10 est vrai, assigne \"un peu froid\" \u00e0 description temp < 10 -> \"un peu froid\" // Si temp < 20 est vrai, assigne \"chaud\" \u00e0 description temp < 20 -> \"chaud\" // Assigne \"tr\u00e8s chaud\" \u00e0 description si aucune des conditions pr\u00e9c\u00e9dentes n'est satisfaite else -> \"tr\u00e8s chaud\" } println(description) // chaud //sampleEnd } Intervalles Avant de parler des boucles, il est utile de savoir comment construire des intervalles pour que les boucles puissent les parcourir. La fa\u00e7on la plus courante de cr\u00e9er un intervalle en Kotlin est d'utiliser l'op\u00e9rateur .. . Par exemple, 1..4 \u00e9quivaut \u00e0 1, 2, 3, 4 . Pour d\u00e9clarer un intervalle qui n'inclut pas la valeur de fin, utilisez l'op\u00e9rateur ..< . Par exemple, 1..<4 \u00e9quivaut \u00e0 1, 2, 3 . Pour d\u00e9clarer un intervalle en ordre inverse, utilisez downTo. . Par exemple, 4 downTo 1 \u00e9quivaut \u00e0 4, 3, 2, 1 . Pour d\u00e9clarer un intervalle qui augmente en pas qui n'est pas de 1, utilisez step et la valeur d'incr\u00e9ment souhait\u00e9e. Par exemple, 1..5 step 2 \u00e9quivaut \u00e0 1, 3, 5 . Il est \u00e9galement possible de faire la m\u00eame chose avec des intervalles de caract\u00e8res Char : 'a'..'d' \u00e9quivaut \u00e0 'a', 'b', 'c', 'd' 'z' downTo 's' step 2 \u00e9quivaut \u00e0 'z', 'x', 'v', 't' Boucles Les deux structures de boucle les plus courantes en programmation sont for et while . Utilisez for pour it\u00e9rer sur une s\u00e9rie de valeurs et effectuer une action. Utilisez while pour poursuivre une action jusqu'\u00e0 ce qu'une condition particuli\u00e8re soit satisfaite. Pour En utilisant votre nouvelle connaissance des intervalles, vous pouvez cr\u00e9er une boucle for qui it\u00e8re sur les num\u00e9ros 1 \u00e0 5 et imprime le num\u00e9ro \u00e0 chaque fois. Placez l'it\u00e9rateur et l'intervalle entre parenth\u00e8ses () avec le mot-cl\u00e9 in . Ajoutez l'action que vous voulez terminer \u00e0 l'int\u00e9rieur des accolades {} : fun main() { //sampleStart for (number in 1..5) { // number est l'it\u00e9rateur et 1..5 est l'intervalle print(number) } // 12345 //sampleEnd } Les collections peuvent \u00e9galement \u00eatre parcourues par des boucles : fun main() { //sampleStart val cakes = listOf(\"carotte\", \"fromage\", \"chocolat\") for (cake in cakes) { println(\"Miam, c'est un g\u00e2teau \u00e0 la $cake!\") } // Miam, c'est un g\u00e2teau \u00e0 la carotte! // Miam, c'est un g\u00e2teau au fromage! // Miam, c'est un g\u00e2teau au chocolat! //sampleEnd } Tant que while peut \u00eatre utilis\u00e9 de deux fa\u00e7ons : Pour ex\u00e9cuter un bloc de code tant qu'une expression conditionnelle est vraie. ( while ) Pour ex\u00e9cuter le bloc de code en premier, puis v\u00e9rifier l'expression conditionnelle. ( do-while ) Dans le premier cas d'utilisation ( while ) : D\u00e9clarez l'expression conditionnelle pour que votre boucle continue entre parenth\u00e8ses () . Ajoutez l'action que vous voulez effectuer \u00e0 l'int\u00e9rieur des accolades {} . Les exemples suivants utilisent l' op\u00e9rateur d'incr\u00e9mentation ++ pour incr\u00e9menter la valeur de la variable g\u00e2teauxMang\u00e9s . fun main() { //sampleStart var g\u00e2teauxMang\u00e9s = 0 while (g\u00e2teauxMang\u00e9s < 3) { println(\"Mange un g\u00e2teau\") g\u00e2teauxMang\u00e9s++ } // Mange un g\u00e2teau // Mange un g\u00e2teau // Mange un g\u00e2teau //sampleEnd } Dans le second cas ( do-while ) : D\u00e9clarez l'expression conditionnelle pour que votre boucle continue entre parenth\u00e8ses () . D\u00e9finissez l'action que vous voulez effectuer entre les accolades {} avec le mot-cl\u00e9 do . fun main() { //sampleStart var g\u00e2teauxMang\u00e9s = 0 var g\u00e2teauxCuits = 0 while (g\u00e2teauxMang\u00e9s < 3) { println(\"Mange un g\u00e2teau\") g\u00e2teauxMang\u00e9s++ } do { println(\"Cuit un g\u00e2teau\") g\u00e2teauxCuits++ } while (g\u00e2teauxCuits < g\u00e2teauxMang\u00e9s) // Mange un g\u00e2teau // Mange un g\u00e2teau // Mange un g\u00e2teau // Cuit un g\u00e2teau // Cuit un g\u00e2teau // Cuit un g\u00e2teau //sampleEnd } Pour plus d'informations et d'exemples sur les expressions conditionnelles et les boucles, voir Conditions et boucles . Maintenant que vous connaissez les fondamentaux du flux de contr\u00f4le de Kotlin, il est temps d'apprendre comment \u00e9crire vos propres fonctions . Pratique Exercice 1 En utilisant une expression when , mettez \u00e0 jour le programme suivant de sorte que lorsque vous saisissez les noms des boutons du GameBoy, les actions soient affich\u00e9es en sortie. Bouton Action A Oui B Non X Menu Y Rien Autre Il n'y a pas de bouton de ce genre fun main() { val bouton = \"A\" println( // \u00c9crivez votre code ici ) } R\u00e9ponse fun main() { val bouton = \"A\" println( when (bouton) { \"A\" -> \"Oui\" \"B\" -> \"Non\" \"X\" -> \"Menu\" \"Y\" -> \"Rien\" else -> \"Il n'y a pas de bouton de ce genre\" } ) } Exercice 2 Vous avez un programme qui compte les tranches de pizza jusqu'\u00e0 ce qu'il y ait une pizza enti\u00e8re avec 8 tranches. Refactorisez ce programme de deux fa\u00e7ons : Utilisez une boucle while . Utilisez une boucle do-while . fun main() { var tranchesPizza = 0 // Commencez le refactoring ici tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ // Terminez le refactoring ici println(\"Il y a $tranchesPizza tranches de pizza. Hourra! Nous avons une pizza enti\u00e8re! :D\") } R\u00e9ponse fun main() { var tranchesPizza = 0 while (tranchesPizza < 7 ) { tranchesPizza++ println(\"Il n 'y a que $tranchesPizza tranche/s de pizza :(\") } tranchesPizza++ println(\"Il y a $tranchesPizza tranches de pizza. Hourra!Nous avons une pizza enti\u00e8re!:D\") } R\u00e9ponse fun main() { var tranchesPizza = 0 tranchesPizza++ do { println(\"Il n 'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ } while (tranchesPizza < 8 ) println(\"Il y a $tranchesPizza tranches de pizza. Hourra!Nous avons une pizza enti\u00e8re!:D\") } Exercice 3 \u00c9crivez un programme qui simule le jeu Fizz buzz . Votre t\u00e2che est d'imprimer les nombres de 1 \u00e0 100 de mani\u00e8re incr\u00e9mentielle, en rempla\u00e7ant tout nombre divisible par trois par le mot \"fizz\", et tout nombre divisible par cinq par le mot \"buzz\". Tout nombre divisible \u00e0 la fois par 3 et 5 doit \u00eatre remplac\u00e9 par le mot \"fizzbuzz\". Indice Utilisez une boucle for pour compter les num\u00e9ros et une expression when pour d\u00e9cider de ce qu'il faut imprimer \u00e0 chaque \u00e9tape. fun main() { // \u00c9crivez votre code ici } R\u00e9ponse fun main() { for (number in 1..100) { println( when { number % 15 == 0 -> \"fizzbuzz\" number % 3 == 0 -> \"fizz\" number % 5 == 0 -> \"buzz\" else -> \"$number\" } ) } } Exercice 4 Vous avez une liste de mots. Utilisez for et if pour imprimer seulement les mots qui commencent par la lettre l . Indice Utilisez la fonction .startsWith() pour le type String . fun main() { val mots = listOf(\"dinosaure\", \"limousine\", \"magazine\", \"langue\") // \u00c9crivez votre code ici } R\u00e9ponse fun main() { val mots = listOf(\"dinosaure\", \"limousine\", \"magazine\", \"langue\") for (m in mots) { if (m.startsWith(\"l\")) println(m) } }","title":"Flot de contr\u00f4le"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#flot-de-controle","text":"Source Comme les autres langages de programmation, Kotlin est capable de prendre des d\u00e9cisions en fonction de l'\u00e9valuation d'un fragment de code \u00e0 vrai. De tels fragments de code sont appel\u00e9s expressions conditionnelles . Kotlin est \u00e9galement capable de cr\u00e9er et naviguer \u00e0 travers des boucles.","title":"Flot de contr\u00f4le"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#expressions-conditionnelles","text":"Kotlin propose if et when pour v\u00e9rifier des expressions conditionnelles. Si vous devez choisir entre if et when , nous vous recommandons d'utiliser when , car cela conduit \u00e0 des programmes plus robustes et plus s\u00fbrs.","title":"Expressions conditionnelles"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#if","text":"Pour utiliser if , ajoutez l'expression conditionnelle entre parenth\u00e8ses () et l'action \u00e0 effectuer si le r\u00e9sultat est vrai \u00e0 l'int\u00e9rieur des accolades {} : fun main() { //sampleStart val d: Int val check = true if (check) { d = 1 } else { d = 2 } println(d) // 1 //sampleEnd } Il n'y a pas d'op\u00e9rateur ternaire condition ? then : else en Kotlin. En revanche, if peut \u00eatre utilis\u00e9 comme une expression. S'il n'y a qu'une seule ligne de code par action, les accolades {} sont facultatives : fun main() { //sampleStart val a = 1 val b = 2 println(if (a > b) a else b) // Returns a value: 2 //sampleEnd }","title":"If"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#when","text":"Utilisez when lorsque vous avez une expression conditionnelle avec plusieurs branches. when peut \u00eatre utilis\u00e9 soit comme une instruction, soit comme une expression. Voici un exemple d'utilisation de when en tant qu'instruction : Placez l'expression conditionnelle entre parenth\u00e8ses () et les actions \u00e0 effectuer \u00e0 l'int\u00e9rieur des accolades {} . Utilisez -> dans chaque branche pour s\u00e9parer chaque condition de chaque action. fun main() { //sampleStart val obj = \"Hello\" when (obj) { // V\u00e9rifie si obj est \u00e9gal \u00e0 \"1\" \"1\" -> println(\"Un\") // V\u00e9rifie si obj est \u00e9gal \u00e0 \"Hello\" \"Hello\" -> println(\"Salutation\") // Instruction par d\u00e9faut else -> println(\"Inconnu\") } // Salutation //sampleEnd } Notez que toutes les conditions des branches sont v\u00e9rifi\u00e9es s\u00e9quentiellement jusqu'\u00e0 ce que l'une d'entre elles soit satisfaite. Seule la premi\u00e8re branche ad\u00e9quate est donc ex\u00e9cut\u00e9e. Voici un exemple d'utilisation de when en tant qu'expression. La syntaxe when est imm\u00e9diatement assign\u00e9e \u00e0 une variable : fun main() { //sampleStart val obj = \"Hello\" val result = when (obj) { // Si obj est \u00e9gal \u00e0 \"1\", assigne \"Un\" \u00e0 result \"1\" -> \"Un\" // Si obj est \u00e9gal \u00e0 \"Hello\", assigne \"Salutation\" \u00e0 result \"Hello\" -> \"Salutation\" // Assign \"Inconnu\" \u00e0 result si aucune des conditions pr\u00e9c\u00e9dentes n'est satisfaite else -> \"Inconnu\" } println(result) // Salutation //sampleEnd } Si when est utilis\u00e9 comme une expression, la branche else est obligatoire, \u00e0 moins que le compilateur puisse d\u00e9tecter que tous les cas possibles sont couverts par les conditions des branches. L'exemple pr\u00e9c\u00e9dent a montr\u00e9 que when est utile pour faire correspondre une variable. when est \u00e9galement utile lorsque vous avez besoin de v\u00e9rifier une cha\u00eene d'expressions bool\u00e9ennes : fun main() { //sampleStart val temp = 18 val description = when { // Si temp < 0 est vrai, assigne \"voir froid\" \u00e0 description temp < 0 -> \"tr\u00e8s froid\" // Si temp < 10 est vrai, assigne \"un peu froid\" \u00e0 description temp < 10 -> \"un peu froid\" // Si temp < 20 est vrai, assigne \"chaud\" \u00e0 description temp < 20 -> \"chaud\" // Assigne \"tr\u00e8s chaud\" \u00e0 description si aucune des conditions pr\u00e9c\u00e9dentes n'est satisfaite else -> \"tr\u00e8s chaud\" } println(description) // chaud //sampleEnd }","title":"When"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#intervalles","text":"Avant de parler des boucles, il est utile de savoir comment construire des intervalles pour que les boucles puissent les parcourir. La fa\u00e7on la plus courante de cr\u00e9er un intervalle en Kotlin est d'utiliser l'op\u00e9rateur .. . Par exemple, 1..4 \u00e9quivaut \u00e0 1, 2, 3, 4 . Pour d\u00e9clarer un intervalle qui n'inclut pas la valeur de fin, utilisez l'op\u00e9rateur ..< . Par exemple, 1..<4 \u00e9quivaut \u00e0 1, 2, 3 . Pour d\u00e9clarer un intervalle en ordre inverse, utilisez downTo. . Par exemple, 4 downTo 1 \u00e9quivaut \u00e0 4, 3, 2, 1 . Pour d\u00e9clarer un intervalle qui augmente en pas qui n'est pas de 1, utilisez step et la valeur d'incr\u00e9ment souhait\u00e9e. Par exemple, 1..5 step 2 \u00e9quivaut \u00e0 1, 3, 5 . Il est \u00e9galement possible de faire la m\u00eame chose avec des intervalles de caract\u00e8res Char : 'a'..'d' \u00e9quivaut \u00e0 'a', 'b', 'c', 'd' 'z' downTo 's' step 2 \u00e9quivaut \u00e0 'z', 'x', 'v', 't'","title":"Intervalles"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#boucles","text":"Les deux structures de boucle les plus courantes en programmation sont for et while . Utilisez for pour it\u00e9rer sur une s\u00e9rie de valeurs et effectuer une action. Utilisez while pour poursuivre une action jusqu'\u00e0 ce qu'une condition particuli\u00e8re soit satisfaite.","title":"Boucles"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#pour","text":"En utilisant votre nouvelle connaissance des intervalles, vous pouvez cr\u00e9er une boucle for qui it\u00e8re sur les num\u00e9ros 1 \u00e0 5 et imprime le num\u00e9ro \u00e0 chaque fois. Placez l'it\u00e9rateur et l'intervalle entre parenth\u00e8ses () avec le mot-cl\u00e9 in . Ajoutez l'action que vous voulez terminer \u00e0 l'int\u00e9rieur des accolades {} : fun main() { //sampleStart for (number in 1..5) { // number est l'it\u00e9rateur et 1..5 est l'intervalle print(number) } // 12345 //sampleEnd } Les collections peuvent \u00e9galement \u00eatre parcourues par des boucles : fun main() { //sampleStart val cakes = listOf(\"carotte\", \"fromage\", \"chocolat\") for (cake in cakes) { println(\"Miam, c'est un g\u00e2teau \u00e0 la $cake!\") } // Miam, c'est un g\u00e2teau \u00e0 la carotte! // Miam, c'est un g\u00e2teau au fromage! // Miam, c'est un g\u00e2teau au chocolat! //sampleEnd }","title":"Pour"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#tant-que","text":"while peut \u00eatre utilis\u00e9 de deux fa\u00e7ons : Pour ex\u00e9cuter un bloc de code tant qu'une expression conditionnelle est vraie. ( while ) Pour ex\u00e9cuter le bloc de code en premier, puis v\u00e9rifier l'expression conditionnelle. ( do-while ) Dans le premier cas d'utilisation ( while ) : D\u00e9clarez l'expression conditionnelle pour que votre boucle continue entre parenth\u00e8ses () . Ajoutez l'action que vous voulez effectuer \u00e0 l'int\u00e9rieur des accolades {} . Les exemples suivants utilisent l' op\u00e9rateur d'incr\u00e9mentation ++ pour incr\u00e9menter la valeur de la variable g\u00e2teauxMang\u00e9s . fun main() { //sampleStart var g\u00e2teauxMang\u00e9s = 0 while (g\u00e2teauxMang\u00e9s < 3) { println(\"Mange un g\u00e2teau\") g\u00e2teauxMang\u00e9s++ } // Mange un g\u00e2teau // Mange un g\u00e2teau // Mange un g\u00e2teau //sampleEnd } Dans le second cas ( do-while ) : D\u00e9clarez l'expression conditionnelle pour que votre boucle continue entre parenth\u00e8ses () . D\u00e9finissez l'action que vous voulez effectuer entre les accolades {} avec le mot-cl\u00e9 do . fun main() { //sampleStart var g\u00e2teauxMang\u00e9s = 0 var g\u00e2teauxCuits = 0 while (g\u00e2teauxMang\u00e9s < 3) { println(\"Mange un g\u00e2teau\") g\u00e2teauxMang\u00e9s++ } do { println(\"Cuit un g\u00e2teau\") g\u00e2teauxCuits++ } while (g\u00e2teauxCuits < g\u00e2teauxMang\u00e9s) // Mange un g\u00e2teau // Mange un g\u00e2teau // Mange un g\u00e2teau // Cuit un g\u00e2teau // Cuit un g\u00e2teau // Cuit un g\u00e2teau //sampleEnd } Pour plus d'informations et d'exemples sur les expressions conditionnelles et les boucles, voir Conditions et boucles . Maintenant que vous connaissez les fondamentaux du flux de contr\u00f4le de Kotlin, il est temps d'apprendre comment \u00e9crire vos propres fonctions .","title":"Tant que"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#pratique","text":"","title":"Pratique"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#exercice-1","text":"En utilisant une expression when , mettez \u00e0 jour le programme suivant de sorte que lorsque vous saisissez les noms des boutons du GameBoy, les actions soient affich\u00e9es en sortie. Bouton Action A Oui B Non X Menu Y Rien Autre Il n'y a pas de bouton de ce genre fun main() { val bouton = \"A\" println( // \u00c9crivez votre code ici ) } R\u00e9ponse fun main() { val bouton = \"A\" println( when (bouton) { \"A\" -> \"Oui\" \"B\" -> \"Non\" \"X\" -> \"Menu\" \"Y\" -> \"Rien\" else -> \"Il n'y a pas de bouton de ce genre\" } ) }","title":"Exercice 1"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#exercice-2","text":"Vous avez un programme qui compte les tranches de pizza jusqu'\u00e0 ce qu'il y ait une pizza enti\u00e8re avec 8 tranches. Refactorisez ce programme de deux fa\u00e7ons : Utilisez une boucle while . Utilisez une boucle do-while . fun main() { var tranchesPizza = 0 // Commencez le refactoring ici tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ println(\"Il n'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ // Terminez le refactoring ici println(\"Il y a $tranchesPizza tranches de pizza. Hourra! Nous avons une pizza enti\u00e8re! :D\") } R\u00e9ponse fun main() { var tranchesPizza = 0 while (tranchesPizza < 7 ) { tranchesPizza++ println(\"Il n 'y a que $tranchesPizza tranche/s de pizza :(\") } tranchesPizza++ println(\"Il y a $tranchesPizza tranches de pizza. Hourra!Nous avons une pizza enti\u00e8re!:D\") } R\u00e9ponse fun main() { var tranchesPizza = 0 tranchesPizza++ do { println(\"Il n 'y a que $tranchesPizza tranche/s de pizza :(\") tranchesPizza++ } while (tranchesPizza < 8 ) println(\"Il y a $tranchesPizza tranches de pizza. Hourra!Nous avons une pizza enti\u00e8re!:D\") }","title":"Exercice 2"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#exercice-3","text":"\u00c9crivez un programme qui simule le jeu Fizz buzz . Votre t\u00e2che est d'imprimer les nombres de 1 \u00e0 100 de mani\u00e8re incr\u00e9mentielle, en rempla\u00e7ant tout nombre divisible par trois par le mot \"fizz\", et tout nombre divisible par cinq par le mot \"buzz\". Tout nombre divisible \u00e0 la fois par 3 et 5 doit \u00eatre remplac\u00e9 par le mot \"fizzbuzz\". Indice Utilisez une boucle for pour compter les num\u00e9ros et une expression when pour d\u00e9cider de ce qu'il faut imprimer \u00e0 chaque \u00e9tape. fun main() { // \u00c9crivez votre code ici } R\u00e9ponse fun main() { for (number in 1..100) { println( when { number % 15 == 0 -> \"fizzbuzz\" number % 3 == 0 -> \"fizz\" number % 5 == 0 -> \"buzz\" else -> \"$number\" } ) } }","title":"Exercice 3"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/05-flot/#exercice-4","text":"Vous avez une liste de mots. Utilisez for et if pour imprimer seulement les mots qui commencent par la lettre l . Indice Utilisez la fonction .startsWith() pour le type String . fun main() { val mots = listOf(\"dinosaure\", \"limousine\", \"magazine\", \"langue\") // \u00c9crivez votre code ici } R\u00e9ponse fun main() { val mots = listOf(\"dinosaure\", \"limousine\", \"magazine\", \"langue\") for (m in mots) { if (m.startsWith(\"l\")) println(m) } }","title":"Exercice 4"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/","text":"Fonctions Source Vous pouvez d\u00e9clarer vos propres fonctions en Kotlin en utilisant le mot-cl\u00e9 fun . fun hello() { return println(\"Bonjour, monde!\") } fun main() { hello() // Bonjour, monde! } En Kotlin: les param\u00e8tres de fonction sont \u00e9crits entre parenth\u00e8ses () . chaque param\u00e8tre doit avoir un type, et plusieurs param\u00e8tres doivent \u00eatre s\u00e9par\u00e9s par des virgules , . le type de retour est \u00e9crit apr\u00e8s les parenth\u00e8ses de la fonction () , s\u00e9par\u00e9 par un deux-points : . le corps d'une fonction est \u00e9crit entre accolades {} . le mot-cl\u00e9 return est utilis\u00e9 pour sortir ou retourner quelque chose d'une fonction. Si une fonction ne renvoie rien d'utile, le type de retour et le mot-cl\u00e9 return peuvent \u00eatre omis. Dans l'exemple suivant : x et y sont des param\u00e8tres de fonction. x et y ont le type Int . le type de retour de la fonction est Int . la fonction renvoie une somme de x et y lorsqu'elle est appel\u00e9e. fun sum(x: Int, y: Int): Int { return x + y } fun main() { println(sum(1, 2)) // 3 } Nous recommandons dans nos conventions de codage que vous nommiez les fonctions en commen\u00e7ant par une lettre minuscule et utilisez camel case sans tirets du bas. Arguments nomm\u00e9s Pour un code concis, lors de l'appel de votre fonction, vous n'avez pas besoin d'inclure les noms des param\u00e8tres. Cependant, l'inclusion des noms des param\u00e8tres rend votre code plus facile \u00e0 lire. C'est ce qu'on appelle l'utilisation des arguments nomm\u00e9s . Si vous incluez les noms des param\u00e8tres, vous pouvez alors \u00e9crire les param\u00e8tres dans n'importe quel ordre. Dans l'exemple suivant, les templates de cha\u00eenes de caract\u00e8res ( $ ) sont utilis\u00e9s pour acc\u00e9der aux valeurs des param\u00e8tres, les convertir en type String , puis les concat\u00e9ner en une cha\u00eene pour l'impression. fun printMessageWithPrefix(message: String, prefix: String) { println(\"[$prefix] $message\") } fun main() { // Utilise des arguments nomm\u00e9s avec l'ordre des param\u00e8tres invers\u00e9 printMessageWithPrefix(prefix = \"Log\", message = \"Bonjour\") // [Log] Bonjour } Valeurs par d\u00e9faut des param\u00e8tres Vous pouvez d\u00e9finir des valeurs par d\u00e9faut pour vos param\u00e8tres de fonction. Tout param\u00e8tre ayant une valeur par d\u00e9faut peut \u00eatre omis lors de l'appel de votre fonction. Pour d\u00e9clarer une valeur par d\u00e9faut, utilisez l'op\u00e9rateur d'affectation = apr\u00e8s le type : fun printMessageWithPrefix(message: String, prefix: String = \"Info\") { println(\"[$prefix] $message\") } fun main() { // Fonction appel\u00e9e avec les deux param\u00e8tres printMessageWithPrefix(\"Bonjour\", \"Log\") // [Log] Bonjour // Fonction appel\u00e9e uniquement avec le param\u00e8tre message printMessageWithPrefix(\"Bonjour\") // [Info] Bonjour printMessageWithPrefix(prefix = \"Log\", message = \"Bonjour\") // [Log] Bonjour } Vous pouvez omettre des param\u00e8tres sp\u00e9cifiques ayant des valeurs par d\u00e9faut, plut\u00f4t que de tous les omettre. Cependant, apr\u00e8s le premier param\u00e8tre omis, vous devez nommer tous les param\u00e8tres suivants. Fonctions sans retour Si votre fonction ne renvoie pas de valeur utile, alors son type de retour est Unit . Unit est un type avec une seule valeur - Unit . Vous n'avez pas \u00e0 d\u00e9clarer explicitement dans le corps de votre fonction que Unit est renvoy\u00e9. Cela signifie que vous n'avez pas \u00e0 utiliser le mot-cl\u00e9 return ou d\u00e9clarer un type de retour : fun printMessage(message: String) { println(message) // `return Unit` ou `return` est optionnel } fun main() { printMessage(\"Bonjour\") // Bonjour } Fonctions \u00e0 expression unique Pour rendre votre code plus concis, vous pouvez utiliser des fonctions \u00e0 expression unique. Par exemple, la fonction sum() peut \u00eatre raccourcie : fun sum(x: Int, y: Int): Int { return x + y } fun main() { println(sum(1, 2)) // 3 } Vous pouvez retirer les accolades {} et d\u00e9clarer le corps de la fonction en utilisant l'op\u00e9rateur d'affectation = . Et gr\u00e2ce \u00e0 l'inf\u00e9rence de types de Kotlin, vous pouvez \u00e9galement omettre le type de retour. La fonction sum() devient alors une ligne : fun sum(x: Int, y: Int) = x + y fun main() { println(sum(1, 2)) // 3 } Omettre le type de retour n'est possible que lorsque votre fonction n'a pas de corps ( {} ). \u00c0 moins que le type de retour de votre fonction ne soit Unit . Pratique des fonctions Exercice 1 \u00c9crivez une fonction appel\u00e9e circleArea qui prend le rayon d'un cercle au format entier comme param\u00e8tre et affiche l'aire de ce cercle. Dans cet exercice, vous importez un package afin de pouvoir acc\u00e9der \u00e0 la valeur de pi via PI . Pour plus d'informations sur l'importation de packages, voir Packages and imports . import kotlin.math.PI fun circleArea() { // \u00c9crivez votre code ici } fun main() { println(circleArea(2)) } R\u00e9ponse import kotlin.math.PI fun circleArea(radius: Int): Double { return PI * radius * radius } fun main() { println(circleArea(2)) // 12.566370614359172 } Exercice 2 R\u00e9\u00e9crivez la fonction circleArea de l'exercice pr\u00e9c\u00e9dent comme une fonction \u00e0 expression unique. import kotlin.math.PI // \u00c9crivez votre code ici fun main() { println(circleArea(2)) } R\u00e9ponse import kotlin.math.PI fun circleArea(radius: Int): Double = PI * radius * radius fun main() { println(circleArea(2)) // 12.566370614359172 } Exercice 3 Vous avez une fonction qui traduit un intervalle de temps donn\u00e9 en heures, minutes et secondes en secondes. Dans la plupart des cas, vous devez passer seulement un ou deux param\u00e8tres de fonction alors que le reste est \u00e9gal \u00e0 0. Am\u00e9liorez la fonction et le code qui l'appelle en utilisant des valeurs par d\u00e9faut pour les param\u00e8tres et des arguments nomm\u00e9s afin que le code soit plus facile \u00e0 lire. fun intervalInSeconds(hours: Int, minutes: Int, seconds: Int) = ((hours * 60) + minutes) * 60 + seconds fun main() { println(intervalInSeconds(1, 20, 15)) println(intervalInSeconds(0, 1, 25)) println(intervalInSeconds(2, 0, 0)) println(intervalInSeconds(0, 10, 0)) println(intervalInSeconds(1, 0, 1)) } R\u00e9ponse fun intervalInSeconds(hours: Int = 0, minutes: Int = 0, seconds: Int = 0) = ((hours * 60) + minutes) * 60 + seconds fun main() { println(intervalInSeconds(1, 20, 15)) println(intervalInSeconds(minutes = 1, seconds = 25)) println(intervalInSeconds(hours = 2)) println(intervalInSeconds(minutes = 10)) println(intervalInSeconds(hours = 1, seconds = 1)) } Expressions lambda Kotlin vous permet d'\u00e9crire un code encore plus concis pour les fonctions en utilisant des expressions lambda. Par exemple, la fonction uppercaseString() suivante : fun uppercaseString(text: String): String { return text.uppercase() } fun main() { println(uppercaseString(\"bonjour\")) // BONJOUR } Peut \u00e9galement \u00eatre \u00e9crite comme une expression lambda : fun main() { println({ text: String -> text.uppercase() }(\"bonjour\")) // BONJOUR } Les expressions lambda peuvent \u00eatre difficiles \u00e0 comprendre \u00e0 premi\u00e8re vue, alors d\u00e9composons-les. Les expressions lambda sont \u00e9crites entre accolades {} . Dans l'expression lambda, vous \u00e9crivez : les param\u00e8tres suivis par un -> . le corps de la fonction apr\u00e8s le -> . Dans l'exemple pr\u00e9c\u00e9dent : text est un param\u00e8tre de fonction. text a le type String . la fonction renvoie le r\u00e9sultat de la fonction .uppercase() appel\u00e9e sur text . Si vous d\u00e9clarez une lambda sans param\u00e8tres, alors il n'est pas n\u00e9cessaire d'utiliser -> . Par exemple : { println(\"Message de log\") } Les expressions lambda peuvent \u00eatre utilis\u00e9es de plusieurs fa\u00e7ons. Vous pouvez : attribuer une lambda \u00e0 une variable que vous pouvez ensuite invoquer plus tard passer une expression lambda comme param\u00e8tre \u00e0 une autre fonction retourner une expression lambda d'une fonction invoquer une expression lambda ind\u00e9pendamment Assigner \u00e0 une variable Pour attribuer une expression lambda \u00e0 une variable, utilisez l'op\u00e9rateur d'affectation = : fun main() { val UpperCaseString = { text: String -> text.uppercase() } println(UpperCaseString(\"bonjour\")) // BONJOUR } Passer \u00e0 une autre fonction Un excellent exemple de quand il est utile de passer une expression lambda \u00e0 une fonction est d'utiliser la fonction .filter() sur des collections : fun main() { //sampleStart val numbers = listOf(1, -2, 3, -4, 5, -6) val positives = numbers.filter { x -> x > 0 } val negatives = numbers.filter { x -> x < 0 } println(positives) // [1, 3, 5] println(negatives) // [-2, -4, -6] //sampleEnd } La fonction .filter() accepte une expression lambda en tant que pr\u00e9dicat : { x -> x > 0 } prend chaque \u00e9l\u00e9ment de la liste et ne renvoie que ceux qui sont positifs. { x -> x < 0 } prend chaque \u00e9l\u00e9ment de la liste et ne renvoie que ceux qui sont n\u00e9gatifs. Si une expression lambda est le seul param\u00e8tre de fonction, vous pouvez supprimer les parenth\u00e8ses de fonction () . Il s'agit d'un exemple de lambda de fin , qui est discut\u00e9 plus en d\u00e9tail \u00e0 la fin de ce chapitre. Un autre bon exemple est l'utilisation de la fonction .map() pour transformer les \u00e9l\u00e9ments d'une collection : fun main() { //sampleStart val numbers = listOf(1, -2, 3, -4, 5, -6) val doubled = numbers.map { x -> x * 2 } val tripled = numbers.map { x -> x * 3 } println(doubled) // [2, -4, 6, -8, 10, -12] println(tripled) // [3, -6, 9, -12, 15, -18] //sampleEnd } La fonction .map() accepte une expression lambda en tant que fonction de transformation : { x -> x * 2 } prend chaque \u00e9l\u00e9ment de la liste et renvoie cet \u00e9l\u00e9ment multipli\u00e9 par 2. { x -> x * 3 } prend chaque \u00e9l\u00e9ment de la liste et renvoie cet \u00e9l\u00e9ment multipli\u00e9 par 3. Types de fonction Avant de pouvoir renvoyer une expression lambda d'une fonction, vous devez d'abord comprendre les types de fonction . Vous avez d\u00e9j\u00e0 appris les types de base, mais les fonctions elles-m\u00eames ont aussi un type. L'inf\u00e9rence de type de Kotlin peut d\u00e9duire le type d'une fonction \u00e0 partir du type de param\u00e8tre. Mais il peut y avoir des moments o\u00f9 vous devez explicitement sp\u00e9cifier le type de la fonction. Le compilateur a besoin du type de fonction pour savoir ce qui est autoris\u00e9 et ce qui ne l'est pas pour cette fonction. La syntaxe pour un type de fonction a : le type de chaque param\u00e8tre \u00e9crit entre parenth\u00e8ses () et s\u00e9par\u00e9 par des virgules , . le type de retour \u00e9crit apr\u00e8s -> . Par exemple : (String) -> String ou (Int, Int) -> Int . Voici \u00e0 quoi ressemble une expression lambda si un type de fonction pour upperCaseString() est d\u00e9fini : val upperCaseString: (String) -> String = { text -> text.uppercase() } fun main() { println(upperCaseString(\"bonjour\")) // BONJOUR } Si votre expression lambda n'a pas de param\u00e8tres, alors les parenth\u00e8ses () sont laiss\u00e9es vides. Par exemple : () -> Unit Vous devez d\u00e9clarer les types de param\u00e8tres et de retour soit dans l'expression lambda, soit en tant que type de fonction. Sinon, le compilateur ne pourra pas savoir quelle est le type de votre expression lambda. Par exemple, la ligne suivante ne fonctionnera pas : val upperCaseString = { str -> str.uppercase() } Retour d'une fonction Des expressions lambda peuvent \u00eatre renvoy\u00e9es par une fonction. Ainsi, pour que le compilateur comprenne quel est le type de l'expression lambda renvoy\u00e9e, vous devez d\u00e9clarer un type de fonction. Dans l'exemple suivant, la fonction toSeconds() a un type de fonction (Int) -> Int car elle renvoie toujours une expression lambda qui prend un param\u00e8tre de type Int et renvoie une valeur Int . Cet exemple utilise une expression when pour d\u00e9terminer quelle expression lambda est renvoy\u00e9e lorsque toSeconds() est appel\u00e9e : fun toSeconds(time: String): (Int) -> Int = when (time) { \"heure\" -> { value -> value * 60 * 60 } \"minute\" -> { value -> value * 60 } \"seconde\" -> { value -> value } else -> { value -> value } } fun main() { val tempsEnMinutes = listOf(2, 10, 15, 1) val min2sec = toSeconds(\"minute\") val tempsTotalEnSecondes = tempsEnMinutes.map(min2sec).sum() println(\"Le temps total est de $tempsTotalEnSecondes secondes\") // Le temps total est de 1680 secondes } Invoquer s\u00e9par\u00e9ment Les expressions lambda peuvent \u00eatre invoqu\u00e9es seules en ajoutant des parenth\u00e8ses () apr\u00e8s les accolades {} et en incluant tous les param\u00e8tres dans les parenth\u00e8ses : fun main() { //sampleStart println({ text: String -> text.uppercase() }(\"bonjour\")) // BONJOUR //sampleEnd } Lambdas de fin Comme vous l'avez d\u00e9j\u00e0 vu, si une expression lambda est le seul param\u00e8tre d'une fonction, vous pouvez supprimer les parenth\u00e8ses de fonction () . Si une expression lambda est pass\u00e9e en tant que dernier param\u00e8tre d'une fonction, alors l'expression peut \u00eatre \u00e9crite en dehors des parenth\u00e8ses de fonction () . Dans les deux cas, cette syntaxe est appel\u00e9e un lambda de fin . Par exemple, la fonction .fold() accepte une valeur initiale et une op\u00e9ration : fun main() { //sampleStart // La valeur initiale est z\u00e9ro. // L'op\u00e9ration somme la valeur initiale avec chaque \u00e9l\u00e9ment de la liste cumulativement. println(listOf(1, 2, 3).fold(0, { x, item -> x + item })) // 6 // Sinon, sous la forme d'un lambda de fin println(listOf(1, 2, 3).fold(0) { x, item -> x + item }) // 6 //sampleEnd } Pour plus d'informations sur les expressions lambda, consultez Expressions lambda et fonctions anonymes . La prochaine \u00e9tape de notre tour est d'apprendre \u00e0 propos des classes en Kotlin. Pratique avec les expressions lambda Exercice 1 Vous disposez d'une liste d'actions prises en charge par un service web, d'un pr\u00e9fixe commun pour toutes les requ\u00eates et d'un identifiant d'une ressource particuli\u00e8re. Pour demander une action titre sur la ressource avec l'ID : 5, vous devez cr\u00e9er l'URL suivante : https://example.com/informations-livre/5/titre . Utilisez une expression lambda pour cr\u00e9er une liste d'URL \u00e0 partir de la liste des actions. fun main() { val actions = listOf(\"titre\", \"ann\u00e9e\", \"auteur\") val prefix = \"https://example.com/informations-livre\" val id = 5 val urls = // \u00c9crivez votre code ici println(urls) } R\u00e9ponse fun main() { val actions = listOf(\"titre\", \"ann\u00e9e\", \"auteur\") val prefix = \"https://example.com/informations-livre\" val id = 5 val urls = actions.map { action -> \"$prefix/$id/$action\" } println(urls) } Exercice 2 \u00c9crivez une fonction qui prend une valeur Int et une action (une fonction de type () -> Unit ) qui r\u00e9p\u00e8te ensuite l'action le nombre de fois donn\u00e9. Ensuite, utilisez cette fonction pour imprimer \"Bonjour\" 5 fois. fun repeatN(n: Int, action: () -> Unit) { // \u00c9crivez votre code ici } fun main() { // \u00c9crivez votre code ici } R\u00e9ponse fun repeatN(n: Int, action: () -> Unit) { for (i in 1..n) { action() } } fun main() { repeatN(5) { println(\"Bonjour\") } }","title":"Fonctions"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#fonctions","text":"Source Vous pouvez d\u00e9clarer vos propres fonctions en Kotlin en utilisant le mot-cl\u00e9 fun . fun hello() { return println(\"Bonjour, monde!\") } fun main() { hello() // Bonjour, monde! } En Kotlin: les param\u00e8tres de fonction sont \u00e9crits entre parenth\u00e8ses () . chaque param\u00e8tre doit avoir un type, et plusieurs param\u00e8tres doivent \u00eatre s\u00e9par\u00e9s par des virgules , . le type de retour est \u00e9crit apr\u00e8s les parenth\u00e8ses de la fonction () , s\u00e9par\u00e9 par un deux-points : . le corps d'une fonction est \u00e9crit entre accolades {} . le mot-cl\u00e9 return est utilis\u00e9 pour sortir ou retourner quelque chose d'une fonction. Si une fonction ne renvoie rien d'utile, le type de retour et le mot-cl\u00e9 return peuvent \u00eatre omis. Dans l'exemple suivant : x et y sont des param\u00e8tres de fonction. x et y ont le type Int . le type de retour de la fonction est Int . la fonction renvoie une somme de x et y lorsqu'elle est appel\u00e9e. fun sum(x: Int, y: Int): Int { return x + y } fun main() { println(sum(1, 2)) // 3 } Nous recommandons dans nos conventions de codage que vous nommiez les fonctions en commen\u00e7ant par une lettre minuscule et utilisez camel case sans tirets du bas.","title":"Fonctions"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#arguments-nommes","text":"Pour un code concis, lors de l'appel de votre fonction, vous n'avez pas besoin d'inclure les noms des param\u00e8tres. Cependant, l'inclusion des noms des param\u00e8tres rend votre code plus facile \u00e0 lire. C'est ce qu'on appelle l'utilisation des arguments nomm\u00e9s . Si vous incluez les noms des param\u00e8tres, vous pouvez alors \u00e9crire les param\u00e8tres dans n'importe quel ordre. Dans l'exemple suivant, les templates de cha\u00eenes de caract\u00e8res ( $ ) sont utilis\u00e9s pour acc\u00e9der aux valeurs des param\u00e8tres, les convertir en type String , puis les concat\u00e9ner en une cha\u00eene pour l'impression. fun printMessageWithPrefix(message: String, prefix: String) { println(\"[$prefix] $message\") } fun main() { // Utilise des arguments nomm\u00e9s avec l'ordre des param\u00e8tres invers\u00e9 printMessageWithPrefix(prefix = \"Log\", message = \"Bonjour\") // [Log] Bonjour }","title":"Arguments nomm\u00e9s"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#valeurs-par-defaut-des-parametres","text":"Vous pouvez d\u00e9finir des valeurs par d\u00e9faut pour vos param\u00e8tres de fonction. Tout param\u00e8tre ayant une valeur par d\u00e9faut peut \u00eatre omis lors de l'appel de votre fonction. Pour d\u00e9clarer une valeur par d\u00e9faut, utilisez l'op\u00e9rateur d'affectation = apr\u00e8s le type : fun printMessageWithPrefix(message: String, prefix: String = \"Info\") { println(\"[$prefix] $message\") } fun main() { // Fonction appel\u00e9e avec les deux param\u00e8tres printMessageWithPrefix(\"Bonjour\", \"Log\") // [Log] Bonjour // Fonction appel\u00e9e uniquement avec le param\u00e8tre message printMessageWithPrefix(\"Bonjour\") // [Info] Bonjour printMessageWithPrefix(prefix = \"Log\", message = \"Bonjour\") // [Log] Bonjour } Vous pouvez omettre des param\u00e8tres sp\u00e9cifiques ayant des valeurs par d\u00e9faut, plut\u00f4t que de tous les omettre. Cependant, apr\u00e8s le premier param\u00e8tre omis, vous devez nommer tous les param\u00e8tres suivants.","title":"Valeurs par d\u00e9faut des param\u00e8tres"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#fonctions-sans-retour","text":"Si votre fonction ne renvoie pas de valeur utile, alors son type de retour est Unit . Unit est un type avec une seule valeur - Unit . Vous n'avez pas \u00e0 d\u00e9clarer explicitement dans le corps de votre fonction que Unit est renvoy\u00e9. Cela signifie que vous n'avez pas \u00e0 utiliser le mot-cl\u00e9 return ou d\u00e9clarer un type de retour : fun printMessage(message: String) { println(message) // `return Unit` ou `return` est optionnel } fun main() { printMessage(\"Bonjour\") // Bonjour }","title":"Fonctions sans retour"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#fonctions-a-expression-unique","text":"Pour rendre votre code plus concis, vous pouvez utiliser des fonctions \u00e0 expression unique. Par exemple, la fonction sum() peut \u00eatre raccourcie : fun sum(x: Int, y: Int): Int { return x + y } fun main() { println(sum(1, 2)) // 3 } Vous pouvez retirer les accolades {} et d\u00e9clarer le corps de la fonction en utilisant l'op\u00e9rateur d'affectation = . Et gr\u00e2ce \u00e0 l'inf\u00e9rence de types de Kotlin, vous pouvez \u00e9galement omettre le type de retour. La fonction sum() devient alors une ligne : fun sum(x: Int, y: Int) = x + y fun main() { println(sum(1, 2)) // 3 } Omettre le type de retour n'est possible que lorsque votre fonction n'a pas de corps ( {} ). \u00c0 moins que le type de retour de votre fonction ne soit Unit .","title":"Fonctions \u00e0 expression unique"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#pratique-des-fonctions","text":"","title":"Pratique des fonctions"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#exercice-1","text":"\u00c9crivez une fonction appel\u00e9e circleArea qui prend le rayon d'un cercle au format entier comme param\u00e8tre et affiche l'aire de ce cercle. Dans cet exercice, vous importez un package afin de pouvoir acc\u00e9der \u00e0 la valeur de pi via PI . Pour plus d'informations sur l'importation de packages, voir Packages and imports . import kotlin.math.PI fun circleArea() { // \u00c9crivez votre code ici } fun main() { println(circleArea(2)) } R\u00e9ponse import kotlin.math.PI fun circleArea(radius: Int): Double { return PI * radius * radius } fun main() { println(circleArea(2)) // 12.566370614359172 }","title":"Exercice 1"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#exercice-2","text":"R\u00e9\u00e9crivez la fonction circleArea de l'exercice pr\u00e9c\u00e9dent comme une fonction \u00e0 expression unique. import kotlin.math.PI // \u00c9crivez votre code ici fun main() { println(circleArea(2)) } R\u00e9ponse import kotlin.math.PI fun circleArea(radius: Int): Double = PI * radius * radius fun main() { println(circleArea(2)) // 12.566370614359172 }","title":"Exercice 2"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#exercice-3","text":"Vous avez une fonction qui traduit un intervalle de temps donn\u00e9 en heures, minutes et secondes en secondes. Dans la plupart des cas, vous devez passer seulement un ou deux param\u00e8tres de fonction alors que le reste est \u00e9gal \u00e0 0. Am\u00e9liorez la fonction et le code qui l'appelle en utilisant des valeurs par d\u00e9faut pour les param\u00e8tres et des arguments nomm\u00e9s afin que le code soit plus facile \u00e0 lire. fun intervalInSeconds(hours: Int, minutes: Int, seconds: Int) = ((hours * 60) + minutes) * 60 + seconds fun main() { println(intervalInSeconds(1, 20, 15)) println(intervalInSeconds(0, 1, 25)) println(intervalInSeconds(2, 0, 0)) println(intervalInSeconds(0, 10, 0)) println(intervalInSeconds(1, 0, 1)) } R\u00e9ponse fun intervalInSeconds(hours: Int = 0, minutes: Int = 0, seconds: Int = 0) = ((hours * 60) + minutes) * 60 + seconds fun main() { println(intervalInSeconds(1, 20, 15)) println(intervalInSeconds(minutes = 1, seconds = 25)) println(intervalInSeconds(hours = 2)) println(intervalInSeconds(minutes = 10)) println(intervalInSeconds(hours = 1, seconds = 1)) }","title":"Exercice 3"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#expressions-lambda","text":"Kotlin vous permet d'\u00e9crire un code encore plus concis pour les fonctions en utilisant des expressions lambda. Par exemple, la fonction uppercaseString() suivante : fun uppercaseString(text: String): String { return text.uppercase() } fun main() { println(uppercaseString(\"bonjour\")) // BONJOUR } Peut \u00e9galement \u00eatre \u00e9crite comme une expression lambda : fun main() { println({ text: String -> text.uppercase() }(\"bonjour\")) // BONJOUR } Les expressions lambda peuvent \u00eatre difficiles \u00e0 comprendre \u00e0 premi\u00e8re vue, alors d\u00e9composons-les. Les expressions lambda sont \u00e9crites entre accolades {} . Dans l'expression lambda, vous \u00e9crivez : les param\u00e8tres suivis par un -> . le corps de la fonction apr\u00e8s le -> . Dans l'exemple pr\u00e9c\u00e9dent : text est un param\u00e8tre de fonction. text a le type String . la fonction renvoie le r\u00e9sultat de la fonction .uppercase() appel\u00e9e sur text . Si vous d\u00e9clarez une lambda sans param\u00e8tres, alors il n'est pas n\u00e9cessaire d'utiliser -> . Par exemple : { println(\"Message de log\") } Les expressions lambda peuvent \u00eatre utilis\u00e9es de plusieurs fa\u00e7ons. Vous pouvez : attribuer une lambda \u00e0 une variable que vous pouvez ensuite invoquer plus tard passer une expression lambda comme param\u00e8tre \u00e0 une autre fonction retourner une expression lambda d'une fonction invoquer une expression lambda ind\u00e9pendamment","title":"Expressions lambda"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#assigner-a-une-variable","text":"Pour attribuer une expression lambda \u00e0 une variable, utilisez l'op\u00e9rateur d'affectation = : fun main() { val UpperCaseString = { text: String -> text.uppercase() } println(UpperCaseString(\"bonjour\")) // BONJOUR }","title":"Assigner \u00e0 une variable"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#passer-a-une-autre-fonction","text":"Un excellent exemple de quand il est utile de passer une expression lambda \u00e0 une fonction est d'utiliser la fonction .filter() sur des collections : fun main() { //sampleStart val numbers = listOf(1, -2, 3, -4, 5, -6) val positives = numbers.filter { x -> x > 0 } val negatives = numbers.filter { x -> x < 0 } println(positives) // [1, 3, 5] println(negatives) // [-2, -4, -6] //sampleEnd } La fonction .filter() accepte une expression lambda en tant que pr\u00e9dicat : { x -> x > 0 } prend chaque \u00e9l\u00e9ment de la liste et ne renvoie que ceux qui sont positifs. { x -> x < 0 } prend chaque \u00e9l\u00e9ment de la liste et ne renvoie que ceux qui sont n\u00e9gatifs. Si une expression lambda est le seul param\u00e8tre de fonction, vous pouvez supprimer les parenth\u00e8ses de fonction () . Il s'agit d'un exemple de lambda de fin , qui est discut\u00e9 plus en d\u00e9tail \u00e0 la fin de ce chapitre. Un autre bon exemple est l'utilisation de la fonction .map() pour transformer les \u00e9l\u00e9ments d'une collection : fun main() { //sampleStart val numbers = listOf(1, -2, 3, -4, 5, -6) val doubled = numbers.map { x -> x * 2 } val tripled = numbers.map { x -> x * 3 } println(doubled) // [2, -4, 6, -8, 10, -12] println(tripled) // [3, -6, 9, -12, 15, -18] //sampleEnd } La fonction .map() accepte une expression lambda en tant que fonction de transformation : { x -> x * 2 } prend chaque \u00e9l\u00e9ment de la liste et renvoie cet \u00e9l\u00e9ment multipli\u00e9 par 2. { x -> x * 3 } prend chaque \u00e9l\u00e9ment de la liste et renvoie cet \u00e9l\u00e9ment multipli\u00e9 par 3.","title":"Passer \u00e0 une autre fonction"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#types-de-fonction","text":"Avant de pouvoir renvoyer une expression lambda d'une fonction, vous devez d'abord comprendre les types de fonction . Vous avez d\u00e9j\u00e0 appris les types de base, mais les fonctions elles-m\u00eames ont aussi un type. L'inf\u00e9rence de type de Kotlin peut d\u00e9duire le type d'une fonction \u00e0 partir du type de param\u00e8tre. Mais il peut y avoir des moments o\u00f9 vous devez explicitement sp\u00e9cifier le type de la fonction. Le compilateur a besoin du type de fonction pour savoir ce qui est autoris\u00e9 et ce qui ne l'est pas pour cette fonction. La syntaxe pour un type de fonction a : le type de chaque param\u00e8tre \u00e9crit entre parenth\u00e8ses () et s\u00e9par\u00e9 par des virgules , . le type de retour \u00e9crit apr\u00e8s -> . Par exemple : (String) -> String ou (Int, Int) -> Int . Voici \u00e0 quoi ressemble une expression lambda si un type de fonction pour upperCaseString() est d\u00e9fini : val upperCaseString: (String) -> String = { text -> text.uppercase() } fun main() { println(upperCaseString(\"bonjour\")) // BONJOUR } Si votre expression lambda n'a pas de param\u00e8tres, alors les parenth\u00e8ses () sont laiss\u00e9es vides. Par exemple : () -> Unit Vous devez d\u00e9clarer les types de param\u00e8tres et de retour soit dans l'expression lambda, soit en tant que type de fonction. Sinon, le compilateur ne pourra pas savoir quelle est le type de votre expression lambda. Par exemple, la ligne suivante ne fonctionnera pas : val upperCaseString = { str -> str.uppercase() }","title":"Types de fonction"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#retour-dune-fonction","text":"Des expressions lambda peuvent \u00eatre renvoy\u00e9es par une fonction. Ainsi, pour que le compilateur comprenne quel est le type de l'expression lambda renvoy\u00e9e, vous devez d\u00e9clarer un type de fonction. Dans l'exemple suivant, la fonction toSeconds() a un type de fonction (Int) -> Int car elle renvoie toujours une expression lambda qui prend un param\u00e8tre de type Int et renvoie une valeur Int . Cet exemple utilise une expression when pour d\u00e9terminer quelle expression lambda est renvoy\u00e9e lorsque toSeconds() est appel\u00e9e : fun toSeconds(time: String): (Int) -> Int = when (time) { \"heure\" -> { value -> value * 60 * 60 } \"minute\" -> { value -> value * 60 } \"seconde\" -> { value -> value } else -> { value -> value } } fun main() { val tempsEnMinutes = listOf(2, 10, 15, 1) val min2sec = toSeconds(\"minute\") val tempsTotalEnSecondes = tempsEnMinutes.map(min2sec).sum() println(\"Le temps total est de $tempsTotalEnSecondes secondes\") // Le temps total est de 1680 secondes }","title":"Retour d'une fonction"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#invoquer-separement","text":"Les expressions lambda peuvent \u00eatre invoqu\u00e9es seules en ajoutant des parenth\u00e8ses () apr\u00e8s les accolades {} et en incluant tous les param\u00e8tres dans les parenth\u00e8ses : fun main() { //sampleStart println({ text: String -> text.uppercase() }(\"bonjour\")) // BONJOUR //sampleEnd }","title":"Invoquer s\u00e9par\u00e9ment"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#lambdas-de-fin","text":"Comme vous l'avez d\u00e9j\u00e0 vu, si une expression lambda est le seul param\u00e8tre d'une fonction, vous pouvez supprimer les parenth\u00e8ses de fonction () . Si une expression lambda est pass\u00e9e en tant que dernier param\u00e8tre d'une fonction, alors l'expression peut \u00eatre \u00e9crite en dehors des parenth\u00e8ses de fonction () . Dans les deux cas, cette syntaxe est appel\u00e9e un lambda de fin . Par exemple, la fonction .fold() accepte une valeur initiale et une op\u00e9ration : fun main() { //sampleStart // La valeur initiale est z\u00e9ro. // L'op\u00e9ration somme la valeur initiale avec chaque \u00e9l\u00e9ment de la liste cumulativement. println(listOf(1, 2, 3).fold(0, { x, item -> x + item })) // 6 // Sinon, sous la forme d'un lambda de fin println(listOf(1, 2, 3).fold(0) { x, item -> x + item }) // 6 //sampleEnd } Pour plus d'informations sur les expressions lambda, consultez Expressions lambda et fonctions anonymes . La prochaine \u00e9tape de notre tour est d'apprendre \u00e0 propos des classes en Kotlin.","title":"Lambdas de fin"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#pratique-avec-les-expressions-lambda","text":"","title":"Pratique avec les expressions lambda"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#exercice-1_1","text":"Vous disposez d'une liste d'actions prises en charge par un service web, d'un pr\u00e9fixe commun pour toutes les requ\u00eates et d'un identifiant d'une ressource particuli\u00e8re. Pour demander une action titre sur la ressource avec l'ID : 5, vous devez cr\u00e9er l'URL suivante : https://example.com/informations-livre/5/titre . Utilisez une expression lambda pour cr\u00e9er une liste d'URL \u00e0 partir de la liste des actions. fun main() { val actions = listOf(\"titre\", \"ann\u00e9e\", \"auteur\") val prefix = \"https://example.com/informations-livre\" val id = 5 val urls = // \u00c9crivez votre code ici println(urls) } R\u00e9ponse fun main() { val actions = listOf(\"titre\", \"ann\u00e9e\", \"auteur\") val prefix = \"https://example.com/informations-livre\" val id = 5 val urls = actions.map { action -> \"$prefix/$id/$action\" } println(urls) }","title":"Exercice 1"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/06-fonctions/#exercice-2_1","text":"\u00c9crivez une fonction qui prend une valeur Int et une action (une fonction de type () -> Unit ) qui r\u00e9p\u00e8te ensuite l'action le nombre de fois donn\u00e9. Ensuite, utilisez cette fonction pour imprimer \"Bonjour\" 5 fois. fun repeatN(n: Int, action: () -> Unit) { // \u00c9crivez votre code ici } fun main() { // \u00c9crivez votre code ici } R\u00e9ponse fun repeatN(n: Int, action: () -> Unit) { for (i in 1..n) { action() } } fun main() { repeatN(5) { println(\"Bonjour\") } }","title":"Exercice 2"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/","text":"Classes Source Kotlin prend en charge la programmation orient\u00e9e objet avec des classes et des objets. Les objets sont utiles pour stocker des donn\u00e9es dans votre programme. Les classes vous permettent de d\u00e9clarer un ensemble de caract\u00e9ristiques pour un objet. Lorsque vous cr\u00e9ez des objets \u00e0 partir d'une classe, vous pouvez gagner du temps et des efforts, car vous n'avez pas \u00e0 d\u00e9clarer ces caract\u00e9ristiques \u00e0 chaque fois. Pour d\u00e9clarer une classe, utilisez le mot-cl\u00e9 class : class Client Propri\u00e9t\u00e9s Les caract\u00e9ristiques d'un objet de classe peuvent \u00eatre d\u00e9clar\u00e9es dans des propri\u00e9t\u00e9s. Vous pouvez d\u00e9clarer des propri\u00e9t\u00e9s pour une classe : Dans les parenth\u00e8ses () apr\u00e8s le nom de la classe. class Contact(val id: Int, var email: String) Au sein du corps de la classe d\u00e9fini par des accolades {} . class Contact(val id: Int, var email: String) { val category: String = \"\" } Nous vous recommandons de d\u00e9clarer les propri\u00e9t\u00e9s en lecture seule ( val ) \u00e0 moins qu'elles ne doivent \u00eatre modifi\u00e9es apr\u00e8s la cr\u00e9ation d'une instance de la classe. Vous pouvez d\u00e9clarer des propri\u00e9t\u00e9s sans val ou var dans les parenth\u00e8ses, mais ces propri\u00e9t\u00e9s ne sont pas accessibles apr\u00e8s la cr\u00e9ation d'une instance. Le contenu entre parenth\u00e8ses () s'appelle l' en-t\u00eate de la classe . Vous pouvez utiliser une virgule finale lors > de la d\u00e9claration des propri\u00e9t\u00e9s de classe. Tout comme avec les param\u00e8tres de fonction, les propri\u00e9t\u00e9s de classe peuvent avoir des valeurs par d\u00e9faut : class Contact(val id: Int, var email: String = \"example@gmail.com\") { val category: String = \"travail\" } Cr\u00e9er une instance Pour cr\u00e9er un objet \u00e0 partir d'une classe, vous d\u00e9clarez une instance de classe \u00e0 l'aide d'un constructeur . Par d\u00e9faut, Kotlin cr\u00e9e automatiquement un constructeur avec les param\u00e8tres d\u00e9clar\u00e9s dans l'en-t\u00eate de la classe. Par exemple : class Contact(val id: Int, var email: String) fun main() { val contact = Contact(1, \"mary@gmail.com\") } Dans cet exemple : Contact est une classe. contact est une instance de la classe Contact . id et email sont des propri\u00e9t\u00e9s. id et email sont utilis\u00e9s avec le constructeur par d\u00e9faut pour cr\u00e9er contact . Les classes Kotlin peuvent avoir de nombreux constructeurs, y compris ceux que vous d\u00e9finissez vous-m\u00eame. Pour en savoir plus sur la fa\u00e7on de d\u00e9clarer plusieurs constructeurs, voir Constructeurs . Acc\u00e9der aux propri\u00e9t\u00e9s Pour acc\u00e9der \u00e0 une propri\u00e9t\u00e9 d'une instance, \u00e9crivez le nom de la propri\u00e9t\u00e9 apr\u00e8s le nom de l'instance, pr\u00e9c\u00e9d\u00e9 d'un point . : class Contact(val id: Int, var email: String) fun main() { val contact = Contact(1, \"mary@gmail.com\") // Affiche la valeur de la propri\u00e9t\u00e9 : email println(contact.email) // mary@gmail.com // Met \u00e0 jour la valeur de la propri\u00e9t\u00e9 : email contact.email = \"jane@gmail.com\" // Affiche la nouvelle valeur de la propri\u00e9t\u00e9 : email println(contact.email) // jane@gmail.com } Pour concat\u00e9ner la valeur d'une propri\u00e9t\u00e9 dans le cadre d'une cha\u00eene de caract\u00e8res, vous pouvez utiliser des mod\u00e8les de cha\u00eene de caract\u00e8res ( $ ). Par exemple : kotlin println(\"Leur adresse email est : ${contact.email}\") Fonctions membres En plus de d\u00e9clarer des propri\u00e9t\u00e9s dans le cadre des caract\u00e9ristiques d'un objet, vous pouvez \u00e9galement d\u00e9finir le comportement d'un objet avec des fonctions membres. En Kotlin, les fonctions membres doivent \u00eatre d\u00e9clar\u00e9es \u00e0 l'int\u00e9rieur du corps de la classe. Pour appeler une fonction membre sur une instance, \u00e9crivez le nom de la fonction apr\u00e8s le nom de l'instance, pr\u00e9c\u00e9d\u00e9 d'un point . . Par exemple : class Contact(val id: Int, var email: String) { fun printId() { println(id) } } fun main() { val contact = Contact(1, \"mary@gmail.com\") // Appelle la fonction membre printId() contact.printId() // 1 } Classes de donn\u00e9es Kotlin dispose de classes de donn\u00e9es particuli\u00e8rement utiles pour stocker des donn\u00e9es. Les classes de donn\u00e9es ont la m\u00eame fonctionnalit\u00e9 que les classes, mais elles viennent automatiquement avec des fonctions membres suppl\u00e9mentaires. Ces fonctions membres vous permettent de facilement imprimer l'instance en sortie lisible, de comparer les instances d'une classe, de copier les instances, et plus encore. Comme ces fonctions sont automatiquement disponibles, vous n'avez pas \u00e0 passer de temps \u00e0 \u00e9crire le m\u00eame code standard pour chacune de vos classes. Pour d\u00e9clarer une classe de donn\u00e9es, utilisez le mot-cl\u00e9 data : data class Utilisateur(val nom: String, val id: Int) Les fonctions membres pr\u00e9d\u00e9finies les plus utiles des classes de donn\u00e9es sont : Fonction Description .toString() Imprime une cha\u00eene de caract\u00e8res lisible de l'instance de la classe et ses propri\u00e9t\u00e9s. .equals() or == Compare les instances d'une classe. .copy() Cr\u00e9e une instance de classe en copiant une autre, potentiellement avec des propri\u00e9t\u00e9s diff\u00e9rentes. Voir les sections suivantes pour des exemples d'utilisation de chaque fonction : Imprimer comme une cha\u00eene Comparer les instances Copier une instance Imprimer comme une cha\u00eene Pour imprimer une cha\u00eene de caract\u00e8res lisible d'une instance de classe, vous pouvez appeler explicitement la fonction .toString() , ou utiliser des fonctions d'impression ( println() et print() ) qui appellent automatiquement .toString() pour vous : class User(val nom: String, val id: Int) fun main() { //sampleStart val utilisateur = User(\"Alex\", 1) // Utilise automatiquement la fonction toString() afin que la sortie soit facile \u00e0 lire println(utilisateur) // User(nom=Alex, id=1) //sampleEnd } Cela est particuli\u00e8rement utile lors du d\u00e9bogage ou de la cr\u00e9ation de journaux. Comparer les instances Pour comparer les instances de classes de donn\u00e9es, utilisez l'op\u00e9rateur d'\u00e9galit\u00e9 == : data class User(val name: String, val id: Int) fun main() { //sampleStart val utilisateur = User(\"Alex\", 1) val secondUtilisateur = User(\"Alex\", 1) val troisiemeUtilisateur = User(\"Max\", 2) // Compare l'utilisateur au deuxi\u00e8me utilisateur println(\"utilisateur == secondUtilisateur : ${utilisateur == secondUtilisateur}\") // utilisateur == secondUtilisateur : true // Compare l'utilisateur au troisi\u00e8me utilisateur println(\"utilisateur == troisiemeUtilisateur : ${utilisateur == troisiemeUtilisateur}\") // utilisateur == troisiemeUtilisateur : false //sampleEnd } Copier une instance Pour cr\u00e9er une copie exacte d'une instance de classe de donn\u00e9es, appelez la fonction .copy() sur l'instance. Pour cr\u00e9er une copie d'une instance de classe de donn\u00e9es et changer certaines propri\u00e9t\u00e9s, appelez la fonction .copy() sur l'instance et ajoutez des valeurs de remplacement pour les propri\u00e9t\u00e9s en tant que param\u00e8tres de fonction. Par exemple : data class User(val name: String, val id: Int) fun main() { //sampleStart val utilisateur = User(\"Alex\", 1) val secondUtilisateur = User(\"Alex\", 1) val troisiemeUtilisateur = User(\"Max\", 2) // Cr\u00e9e une copie exacte de l'utilisateur println(utilisateur.copy()) // User(name=Alex, id=1) // Cr\u00e9e une copie de l'utilisateur avec le nom : \"Max\" println(utilisateur.copy(\"Max\")) // User(name=Max, id=1) // Cr\u00e9e une copie de l'utilisateur avec id : 3 println(utilisateur.copy(id = 3)) // User(name=Alex, id=3) //sampleEnd } Cr\u00e9er une copie d'une instance est plus s\u00fbr que de modifier l'instance d'origine, car tout code qui d\u00e9pend de l'instance d'origine n'est pas affect\u00e9 par la copie et ce que vous en faites. Pour plus d'informations sur les classes de donn\u00e9es, voir Classes de donn\u00e9es . Le dernier chapitre de ce tour est \u00e0 propos de la s\u00e9curit\u00e9 contre null de Kotlin. Pratique Exercice 1 D\u00e9finissez une classe de donn\u00e9es Employ\u00e9 avec deux propri\u00e9t\u00e9s : une pour un nom, et une autre pour un salaire. Assurez-vous que la propri\u00e9t\u00e9 pour le salaire est modifiable, sinon vous n'obtiendrez pas d'augmentation de salaire \u00e0 la fin de l'ann\u00e9e ! La fonction principale d\u00e9montre comment vous pouvez utiliser cette classe de donn\u00e9es. // \u00c9crivez votre code ici fun main() { val emp = Employe(\"Mary\", 20) println(emp) emp.salaire += 10 println(emp) } R\u00e9ponse data class Employ\u00e9(val nom: String, var salaire: Int) fun main() { val emp = Employ\u00e9(\"Mary\", 20) println(emp) emp.salaire += 10 println(emp) } Exercice 2 Pour tester votre code, vous avez besoin d'un g\u00e9n\u00e9rateur capable de cr\u00e9er des employ\u00e9s al\u00e9atoires. D\u00e9finissez une classe avec une liste fixe de noms potentiels (\u00e0 l'int\u00e9rieur du corps de la classe), et qui est configur\u00e9e par un salaire minimum et maximum (\u00e0 l'int\u00e9rieur de l'en-t\u00eate de la classe). Encore une fois, la fonction principale d\u00e9montre comment vous pouvez utiliser cette classe. Indice Les listes ont une fonction d'extension appel\u00e9e .random() qui renvoie un \u00e9l\u00e9ment al\u00e9atoire dans une liste. Indice Random.nextInt(from = ..., until = ...) vous donne un nombre al\u00e9atoire de type Int dans des limites sp\u00e9cifi\u00e9es. import kotlin.random.Random data class Employe(val nom: String, var salaire: Int) // \u00c9crivez votre code ici fun main() { val empGen = GenerateurEmployeAleatoire(10, 30) println(empGen.genererEmploye()) println(empGen.genererEmploye()) println(empGen.genererEmploye()) empGen.salaireMin = 50 empGen.salaireMax = 100 println(empGen.genererEmploye()) } R\u00e9ponse import kotlin.random.Random data class Employe(val nom: String, var salaire: Int) class GenerateurEmployeAleatoire(var salaireMin: Int, var salaireMax: Int) { val noms = listOf(\"John\", \"Mary\", \"Ann\", \"Paul\", \"Jack\", \"Elizabeth\") fun genererEmploye() = Employe(noms.random(), Random.nextInt(from = salaireMin, until = salaireMax)) } fun main() { val empGen = GenerateurEmployeAleatoire(10, 30) println(empGen.genererEmploye()) println(empGen.genererEmploye()) println(empGen.genererEmploye()) empGen.salaireMin = 50 empGen.salaireMax = 100 println(empGen.genererEmploye()) }","title":"Classes"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#classes","text":"Source Kotlin prend en charge la programmation orient\u00e9e objet avec des classes et des objets. Les objets sont utiles pour stocker des donn\u00e9es dans votre programme. Les classes vous permettent de d\u00e9clarer un ensemble de caract\u00e9ristiques pour un objet. Lorsque vous cr\u00e9ez des objets \u00e0 partir d'une classe, vous pouvez gagner du temps et des efforts, car vous n'avez pas \u00e0 d\u00e9clarer ces caract\u00e9ristiques \u00e0 chaque fois. Pour d\u00e9clarer une classe, utilisez le mot-cl\u00e9 class : class Client","title":"Classes"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#proprietes","text":"Les caract\u00e9ristiques d'un objet de classe peuvent \u00eatre d\u00e9clar\u00e9es dans des propri\u00e9t\u00e9s. Vous pouvez d\u00e9clarer des propri\u00e9t\u00e9s pour une classe : Dans les parenth\u00e8ses () apr\u00e8s le nom de la classe. class Contact(val id: Int, var email: String) Au sein du corps de la classe d\u00e9fini par des accolades {} . class Contact(val id: Int, var email: String) { val category: String = \"\" } Nous vous recommandons de d\u00e9clarer les propri\u00e9t\u00e9s en lecture seule ( val ) \u00e0 moins qu'elles ne doivent \u00eatre modifi\u00e9es apr\u00e8s la cr\u00e9ation d'une instance de la classe. Vous pouvez d\u00e9clarer des propri\u00e9t\u00e9s sans val ou var dans les parenth\u00e8ses, mais ces propri\u00e9t\u00e9s ne sont pas accessibles apr\u00e8s la cr\u00e9ation d'une instance. Le contenu entre parenth\u00e8ses () s'appelle l' en-t\u00eate de la classe . Vous pouvez utiliser une virgule finale lors > de la d\u00e9claration des propri\u00e9t\u00e9s de classe. Tout comme avec les param\u00e8tres de fonction, les propri\u00e9t\u00e9s de classe peuvent avoir des valeurs par d\u00e9faut : class Contact(val id: Int, var email: String = \"example@gmail.com\") { val category: String = \"travail\" }","title":"Propri\u00e9t\u00e9s"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#creer-une-instance","text":"Pour cr\u00e9er un objet \u00e0 partir d'une classe, vous d\u00e9clarez une instance de classe \u00e0 l'aide d'un constructeur . Par d\u00e9faut, Kotlin cr\u00e9e automatiquement un constructeur avec les param\u00e8tres d\u00e9clar\u00e9s dans l'en-t\u00eate de la classe. Par exemple : class Contact(val id: Int, var email: String) fun main() { val contact = Contact(1, \"mary@gmail.com\") } Dans cet exemple : Contact est une classe. contact est une instance de la classe Contact . id et email sont des propri\u00e9t\u00e9s. id et email sont utilis\u00e9s avec le constructeur par d\u00e9faut pour cr\u00e9er contact . Les classes Kotlin peuvent avoir de nombreux constructeurs, y compris ceux que vous d\u00e9finissez vous-m\u00eame. Pour en savoir plus sur la fa\u00e7on de d\u00e9clarer plusieurs constructeurs, voir Constructeurs .","title":"Cr\u00e9er une instance"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#acceder-aux-proprietes","text":"Pour acc\u00e9der \u00e0 une propri\u00e9t\u00e9 d'une instance, \u00e9crivez le nom de la propri\u00e9t\u00e9 apr\u00e8s le nom de l'instance, pr\u00e9c\u00e9d\u00e9 d'un point . : class Contact(val id: Int, var email: String) fun main() { val contact = Contact(1, \"mary@gmail.com\") // Affiche la valeur de la propri\u00e9t\u00e9 : email println(contact.email) // mary@gmail.com // Met \u00e0 jour la valeur de la propri\u00e9t\u00e9 : email contact.email = \"jane@gmail.com\" // Affiche la nouvelle valeur de la propri\u00e9t\u00e9 : email println(contact.email) // jane@gmail.com } Pour concat\u00e9ner la valeur d'une propri\u00e9t\u00e9 dans le cadre d'une cha\u00eene de caract\u00e8res, vous pouvez utiliser des mod\u00e8les de cha\u00eene de caract\u00e8res ( $ ). Par exemple : kotlin println(\"Leur adresse email est : ${contact.email}\")","title":"Acc\u00e9der aux propri\u00e9t\u00e9s"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#fonctions-membres","text":"En plus de d\u00e9clarer des propri\u00e9t\u00e9s dans le cadre des caract\u00e9ristiques d'un objet, vous pouvez \u00e9galement d\u00e9finir le comportement d'un objet avec des fonctions membres. En Kotlin, les fonctions membres doivent \u00eatre d\u00e9clar\u00e9es \u00e0 l'int\u00e9rieur du corps de la classe. Pour appeler une fonction membre sur une instance, \u00e9crivez le nom de la fonction apr\u00e8s le nom de l'instance, pr\u00e9c\u00e9d\u00e9 d'un point . . Par exemple : class Contact(val id: Int, var email: String) { fun printId() { println(id) } } fun main() { val contact = Contact(1, \"mary@gmail.com\") // Appelle la fonction membre printId() contact.printId() // 1 }","title":"Fonctions membres"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#classes-de-donnees","text":"Kotlin dispose de classes de donn\u00e9es particuli\u00e8rement utiles pour stocker des donn\u00e9es. Les classes de donn\u00e9es ont la m\u00eame fonctionnalit\u00e9 que les classes, mais elles viennent automatiquement avec des fonctions membres suppl\u00e9mentaires. Ces fonctions membres vous permettent de facilement imprimer l'instance en sortie lisible, de comparer les instances d'une classe, de copier les instances, et plus encore. Comme ces fonctions sont automatiquement disponibles, vous n'avez pas \u00e0 passer de temps \u00e0 \u00e9crire le m\u00eame code standard pour chacune de vos classes. Pour d\u00e9clarer une classe de donn\u00e9es, utilisez le mot-cl\u00e9 data : data class Utilisateur(val nom: String, val id: Int) Les fonctions membres pr\u00e9d\u00e9finies les plus utiles des classes de donn\u00e9es sont : Fonction Description .toString() Imprime une cha\u00eene de caract\u00e8res lisible de l'instance de la classe et ses propri\u00e9t\u00e9s. .equals() or == Compare les instances d'une classe. .copy() Cr\u00e9e une instance de classe en copiant une autre, potentiellement avec des propri\u00e9t\u00e9s diff\u00e9rentes. Voir les sections suivantes pour des exemples d'utilisation de chaque fonction : Imprimer comme une cha\u00eene Comparer les instances Copier une instance","title":"Classes de donn\u00e9es"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#imprimer-comme-une-chaine","text":"Pour imprimer une cha\u00eene de caract\u00e8res lisible d'une instance de classe, vous pouvez appeler explicitement la fonction .toString() , ou utiliser des fonctions d'impression ( println() et print() ) qui appellent automatiquement .toString() pour vous : class User(val nom: String, val id: Int) fun main() { //sampleStart val utilisateur = User(\"Alex\", 1) // Utilise automatiquement la fonction toString() afin que la sortie soit facile \u00e0 lire println(utilisateur) // User(nom=Alex, id=1) //sampleEnd } Cela est particuli\u00e8rement utile lors du d\u00e9bogage ou de la cr\u00e9ation de journaux.","title":"Imprimer comme une cha\u00eene"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#comparer-les-instances","text":"Pour comparer les instances de classes de donn\u00e9es, utilisez l'op\u00e9rateur d'\u00e9galit\u00e9 == : data class User(val name: String, val id: Int) fun main() { //sampleStart val utilisateur = User(\"Alex\", 1) val secondUtilisateur = User(\"Alex\", 1) val troisiemeUtilisateur = User(\"Max\", 2) // Compare l'utilisateur au deuxi\u00e8me utilisateur println(\"utilisateur == secondUtilisateur : ${utilisateur == secondUtilisateur}\") // utilisateur == secondUtilisateur : true // Compare l'utilisateur au troisi\u00e8me utilisateur println(\"utilisateur == troisiemeUtilisateur : ${utilisateur == troisiemeUtilisateur}\") // utilisateur == troisiemeUtilisateur : false //sampleEnd }","title":"Comparer les instances"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#copier-une-instance","text":"Pour cr\u00e9er une copie exacte d'une instance de classe de donn\u00e9es, appelez la fonction .copy() sur l'instance. Pour cr\u00e9er une copie d'une instance de classe de donn\u00e9es et changer certaines propri\u00e9t\u00e9s, appelez la fonction .copy() sur l'instance et ajoutez des valeurs de remplacement pour les propri\u00e9t\u00e9s en tant que param\u00e8tres de fonction. Par exemple : data class User(val name: String, val id: Int) fun main() { //sampleStart val utilisateur = User(\"Alex\", 1) val secondUtilisateur = User(\"Alex\", 1) val troisiemeUtilisateur = User(\"Max\", 2) // Cr\u00e9e une copie exacte de l'utilisateur println(utilisateur.copy()) // User(name=Alex, id=1) // Cr\u00e9e une copie de l'utilisateur avec le nom : \"Max\" println(utilisateur.copy(\"Max\")) // User(name=Max, id=1) // Cr\u00e9e une copie de l'utilisateur avec id : 3 println(utilisateur.copy(id = 3)) // User(name=Alex, id=3) //sampleEnd } Cr\u00e9er une copie d'une instance est plus s\u00fbr que de modifier l'instance d'origine, car tout code qui d\u00e9pend de l'instance d'origine n'est pas affect\u00e9 par la copie et ce que vous en faites. Pour plus d'informations sur les classes de donn\u00e9es, voir Classes de donn\u00e9es . Le dernier chapitre de ce tour est \u00e0 propos de la s\u00e9curit\u00e9 contre null de Kotlin.","title":"Copier une instance"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#pratique","text":"","title":"Pratique"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#exercice-1","text":"D\u00e9finissez une classe de donn\u00e9es Employ\u00e9 avec deux propri\u00e9t\u00e9s : une pour un nom, et une autre pour un salaire. Assurez-vous que la propri\u00e9t\u00e9 pour le salaire est modifiable, sinon vous n'obtiendrez pas d'augmentation de salaire \u00e0 la fin de l'ann\u00e9e ! La fonction principale d\u00e9montre comment vous pouvez utiliser cette classe de donn\u00e9es. // \u00c9crivez votre code ici fun main() { val emp = Employe(\"Mary\", 20) println(emp) emp.salaire += 10 println(emp) } R\u00e9ponse data class Employ\u00e9(val nom: String, var salaire: Int) fun main() { val emp = Employ\u00e9(\"Mary\", 20) println(emp) emp.salaire += 10 println(emp) }","title":"Exercice 1"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/07-classes/#exercice-2","text":"Pour tester votre code, vous avez besoin d'un g\u00e9n\u00e9rateur capable de cr\u00e9er des employ\u00e9s al\u00e9atoires. D\u00e9finissez une classe avec une liste fixe de noms potentiels (\u00e0 l'int\u00e9rieur du corps de la classe), et qui est configur\u00e9e par un salaire minimum et maximum (\u00e0 l'int\u00e9rieur de l'en-t\u00eate de la classe). Encore une fois, la fonction principale d\u00e9montre comment vous pouvez utiliser cette classe. Indice Les listes ont une fonction d'extension appel\u00e9e .random() qui renvoie un \u00e9l\u00e9ment al\u00e9atoire dans une liste. Indice Random.nextInt(from = ..., until = ...) vous donne un nombre al\u00e9atoire de type Int dans des limites sp\u00e9cifi\u00e9es. import kotlin.random.Random data class Employe(val nom: String, var salaire: Int) // \u00c9crivez votre code ici fun main() { val empGen = GenerateurEmployeAleatoire(10, 30) println(empGen.genererEmploye()) println(empGen.genererEmploye()) println(empGen.genererEmploye()) empGen.salaireMin = 50 empGen.salaireMax = 100 println(empGen.genererEmploye()) } R\u00e9ponse import kotlin.random.Random data class Employe(val nom: String, var salaire: Int) class GenerateurEmployeAleatoire(var salaireMin: Int, var salaireMax: Int) { val noms = listOf(\"John\", \"Mary\", \"Ann\", \"Paul\", \"Jack\", \"Elizabeth\") fun genererEmploye() = Employe(noms.random(), Random.nextInt(from = salaireMin, until = salaireMax)) } fun main() { val empGen = GenerateurEmployeAleatoire(10, 30) println(empGen.genererEmploye()) println(empGen.genererEmploye()) println(empGen.genererEmploye()) empGen.salaireMin = 50 empGen.salaireMax = 100 println(empGen.genererEmploye()) }","title":"Exercice 2"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/08-valeurs-nulles/","text":"S\u00e9curit\u00e9 contre les valeurs nulles Source En Kotlin, il est possible d'avoir une valeur null . Pour aider \u00e0 pr\u00e9venir les probl\u00e8mes avec les valeurs null dans vos programmes, Kotlin a mis en place une s\u00e9curit\u00e9 contre les nullit\u00e9s. La s\u00e9curit\u00e9 contre les nullit\u00e9s d\u00e9tecte les probl\u00e8mes potentiels avec les valeurs null au moment de la compilation, plut\u00f4t qu'au moment de l'ex\u00e9cution. La s\u00e9curit\u00e9 contre les nullit\u00e9s est une combinaison de fonctionnalit\u00e9s qui vous permettent de : d\u00e9clarer explicitement quand les valeurs null sont autoris\u00e9es dans votre programme. v\u00e9rifier la pr\u00e9sence de valeurs null . utiliser des appels s\u00e9curis\u00e9s \u00e0 des propri\u00e9t\u00e9s ou des fonctions qui peuvent contenir des valeurs null . d\u00e9clarer des actions \u00e0 prendre si des valeurs null sont d\u00e9tect\u00e9es. Types Nullable Kotlin supporte les types Nullable qui permettent la possibilit\u00e9 pour le type d\u00e9clar\u00e9 d'avoir des valeurs null . Par d\u00e9faut, un type n'est pas autoris\u00e9 \u00e0 accepter des valeurs null . Les types Nullable sont d\u00e9clar\u00e9s en ajoutant explicitement ? apr\u00e8s la d\u00e9claration du type. Par exemple : fun main() { // neverNull a le type String var neverNull: String = \"Ceci ne peut pas \u00eatre null\" // L\u00e8ve une erreur de compilation neverNull = null // nullable a un type String nullable var nullable: String? = \"Vous pouvez garder un null ici\" // C'est OK nullable = null // Par d\u00e9faut, les valeurs null ne sont pas accept\u00e9es var inferredNonNull = \"Le compilateur suppose non-nullable\" // L\u00e8ve une erreur de compilation inferredNonNull = null // notNull n'accepte pas les valeurs null fun strLength(notNull: String): Int { return notNull.length } println(strLength(neverNull)) // 18 println(strLength(nullable)) // L\u00e8ve une erreur de compilation } length est une propri\u00e9t\u00e9 de la classe String qui contient le nombre de caract\u00e8res dans une cha\u00eene. V\u00e9rifier les valeurs nulles Vous pouvez v\u00e9rifier la pr\u00e9sence de valeurs null dans les expressions conditionnelles. Dans l'exemple suivant, la fonction describeString() a une instruction if qui v\u00e9rifie si maybeString n'est pas null et si sa length est sup\u00e9rieure \u00e0 z\u00e9ro : fun describeString(maybeString: String?): String { if (maybeString != null && maybeString.length > 0) { return \"Cha\u00eene de longueur ${maybeString.length}\" } else { return \"Cha\u00eene vide ou null\" } } fun main() { val nullString: String? = null println(describeString(nullString)) // Cha\u00eene vide ou null } Utiliser des appels s\u00e9curis\u00e9s Pour acc\u00e9der en toute s\u00e9curit\u00e9 aux propri\u00e9t\u00e9s d'un objet qui peut contenir une valeur null , utilisez l'op\u00e9rateur d'appel s\u00e9curis\u00e9 ?. . L'op\u00e9rateur d'appel s\u00e9curis\u00e9 renvoie null si l'objet ou l'une de ses propri\u00e9t\u00e9s acc\u00e9d\u00e9es est null . Ceci est utile si vous voulez \u00e9viter que la pr\u00e9sence de valeurs null d\u00e9clenche des erreurs dans votre code. Dans l'exemple suivant, la fonction lengthString() utilise un appel s\u00e9curis\u00e9 pour renvoyer soit la longueur de la cha\u00eene, soit null : fun lengthString(maybeString: String?): Int? = maybeString?.length fun main() { val nullString: String? = null println(lengthString(nullString)) // null } Les appels s\u00e9curis\u00e9s peuvent \u00eatre cha\u00een\u00e9s de mani\u00e8re \u00e0 ce que si une propri\u00e9t\u00e9 d'un objet contient une valeur null , alors null est renvoy\u00e9 sans qu'une erreur soit lev\u00e9e. Par exemple : kotlin person.company?.address?.country L'op\u00e9rateur d'appel s\u00e9curis\u00e9 peut \u00e9galement \u00eatre utilis\u00e9 pour appeler en toute s\u00e9curit\u00e9 une fonction d'extension ou de membre. Dans ce cas, une v\u00e9rification de nullit\u00e9 est effectu\u00e9e avant l'appel de la fonction. Si la v\u00e9rification d\u00e9tecte une valeur null , alors l'appel est saut\u00e9 et null est renvoy\u00e9. Dans l'exemple suivant, nullString est null donc l'invocation de .uppercase() est saut\u00e9e et null est renvoy\u00e9 : fun main() { val nullString: String? = null println(nullString?.uppercase()) // null } Utiliser l'op\u00e9rateur Elvis Vous pouvez fournir une valeur par d\u00e9faut \u00e0 retourner si une valeur null est d\u00e9tect\u00e9e en utilisant l' op\u00e9rateur Elvis ?: . \u00c9crivez sur le c\u00f4t\u00e9 gauche de l'op\u00e9rateur Elvis ce qui doit \u00eatre v\u00e9rifi\u00e9 pour une valeur null . \u00c9crivez sur le c\u00f4t\u00e9 droit de l'op\u00e9rateur Elvis ce qui doit \u00eatre renvoy\u00e9 si une valeur null est d\u00e9tect\u00e9e. Dans l'exemple suivant, nullString est null donc l'appel s\u00e9curis\u00e9 pour acc\u00e9der \u00e0 la propri\u00e9t\u00e9 length renvoie une valeur null . En cons\u00e9quence, l'op\u00e9rateur Elvis renvoie 0 : fun main() { val nullString: String? = null println(nullString?.length ?: 0) // 0 } Pour plus d'informations sur la s\u00e9curit\u00e9 des nullit\u00e9s en Kotlin, voir Null safety . Pratique Exercice Vous avez la fonction employeeById qui vous donne acc\u00e8s \u00e0 une base de donn\u00e9es d'employ\u00e9s d'une entreprise. Malheureusement, cette fonction renvoie une valeur du type Employee? , donc le r\u00e9sultat peut \u00eatre null . Votre but est d'\u00e9crire une fonction qui renvoie le salaire d'un employ\u00e9 quand son id est fourni, ou 0 si l'employ\u00e9 est manquant dans la base de donn\u00e9es. data class Employee (val name: String, var salary: Int) fun employeeById(id: Int) = when(id) { 1 -> Employee(\"Mary\", 20) 2 -> null 3 -> Employee(\"John\", 21) 4 -> Employee(\"Ann\", 23) else -> null } fun salaryById(id: Int) = // \u00c9crivez votre code ici fun main() { println((1..5).sumOf { id -> salaryById(id) }) } R\u00e9ponse data class Employee (val name: String, var salary: Int) fun employeeById(id: Int) = when(id) { 1 -> Employee(\"Mary\", 20) 2 -> null 3 -> Employee(\"John\", 21) 4 -> Employee(\"Ann\", 23) else -> null } fun salaryById(id: Int) = employeeById(id)?.salary ?: 0 fun main() { println((1..5).sumOf { id -> salaryById(id) }) }","title":"S\u00e9curit\u00e9 contre les valeurs nulles"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/08-valeurs-nulles/#securite-contre-les-valeurs-nulles","text":"Source En Kotlin, il est possible d'avoir une valeur null . Pour aider \u00e0 pr\u00e9venir les probl\u00e8mes avec les valeurs null dans vos programmes, Kotlin a mis en place une s\u00e9curit\u00e9 contre les nullit\u00e9s. La s\u00e9curit\u00e9 contre les nullit\u00e9s d\u00e9tecte les probl\u00e8mes potentiels avec les valeurs null au moment de la compilation, plut\u00f4t qu'au moment de l'ex\u00e9cution. La s\u00e9curit\u00e9 contre les nullit\u00e9s est une combinaison de fonctionnalit\u00e9s qui vous permettent de : d\u00e9clarer explicitement quand les valeurs null sont autoris\u00e9es dans votre programme. v\u00e9rifier la pr\u00e9sence de valeurs null . utiliser des appels s\u00e9curis\u00e9s \u00e0 des propri\u00e9t\u00e9s ou des fonctions qui peuvent contenir des valeurs null . d\u00e9clarer des actions \u00e0 prendre si des valeurs null sont d\u00e9tect\u00e9es.","title":"S\u00e9curit\u00e9 contre les valeurs nulles"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/08-valeurs-nulles/#types-nullable","text":"Kotlin supporte les types Nullable qui permettent la possibilit\u00e9 pour le type d\u00e9clar\u00e9 d'avoir des valeurs null . Par d\u00e9faut, un type n'est pas autoris\u00e9 \u00e0 accepter des valeurs null . Les types Nullable sont d\u00e9clar\u00e9s en ajoutant explicitement ? apr\u00e8s la d\u00e9claration du type. Par exemple : fun main() { // neverNull a le type String var neverNull: String = \"Ceci ne peut pas \u00eatre null\" // L\u00e8ve une erreur de compilation neverNull = null // nullable a un type String nullable var nullable: String? = \"Vous pouvez garder un null ici\" // C'est OK nullable = null // Par d\u00e9faut, les valeurs null ne sont pas accept\u00e9es var inferredNonNull = \"Le compilateur suppose non-nullable\" // L\u00e8ve une erreur de compilation inferredNonNull = null // notNull n'accepte pas les valeurs null fun strLength(notNull: String): Int { return notNull.length } println(strLength(neverNull)) // 18 println(strLength(nullable)) // L\u00e8ve une erreur de compilation } length est une propri\u00e9t\u00e9 de la classe String qui contient le nombre de caract\u00e8res dans une cha\u00eene.","title":"Types Nullable"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/08-valeurs-nulles/#verifier-les-valeurs-nulles","text":"Vous pouvez v\u00e9rifier la pr\u00e9sence de valeurs null dans les expressions conditionnelles. Dans l'exemple suivant, la fonction describeString() a une instruction if qui v\u00e9rifie si maybeString n'est pas null et si sa length est sup\u00e9rieure \u00e0 z\u00e9ro : fun describeString(maybeString: String?): String { if (maybeString != null && maybeString.length > 0) { return \"Cha\u00eene de longueur ${maybeString.length}\" } else { return \"Cha\u00eene vide ou null\" } } fun main() { val nullString: String? = null println(describeString(nullString)) // Cha\u00eene vide ou null }","title":"V\u00e9rifier les valeurs nulles"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/08-valeurs-nulles/#utiliser-des-appels-securises","text":"Pour acc\u00e9der en toute s\u00e9curit\u00e9 aux propri\u00e9t\u00e9s d'un objet qui peut contenir une valeur null , utilisez l'op\u00e9rateur d'appel s\u00e9curis\u00e9 ?. . L'op\u00e9rateur d'appel s\u00e9curis\u00e9 renvoie null si l'objet ou l'une de ses propri\u00e9t\u00e9s acc\u00e9d\u00e9es est null . Ceci est utile si vous voulez \u00e9viter que la pr\u00e9sence de valeurs null d\u00e9clenche des erreurs dans votre code. Dans l'exemple suivant, la fonction lengthString() utilise un appel s\u00e9curis\u00e9 pour renvoyer soit la longueur de la cha\u00eene, soit null : fun lengthString(maybeString: String?): Int? = maybeString?.length fun main() { val nullString: String? = null println(lengthString(nullString)) // null } Les appels s\u00e9curis\u00e9s peuvent \u00eatre cha\u00een\u00e9s de mani\u00e8re \u00e0 ce que si une propri\u00e9t\u00e9 d'un objet contient une valeur null , alors null est renvoy\u00e9 sans qu'une erreur soit lev\u00e9e. Par exemple : kotlin person.company?.address?.country L'op\u00e9rateur d'appel s\u00e9curis\u00e9 peut \u00e9galement \u00eatre utilis\u00e9 pour appeler en toute s\u00e9curit\u00e9 une fonction d'extension ou de membre. Dans ce cas, une v\u00e9rification de nullit\u00e9 est effectu\u00e9e avant l'appel de la fonction. Si la v\u00e9rification d\u00e9tecte une valeur null , alors l'appel est saut\u00e9 et null est renvoy\u00e9. Dans l'exemple suivant, nullString est null donc l'invocation de .uppercase() est saut\u00e9e et null est renvoy\u00e9 : fun main() { val nullString: String? = null println(nullString?.uppercase()) // null }","title":"Utiliser des appels s\u00e9curis\u00e9s"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/08-valeurs-nulles/#utiliser-loperateur-elvis","text":"Vous pouvez fournir une valeur par d\u00e9faut \u00e0 retourner si une valeur null est d\u00e9tect\u00e9e en utilisant l' op\u00e9rateur Elvis ?: . \u00c9crivez sur le c\u00f4t\u00e9 gauche de l'op\u00e9rateur Elvis ce qui doit \u00eatre v\u00e9rifi\u00e9 pour une valeur null . \u00c9crivez sur le c\u00f4t\u00e9 droit de l'op\u00e9rateur Elvis ce qui doit \u00eatre renvoy\u00e9 si une valeur null est d\u00e9tect\u00e9e. Dans l'exemple suivant, nullString est null donc l'appel s\u00e9curis\u00e9 pour acc\u00e9der \u00e0 la propri\u00e9t\u00e9 length renvoie une valeur null . En cons\u00e9quence, l'op\u00e9rateur Elvis renvoie 0 : fun main() { val nullString: String? = null println(nullString?.length ?: 0) // 0 } Pour plus d'informations sur la s\u00e9curit\u00e9 des nullit\u00e9s en Kotlin, voir Null safety .","title":"Utiliser l'op\u00e9rateur Elvis"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/08-valeurs-nulles/#pratique","text":"","title":"Pratique"},{"location":"1.%20Kotlin/Survol%20de%20Kotlin/08-valeurs-nulles/#exercice","text":"Vous avez la fonction employeeById qui vous donne acc\u00e8s \u00e0 une base de donn\u00e9es d'employ\u00e9s d'une entreprise. Malheureusement, cette fonction renvoie une valeur du type Employee? , donc le r\u00e9sultat peut \u00eatre null . Votre but est d'\u00e9crire une fonction qui renvoie le salaire d'un employ\u00e9 quand son id est fourni, ou 0 si l'employ\u00e9 est manquant dans la base de donn\u00e9es. data class Employee (val name: String, var salary: Int) fun employeeById(id: Int) = when(id) { 1 -> Employee(\"Mary\", 20) 2 -> null 3 -> Employee(\"John\", 21) 4 -> Employee(\"Ann\", 23) else -> null } fun salaryById(id: Int) = // \u00c9crivez votre code ici fun main() { println((1..5).sumOf { id -> salaryById(id) }) } R\u00e9ponse data class Employee (val name: String, var salary: Int) fun employeeById(id: Int) = when(id) { 1 -> Employee(\"Mary\", 20) 2 -> null 3 -> Employee(\"John\", 21) 4 -> Employee(\"Ann\", 23) else -> null } fun salaryById(id: Int) = employeeById(id)?.salary ?: 0 fun main() { println((1..5).sumOf { id -> salaryById(id) }) }","title":"Exercice"},{"location":"2.%20Android/01-intro/","text":"1. Introduction \u00e0 la programmation mobile et Android La programmation mobile repr\u00e9sente un domaine passionnant et en constante \u00e9volution dans le monde du d\u00e9veloppement logiciel. Elle offre aux d\u00e9veloppeurs la possibilit\u00e9 de cr\u00e9er des applications qui accompagnent les utilisateurs partout, transformant la fa\u00e7on dont nous interagissons avec la technologie au quotidien. D\u00e9fis de la programmation mobile Le d\u00e9veloppement d'applications mobiles pr\u00e9sente des d\u00e9fis uniques par rapport aux plateformes traditionnelles : Ressources limit\u00e9es : Les appareils mobiles ont g\u00e9n\u00e9ralement moins de puissance de traitement, de m\u00e9moire et de batterie que les ordinateurs de bureau. Diversit\u00e9 des appareils : Il existe une grande vari\u00e9t\u00e9 de tailles d'\u00e9cran, de r\u00e9solutions et de capacit\u00e9s mat\u00e9rielles \u00e0 prendre en compte. Connectivit\u00e9 intermittente : Les applications mobiles doivent souvent fonctionner avec une connexion Internet instable ou inexistante. Interactions tactiles : L'interface utilisateur doit \u00eatre con\u00e7ue pour des interactions tactiles plut\u00f4t que pour la souris et le clavier. Cycle de vie des applications : Les applications mobiles peuvent \u00eatre interrompues \u00e0 tout moment par des appels, des notifications ou d'autres \u00e9v\u00e9nements syst\u00e8me. Android vs autres plateformes Android se distingue par plusieurs aspects : Open source : Contrairement \u00e0 iOS, Android est un syst\u00e8me d'exploitation open source, offrant plus de flexibilit\u00e9 aux d\u00e9veloppeurs. Part de march\u00e9 : Android domine le march\u00e9 mondial des smartphones avec plus de 70% de part de march\u00e9. Diversit\u00e9 des appareils : Android fonctionne sur une grande vari\u00e9t\u00e9 d'appareils de diff\u00e9rents fabricants, contrairement \u00e0 iOS qui est limit\u00e9 aux appareils Apple. Processus de publication : La publication d'applications sur le Google Play Store est g\u00e9n\u00e9ralement plus rapide et moins restrictive que sur l'App Store d'Apple. Historique des versions d'Android 2008 : Android 1.0 (API 1) 2009 : Android 2.0 (Eclair, API 5) 2010 : Android 2.2 (Froyo, API 8) et 2.3 (Gingerbread, API 9) 2011 : Android 3.0 (Honeycomb, API 11) et 4.0 (Ice Cream Sandwich, API 14) 2012 : Android 4.1 (Jelly Bean, API 16) 2013 : Android 4.4 (KitKat, API 19) 2014 : Android 5.0 (Lollipop, API 21) 2015 : Android 6.0 (Marshmallow, API 23) 2016 : Android 7.0 (Nougat, API 24) 2017 : Android 8.0 (Oreo, API 26) 2018 : Android 9 (Pie, API 28) 2019 : Android 10 (API 29) 2020 : Android 11 (API 30) 2021 : Android 12 (API 31) 2022 : Android 13 (API 33) 2023 : Android 14 (API 34) Cette liste met en \u00e9vidence la progression des versions d'Android et leurs API correspondantes. Il est important de noter que chaque nouvelle version d'API apporte g\u00e9n\u00e9ralement de nouvelles fonctionnalit\u00e9s, des am\u00e9liorations de performance et des changements dans la fa\u00e7on dont les d\u00e9veloppeurs interagissent avec le syst\u00e8me Android. Les num\u00e9ros d'API sont particuli\u00e8rement importants pour les d\u00e9veloppeurs car ils d\u00e9terminent : Les fonctionnalit\u00e9s disponibles pour l'application. La compatibilit\u00e9 de l'application avec diff\u00e9rents appareils Android. Les exigences minimales et cibles pour la publication sur le Google Play Store. Lors du d\u00e9veloppement d'une application Android, les d\u00e9veloppeurs doivent choisir une version d'API minimale (qui d\u00e9termine les appareils les plus anciens support\u00e9s) et une version d'API cible (g\u00e9n\u00e9ralement la plus r\u00e9cente pour profiter des derni\u00e8res fonctionnalit\u00e9s et optimisations). Cette progression constante des versions d'API souligne l'importance pour les d\u00e9veloppeurs Android de rester \u00e0 jour avec les derni\u00e8res \u00e9volutions de la plateforme et d'adapter leurs applications en cons\u00e9quence. Applications classiques vs modernes sur Android Applications classiques (Java) Utilisation de Java comme langage principal Interface utilisateur d\u00e9finie en XML Utilisation d'Activities et de Fragments pour la structure de l'application Cycle de vie des composants plus complexe \u00e0 g\u00e9rer Applications modernes (Kotlin avec Jetpack Compose) Utilisation de Kotlin, un langage plus moderne et concis Interface utilisateur d\u00e9finie de mani\u00e8re d\u00e9clarative avec Jetpack Compose Structure d'application plus flexible et modulaire Gestion simplifi\u00e9e du cycle de vie des composants Meilleure performance et moins de code boilerplate Support natif pour la programmation asynchrone et r\u00e9active Le passage de Java \u00e0 Kotlin et l'adoption de Jetpack Compose repr\u00e9sentent une \u00e9volution majeure dans le d\u00e9veloppement Android, offrant aux d\u00e9veloppeurs des outils plus puissants et une exp\u00e9rience de d\u00e9veloppement plus agr\u00e9able. En conclusion, la programmation mobile Android offre de nombreuses opportunit\u00e9s et d\u00e9fis. Avec l'\u00e9volution constante de la plateforme et des outils de d\u00e9veloppement, il est crucial pour les d\u00e9veloppeurs de rester \u00e0 jour et d'adopter les meilleures pratiques pour cr\u00e9er des applications performantes et attrayantes. \u00c9tapes de d\u00e9veloppement d'une application mobile Android Le d\u00e9veloppement d'une application mobile est un processus complexe qui implique plusieurs \u00e9tapes, de la conception initiale au d\u00e9ploiement final. Voici un aper\u00e7u d\u00e9taill\u00e9 des principales \u00e9tapes pour d\u00e9velopper une application mobile Android, en incluant les phases de test et de d\u00e9ploiement : 1. Conception et planification D\u00e9finir les objectifs et les fonctionnalit\u00e9s de l'application R\u00e9aliser une \u00e9tude de march\u00e9 et une analyse de la concurrence Cr\u00e9er des wireframes et des maquettes de l'interface utilisateur \u00c9laborer un plan de d\u00e9veloppement et un calendrier 2. Configuration de l'environnement de d\u00e9veloppement Installer Android Studio Configurer le SDK Android et les outils n\u00e9cessaires Mettre en place un syst\u00e8me de contr\u00f4le de version (ex: Git) 3. D\u00e9veloppement Coder l'interface utilisateur (UI) avec Jetpack Compose Impl\u00e9menter la logique m\u00e9tier en Kotlin Int\u00e9grer les API n\u00e9cessaires (Google Maps, paiement, etc.) G\u00e9rer le stockage local des donn\u00e9es (SharedPreferences, Room) Impl\u00e9menter les fonctionnalit\u00e9s de connectivit\u00e9 r\u00e9seau 4. Tests a. Tests unitaires \u00c9crire et ex\u00e9cuter des tests unitaires pour les composants individuels Utiliser JUnit et Mockito pour tester la logique m\u00e9tier b. Tests d'int\u00e9gration Tester l'interaction entre diff\u00e9rents modules de l'application Utiliser Espresso pour les tests d'interface utilisateur automatis\u00e9s c. Tests manuels Effectuer des tests fonctionnels sur diff\u00e9rents appareils et versions d'Android Tester les sc\u00e9narios d'utilisation r\u00e9els d. Tests de performance Analyser les performances de l'application (utilisation CPU, m\u00e9moire, batterie) Utiliser Android Profiler pour identifier les goulots d'\u00e9tranglement 5. D\u00e9bogage et optimisation Corriger les bugs identifi\u00e9s lors des tests Optimiser les performances de l'application Am\u00e9liorer l'exp\u00e9rience utilisateur en fonction des retours 6. Pr\u00e9paration au d\u00e9ploiement G\u00e9n\u00e9rer une version sign\u00e9e de l'APK ou du bundle App Pr\u00e9parer les ressources marketing (ic\u00f4nes, captures d'\u00e9cran, descriptions) R\u00e9diger la politique de confidentialit\u00e9 et les conditions d'utilisation 7. D\u00e9ploiement sur le Google Play Store Cr\u00e9er un compte d\u00e9veloppeur Google Play Configurer la fiche de l'application sur la console Google Play T\u00e9l\u00e9verser l'APK ou le bundle App D\u00e9finir les pays de distribution et les prix (si applicable) Soumettre l'application pour examen 8. Surveillance et maintenance post-lancement Surveiller les statistiques d'installation et d'utilisation Collecter et analyser les retours des utilisateurs R\u00e9pondre aux commentaires et aux questions des utilisateurs Planifier et d\u00e9velopper des mises \u00e0 jour r\u00e9guli\u00e8res 9. Mises \u00e0 jour et it\u00e9rations Corriger les bugs signal\u00e9s par les utilisateurs Ajouter de nouvelles fonctionnalit\u00e9s bas\u00e9es sur les retours Adapter l'application aux nouvelles versions d'Android et aux nouveaux appareils 10. Marketing et promotion continus Mettre en \u0153uvre des strat\u00e9gies d'ASO (App Store Optimization) Promouvoir l'application sur les r\u00e9seaux sociaux et autres canaux Analyser les m\u00e9triques de performance et ajuster la strat\u00e9gie marketing Ce processus est it\u00e9ratif, et de nombreuses \u00e9tapes peuvent se chevaucher ou \u00eatre r\u00e9p\u00e9t\u00e9es au fur et \u00e0 mesure du d\u00e9veloppement et de l'\u00e9volution de l'application. Il est crucial de rester flexible et r\u00e9actif aux changements du march\u00e9, aux retours des utilisateurs et aux avanc\u00e9es technologiques tout au long du cycle de vie de l'application. Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"1. Introduction \u00e0 la programmation mobile et Android"},{"location":"2.%20Android/01-intro/#1-introduction-a-la-programmation-mobile-et-android","text":"La programmation mobile repr\u00e9sente un domaine passionnant et en constante \u00e9volution dans le monde du d\u00e9veloppement logiciel. Elle offre aux d\u00e9veloppeurs la possibilit\u00e9 de cr\u00e9er des applications qui accompagnent les utilisateurs partout, transformant la fa\u00e7on dont nous interagissons avec la technologie au quotidien.","title":"1. Introduction \u00e0 la programmation mobile et Android"},{"location":"2.%20Android/01-intro/#defis-de-la-programmation-mobile","text":"Le d\u00e9veloppement d'applications mobiles pr\u00e9sente des d\u00e9fis uniques par rapport aux plateformes traditionnelles : Ressources limit\u00e9es : Les appareils mobiles ont g\u00e9n\u00e9ralement moins de puissance de traitement, de m\u00e9moire et de batterie que les ordinateurs de bureau. Diversit\u00e9 des appareils : Il existe une grande vari\u00e9t\u00e9 de tailles d'\u00e9cran, de r\u00e9solutions et de capacit\u00e9s mat\u00e9rielles \u00e0 prendre en compte. Connectivit\u00e9 intermittente : Les applications mobiles doivent souvent fonctionner avec une connexion Internet instable ou inexistante. Interactions tactiles : L'interface utilisateur doit \u00eatre con\u00e7ue pour des interactions tactiles plut\u00f4t que pour la souris et le clavier. Cycle de vie des applications : Les applications mobiles peuvent \u00eatre interrompues \u00e0 tout moment par des appels, des notifications ou d'autres \u00e9v\u00e9nements syst\u00e8me.","title":"D\u00e9fis de la programmation mobile"},{"location":"2.%20Android/01-intro/#android-vs-autres-plateformes","text":"Android se distingue par plusieurs aspects : Open source : Contrairement \u00e0 iOS, Android est un syst\u00e8me d'exploitation open source, offrant plus de flexibilit\u00e9 aux d\u00e9veloppeurs. Part de march\u00e9 : Android domine le march\u00e9 mondial des smartphones avec plus de 70% de part de march\u00e9. Diversit\u00e9 des appareils : Android fonctionne sur une grande vari\u00e9t\u00e9 d'appareils de diff\u00e9rents fabricants, contrairement \u00e0 iOS qui est limit\u00e9 aux appareils Apple. Processus de publication : La publication d'applications sur le Google Play Store est g\u00e9n\u00e9ralement plus rapide et moins restrictive que sur l'App Store d'Apple.","title":"Android vs autres plateformes"},{"location":"2.%20Android/01-intro/#historique-des-versions-dandroid","text":"2008 : Android 1.0 (API 1) 2009 : Android 2.0 (Eclair, API 5) 2010 : Android 2.2 (Froyo, API 8) et 2.3 (Gingerbread, API 9) 2011 : Android 3.0 (Honeycomb, API 11) et 4.0 (Ice Cream Sandwich, API 14) 2012 : Android 4.1 (Jelly Bean, API 16) 2013 : Android 4.4 (KitKat, API 19) 2014 : Android 5.0 (Lollipop, API 21) 2015 : Android 6.0 (Marshmallow, API 23) 2016 : Android 7.0 (Nougat, API 24) 2017 : Android 8.0 (Oreo, API 26) 2018 : Android 9 (Pie, API 28) 2019 : Android 10 (API 29) 2020 : Android 11 (API 30) 2021 : Android 12 (API 31) 2022 : Android 13 (API 33) 2023 : Android 14 (API 34) Cette liste met en \u00e9vidence la progression des versions d'Android et leurs API correspondantes. Il est important de noter que chaque nouvelle version d'API apporte g\u00e9n\u00e9ralement de nouvelles fonctionnalit\u00e9s, des am\u00e9liorations de performance et des changements dans la fa\u00e7on dont les d\u00e9veloppeurs interagissent avec le syst\u00e8me Android. Les num\u00e9ros d'API sont particuli\u00e8rement importants pour les d\u00e9veloppeurs car ils d\u00e9terminent : Les fonctionnalit\u00e9s disponibles pour l'application. La compatibilit\u00e9 de l'application avec diff\u00e9rents appareils Android. Les exigences minimales et cibles pour la publication sur le Google Play Store. Lors du d\u00e9veloppement d'une application Android, les d\u00e9veloppeurs doivent choisir une version d'API minimale (qui d\u00e9termine les appareils les plus anciens support\u00e9s) et une version d'API cible (g\u00e9n\u00e9ralement la plus r\u00e9cente pour profiter des derni\u00e8res fonctionnalit\u00e9s et optimisations). Cette progression constante des versions d'API souligne l'importance pour les d\u00e9veloppeurs Android de rester \u00e0 jour avec les derni\u00e8res \u00e9volutions de la plateforme et d'adapter leurs applications en cons\u00e9quence.","title":"Historique des versions d'Android"},{"location":"2.%20Android/01-intro/#applications-classiques-vs-modernes-sur-android","text":"","title":"Applications classiques vs modernes sur Android"},{"location":"2.%20Android/01-intro/#applications-classiques-java","text":"Utilisation de Java comme langage principal Interface utilisateur d\u00e9finie en XML Utilisation d'Activities et de Fragments pour la structure de l'application Cycle de vie des composants plus complexe \u00e0 g\u00e9rer","title":"Applications classiques (Java)"},{"location":"2.%20Android/01-intro/#applications-modernes-kotlin-avec-jetpack-compose","text":"Utilisation de Kotlin, un langage plus moderne et concis Interface utilisateur d\u00e9finie de mani\u00e8re d\u00e9clarative avec Jetpack Compose Structure d'application plus flexible et modulaire Gestion simplifi\u00e9e du cycle de vie des composants Meilleure performance et moins de code boilerplate Support natif pour la programmation asynchrone et r\u00e9active Le passage de Java \u00e0 Kotlin et l'adoption de Jetpack Compose repr\u00e9sentent une \u00e9volution majeure dans le d\u00e9veloppement Android, offrant aux d\u00e9veloppeurs des outils plus puissants et une exp\u00e9rience de d\u00e9veloppement plus agr\u00e9able. En conclusion, la programmation mobile Android offre de nombreuses opportunit\u00e9s et d\u00e9fis. Avec l'\u00e9volution constante de la plateforme et des outils de d\u00e9veloppement, il est crucial pour les d\u00e9veloppeurs de rester \u00e0 jour et d'adopter les meilleures pratiques pour cr\u00e9er des applications performantes et attrayantes.","title":"Applications modernes (Kotlin avec Jetpack Compose)"},{"location":"2.%20Android/01-intro/#etapes-de-developpement-dune-application-mobile-android","text":"Le d\u00e9veloppement d'une application mobile est un processus complexe qui implique plusieurs \u00e9tapes, de la conception initiale au d\u00e9ploiement final. Voici un aper\u00e7u d\u00e9taill\u00e9 des principales \u00e9tapes pour d\u00e9velopper une application mobile Android, en incluant les phases de test et de d\u00e9ploiement :","title":"\u00c9tapes de d\u00e9veloppement d'une application mobile Android"},{"location":"2.%20Android/01-intro/#1-conception-et-planification","text":"D\u00e9finir les objectifs et les fonctionnalit\u00e9s de l'application R\u00e9aliser une \u00e9tude de march\u00e9 et une analyse de la concurrence Cr\u00e9er des wireframes et des maquettes de l'interface utilisateur \u00c9laborer un plan de d\u00e9veloppement et un calendrier","title":"1. Conception et planification"},{"location":"2.%20Android/01-intro/#2-configuration-de-lenvironnement-de-developpement","text":"Installer Android Studio Configurer le SDK Android et les outils n\u00e9cessaires Mettre en place un syst\u00e8me de contr\u00f4le de version (ex: Git)","title":"2. Configuration de l'environnement de d\u00e9veloppement"},{"location":"2.%20Android/01-intro/#3-developpement","text":"Coder l'interface utilisateur (UI) avec Jetpack Compose Impl\u00e9menter la logique m\u00e9tier en Kotlin Int\u00e9grer les API n\u00e9cessaires (Google Maps, paiement, etc.) G\u00e9rer le stockage local des donn\u00e9es (SharedPreferences, Room) Impl\u00e9menter les fonctionnalit\u00e9s de connectivit\u00e9 r\u00e9seau","title":"3. D\u00e9veloppement"},{"location":"2.%20Android/01-intro/#4-tests","text":"","title":"4. Tests"},{"location":"2.%20Android/01-intro/#a-tests-unitaires","text":"\u00c9crire et ex\u00e9cuter des tests unitaires pour les composants individuels Utiliser JUnit et Mockito pour tester la logique m\u00e9tier","title":"a. Tests unitaires"},{"location":"2.%20Android/01-intro/#b-tests-dintegration","text":"Tester l'interaction entre diff\u00e9rents modules de l'application Utiliser Espresso pour les tests d'interface utilisateur automatis\u00e9s","title":"b. Tests d'int\u00e9gration"},{"location":"2.%20Android/01-intro/#c-tests-manuels","text":"Effectuer des tests fonctionnels sur diff\u00e9rents appareils et versions d'Android Tester les sc\u00e9narios d'utilisation r\u00e9els","title":"c. Tests manuels"},{"location":"2.%20Android/01-intro/#d-tests-de-performance","text":"Analyser les performances de l'application (utilisation CPU, m\u00e9moire, batterie) Utiliser Android Profiler pour identifier les goulots d'\u00e9tranglement","title":"d. Tests de performance"},{"location":"2.%20Android/01-intro/#5-debogage-et-optimisation","text":"Corriger les bugs identifi\u00e9s lors des tests Optimiser les performances de l'application Am\u00e9liorer l'exp\u00e9rience utilisateur en fonction des retours","title":"5. D\u00e9bogage et optimisation"},{"location":"2.%20Android/01-intro/#6-preparation-au-deploiement","text":"G\u00e9n\u00e9rer une version sign\u00e9e de l'APK ou du bundle App Pr\u00e9parer les ressources marketing (ic\u00f4nes, captures d'\u00e9cran, descriptions) R\u00e9diger la politique de confidentialit\u00e9 et les conditions d'utilisation","title":"6. Pr\u00e9paration au d\u00e9ploiement"},{"location":"2.%20Android/01-intro/#7-deploiement-sur-le-google-play-store","text":"Cr\u00e9er un compte d\u00e9veloppeur Google Play Configurer la fiche de l'application sur la console Google Play T\u00e9l\u00e9verser l'APK ou le bundle App D\u00e9finir les pays de distribution et les prix (si applicable) Soumettre l'application pour examen","title":"7. D\u00e9ploiement sur le Google Play Store"},{"location":"2.%20Android/01-intro/#8-surveillance-et-maintenance-post-lancement","text":"Surveiller les statistiques d'installation et d'utilisation Collecter et analyser les retours des utilisateurs R\u00e9pondre aux commentaires et aux questions des utilisateurs Planifier et d\u00e9velopper des mises \u00e0 jour r\u00e9guli\u00e8res","title":"8. Surveillance et maintenance post-lancement"},{"location":"2.%20Android/01-intro/#9-mises-a-jour-et-iterations","text":"Corriger les bugs signal\u00e9s par les utilisateurs Ajouter de nouvelles fonctionnalit\u00e9s bas\u00e9es sur les retours Adapter l'application aux nouvelles versions d'Android et aux nouveaux appareils","title":"9. Mises \u00e0 jour et it\u00e9rations"},{"location":"2.%20Android/01-intro/#10-marketing-et-promotion-continus","text":"Mettre en \u0153uvre des strat\u00e9gies d'ASO (App Store Optimization) Promouvoir l'application sur les r\u00e9seaux sociaux et autres canaux Analyser les m\u00e9triques de performance et ajuster la strat\u00e9gie marketing Ce processus est it\u00e9ratif, et de nombreuses \u00e9tapes peuvent se chevaucher ou \u00eatre r\u00e9p\u00e9t\u00e9es au fur et \u00e0 mesure du d\u00e9veloppement et de l'\u00e9volution de l'application. Il est crucial de rester flexible et r\u00e9actif aux changements du march\u00e9, aux retours des utilisateurs et aux avanc\u00e9es technologiques tout au long du cycle de vie de l'application. Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"10. Marketing et promotion continus"},{"location":"2.%20Android/02-intro-compose/","text":"2. Introduction \u00e0 Jetpack Compose Jetpack Compose est une bo\u00eete \u00e0 outils moderne pour le d\u00e9veloppement d'interfaces utilisateur natives sur Android. Lanc\u00e9 par Google, il repr\u00e9sente une \u00e9volution majeure dans la fa\u00e7on dont les d\u00e9veloppeurs cr\u00e9ent des interfaces pour les applications Android. Motivations et historique Motivations Simplification du d\u00e9veloppement UI : R\u00e9duire la complexit\u00e9 et le code boilerplate associ\u00e9s \u00e0 la cr\u00e9ation d'interfaces utilisateur. Approche d\u00e9clarative : Permettre aux d\u00e9veloppeurs de d\u00e9crire ce qu'ils veulent afficher plut\u00f4t que comment le construire. Performances am\u00e9lior\u00e9es : Optimiser le rendu et les mises \u00e0 jour de l'interface utilisateur. Coh\u00e9rence avec les tendances modernes : S'aligner sur les approches modernes de d\u00e9veloppement UI comme React et SwiftUI. Historique 2019 : Annonce initiale de Jetpack Compose lors de la Google I/O. 2020 : Sortie des premi\u00e8res versions alpha pour les d\u00e9veloppeurs. Juillet 2021 : Lancement officiel de la version 1.0 stable. Depuis, Compose continue d'\u00e9voluer avec des mises \u00e0 jour r\u00e9guli\u00e8res apportant de nouvelles fonctionnalit\u00e9s et am\u00e9liorations. Entreprises et organisations utilisant Kotlin et Compose Google : Utilise Kotlin et Compose dans de nombreuses applications comme Google Play, Google Home, et Google Drive. Raison : Am\u00e9lioration de la productivit\u00e9 des d\u00e9veloppeurs et coh\u00e9rence avec les recommandations Android. Netflix : A adopt\u00e9 Kotlin pour son application Android. Raison : S\u00e9curit\u00e9 du type, r\u00e9duction des erreurs, et expressivit\u00e9 du code. Airbnb : Utilise Kotlin dans son application mobile. Raison : Interop\u00e9rabilit\u00e9 avec Java existant et am\u00e9lioration de la qualit\u00e9 du code. Pinterest : A migr\u00e9 vers Kotlin pour son d\u00e9veloppement Android. Raison : Syntaxe concise et fonctionnalit\u00e9s modernes du langage. Uber : Utilise Kotlin dans ses applications mobiles. Raison : Am\u00e9lioration de la productivit\u00e9 des d\u00e9veloppeurs et r\u00e9duction des bugs. Trello : A adopt\u00e9 Kotlin pour son application Android. Raison : Expressivit\u00e9 du langage et meilleures pratiques de programmation. Evernote : Utilise Kotlin dans son application Android. Raison : Code plus propre et plus facile \u00e0 maintenir. Basecamp : A migr\u00e9 son application vers Kotlin. Raison : S\u00e9curit\u00e9 accrue et syntaxe plus agr\u00e9able pour les d\u00e9veloppeurs. Corda : Plateforme blockchain d\u00e9velopp\u00e9e enti\u00e8rement en Kotlin. Raison : Robustesse du langage pour les syst\u00e8mes critiques. Coursera : Utilise Kotlin pour son application mobile. Raison : Am\u00e9lioration de la qualit\u00e9 du code et de la vitesse de d\u00e9veloppement. Ces entreprises ont choisi Kotlin et, pour certaines, Compose, principalement pour : La productivit\u00e9 accrue des d\u00e9veloppeurs La r\u00e9duction des erreurs et des crashs La modernit\u00e9 et l'expressivit\u00e9 du langage La compatibilit\u00e9 avec l'\u00e9cosyst\u00e8me Java existant L'am\u00e9lioration de la maintenabilit\u00e9 du code L'adoption croissante de Compose, bien que plus r\u00e9cente, est motiv\u00e9e par sa capacit\u00e9 \u00e0 simplifier et acc\u00e9l\u00e9rer le d\u00e9veloppement d'interfaces utilisateur modernes et performantes sur Android. Principes de base d'une application Compose Structure de l'application Composables : Fonctions annot\u00e9es avec @Composable qui d\u00e9crivent une partie de l'interface utilisateur. \u00c9tat : Donn\u00e9es qui peuvent changer au fil du temps et qui influencent l'IU (interface utilisateur). Recomposition : Processus de mise \u00e0 jour de l'IU lorsque l'\u00e9tat change. Composants typiques Agencement des composables ( Layout ) : Column , Row , Box pour structurer l'IU. Elements de l'IU : Text , Button , Image , etc., pour afficher du contenu. Modificateurs : Pour personnaliser l'apparence et le comportement des composables. Ascension de l'\u00e9tat ( State Hoisting ) : Technique pour g\u00e9rer et partager l'\u00e9tat entre composants. Navigation : Gestion des diff\u00e9rents \u00e9crans et du flux de l'application. Th\u00e8mes : Personnalisation coh\u00e9rente de l'apparence de l'application. Jetpack Compose offre plusieurs avantages significatifs par rapport aux m\u00e9thodes de d\u00e9veloppement Android traditionnelles bas\u00e9es sur XML et le syst\u00e8me de vues. Voici les principaux avantages de Jetpack Compose : Avantages de Jetpack Compose 1. Simplicit\u00e9 et concision du code Moins de code boilerplate : Compose r\u00e9duit consid\u00e9rablement la quantit\u00e9 de code n\u00e9cessaire pour cr\u00e9er des interfaces utilisateur complexes. Code plus lisible : La nature d\u00e9clarative de Compose rend le code plus facile \u00e0 lire et \u00e0 comprendre. Unification du code UI : Plus besoin de jongler entre XML et Java/Kotlin, tout est dans un seul langage (Kotlin). 2. D\u00e9veloppement plus rapide Pr\u00e9visualisation en temps r\u00e9el : Les d\u00e9veloppeurs peuvent voir les changements d'UI instantan\u00e9ment sans avoir \u00e0 recompiler l'application enti\u00e8re. It\u00e9rations plus rapides : La combinaison de la pr\u00e9visualisation en temps r\u00e9el et du code plus concis permet des it\u00e9rations de d\u00e9veloppement plus rapides. 3. Approche d\u00e9clarative Description de l'\u00e9tat final : Les d\u00e9veloppeurs d\u00e9crivent ce que l'UI devrait \u00eatre, plut\u00f4t que les \u00e9tapes pour y arriver. Gestion d'\u00e9tat simplifi\u00e9e : Compose facilite la gestion de l'\u00e9tat de l'application et sa synchronisation avec l'UI. 4. Flexibilit\u00e9 et r\u00e9utilisabilit\u00e9 Composants hautement r\u00e9utilisables : Il est facile de cr\u00e9er des composants UI r\u00e9utilisables et de les partager entre diff\u00e9rentes parties de l'application. Personnalisation facile : Les composants peuvent \u00eatre facilement personnalis\u00e9s gr\u00e2ce aux modifiers et aux param\u00e8tres. 5. Performance am\u00e9lior\u00e9e Optimisations automatiques : Compose optimise automatiquement les recompositions pour minimiser les mises \u00e0 jour inutiles de l'UI. Rendu efficace : Le syst\u00e8me de rendu de Compose est con\u00e7u pour \u00eatre plus efficace que le syst\u00e8me de vues traditionnel. 6. Meilleure interop\u00e9rabilit\u00e9 Int\u00e9gration avec les vues existantes : Compose peut \u00eatre int\u00e9gr\u00e9 progressivement dans des applications existantes, permettant une migration en douceur. Support des biblioth\u00e8ques Android existantes : Compose fonctionne bien avec les biblioth\u00e8ques et composants Android existants. 7. Tests simplifi\u00e9s Tests unitaires plus faciles : Les composables \u00e9tant des fonctions Kotlin, ils sont plus faciles \u00e0 tester unitairement. Moins de tests d'UI n\u00e9cessaires : La nature d\u00e9clarative de Compose r\u00e9duit le besoin de tests d'UI exhaustifs. 8. Coh\u00e9rence avec Material Design Impl\u00e9mentation native de Material Design : Compose fournit des composants Material Design pr\u00eats \u00e0 l'emploi, facilitant la cr\u00e9ation d'interfaces conformes aux directives de Google. 9. Support multiplateforme Potentiel pour le d\u00e9veloppement multiplateforme : Bien que principalement pour Android, Compose a le potentiel d'\u00eatre utilis\u00e9 pour le d\u00e9veloppement d'applications de bureau et web (avec Compose for Desktop et Compose for Web). 10. Courbe d'apprentissage r\u00e9duite Concepts unifi\u00e9s : Une fois les concepts de base ma\u00eetris\u00e9s, il est plus facile de cr\u00e9er des interfaces complexes. Documentation et ressources de qualit\u00e9 : Google fournit une documentation extensive et des codelabs pour faciliter l'apprentissage. 11. Meilleure gestion des animations API d'animation intuitive : Compose offre des API d'animation plus simples et plus puissantes que les m\u00e9thodes traditionnelles. 12. Adaptation aux diff\u00e9rentes tailles d'\u00e9cran Responsive design facilit\u00e9 : Compose simplifie la cr\u00e9ation d'interfaces qui s'adaptent \u00e0 diff\u00e9rentes tailles d'\u00e9cran, un aspect crucial pour les applications Android modernes. En conclusion, Jetpack Compose repr\u00e9sente une \u00e9volution majeure dans le d\u00e9veloppement Android, offrant une approche plus moderne, efficace et agr\u00e9able pour cr\u00e9er des interfaces utilisateur. Bien qu'il y ait une courbe d'apprentissage initiale, les avantages \u00e0 long terme en termes de productivit\u00e9, de maintenabilit\u00e9 et de qualit\u00e9 du code sont significatifs. Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"2. Introduction \u00e0 Jetpack Compose"},{"location":"2.%20Android/02-intro-compose/#2-introduction-a-jetpack-compose","text":"Jetpack Compose est une bo\u00eete \u00e0 outils moderne pour le d\u00e9veloppement d'interfaces utilisateur natives sur Android. Lanc\u00e9 par Google, il repr\u00e9sente une \u00e9volution majeure dans la fa\u00e7on dont les d\u00e9veloppeurs cr\u00e9ent des interfaces pour les applications Android.","title":"2. Introduction \u00e0 Jetpack Compose"},{"location":"2.%20Android/02-intro-compose/#motivations-et-historique","text":"","title":"Motivations et historique"},{"location":"2.%20Android/02-intro-compose/#motivations","text":"Simplification du d\u00e9veloppement UI : R\u00e9duire la complexit\u00e9 et le code boilerplate associ\u00e9s \u00e0 la cr\u00e9ation d'interfaces utilisateur. Approche d\u00e9clarative : Permettre aux d\u00e9veloppeurs de d\u00e9crire ce qu'ils veulent afficher plut\u00f4t que comment le construire. Performances am\u00e9lior\u00e9es : Optimiser le rendu et les mises \u00e0 jour de l'interface utilisateur. Coh\u00e9rence avec les tendances modernes : S'aligner sur les approches modernes de d\u00e9veloppement UI comme React et SwiftUI.","title":"Motivations"},{"location":"2.%20Android/02-intro-compose/#historique","text":"2019 : Annonce initiale de Jetpack Compose lors de la Google I/O. 2020 : Sortie des premi\u00e8res versions alpha pour les d\u00e9veloppeurs. Juillet 2021 : Lancement officiel de la version 1.0 stable. Depuis, Compose continue d'\u00e9voluer avec des mises \u00e0 jour r\u00e9guli\u00e8res apportant de nouvelles fonctionnalit\u00e9s et am\u00e9liorations.","title":"Historique"},{"location":"2.%20Android/02-intro-compose/#entreprises-et-organisations-utilisant-kotlin-et-compose","text":"Google : Utilise Kotlin et Compose dans de nombreuses applications comme Google Play, Google Home, et Google Drive. Raison : Am\u00e9lioration de la productivit\u00e9 des d\u00e9veloppeurs et coh\u00e9rence avec les recommandations Android. Netflix : A adopt\u00e9 Kotlin pour son application Android. Raison : S\u00e9curit\u00e9 du type, r\u00e9duction des erreurs, et expressivit\u00e9 du code. Airbnb : Utilise Kotlin dans son application mobile. Raison : Interop\u00e9rabilit\u00e9 avec Java existant et am\u00e9lioration de la qualit\u00e9 du code. Pinterest : A migr\u00e9 vers Kotlin pour son d\u00e9veloppement Android. Raison : Syntaxe concise et fonctionnalit\u00e9s modernes du langage. Uber : Utilise Kotlin dans ses applications mobiles. Raison : Am\u00e9lioration de la productivit\u00e9 des d\u00e9veloppeurs et r\u00e9duction des bugs. Trello : A adopt\u00e9 Kotlin pour son application Android. Raison : Expressivit\u00e9 du langage et meilleures pratiques de programmation. Evernote : Utilise Kotlin dans son application Android. Raison : Code plus propre et plus facile \u00e0 maintenir. Basecamp : A migr\u00e9 son application vers Kotlin. Raison : S\u00e9curit\u00e9 accrue et syntaxe plus agr\u00e9able pour les d\u00e9veloppeurs. Corda : Plateforme blockchain d\u00e9velopp\u00e9e enti\u00e8rement en Kotlin. Raison : Robustesse du langage pour les syst\u00e8mes critiques. Coursera : Utilise Kotlin pour son application mobile. Raison : Am\u00e9lioration de la qualit\u00e9 du code et de la vitesse de d\u00e9veloppement. Ces entreprises ont choisi Kotlin et, pour certaines, Compose, principalement pour : La productivit\u00e9 accrue des d\u00e9veloppeurs La r\u00e9duction des erreurs et des crashs La modernit\u00e9 et l'expressivit\u00e9 du langage La compatibilit\u00e9 avec l'\u00e9cosyst\u00e8me Java existant L'am\u00e9lioration de la maintenabilit\u00e9 du code L'adoption croissante de Compose, bien que plus r\u00e9cente, est motiv\u00e9e par sa capacit\u00e9 \u00e0 simplifier et acc\u00e9l\u00e9rer le d\u00e9veloppement d'interfaces utilisateur modernes et performantes sur Android.","title":"Entreprises et organisations utilisant Kotlin et Compose"},{"location":"2.%20Android/02-intro-compose/#principes-de-base-dune-application-compose","text":"","title":"Principes de base d'une application Compose"},{"location":"2.%20Android/02-intro-compose/#structure-de-lapplication","text":"Composables : Fonctions annot\u00e9es avec @Composable qui d\u00e9crivent une partie de l'interface utilisateur. \u00c9tat : Donn\u00e9es qui peuvent changer au fil du temps et qui influencent l'IU (interface utilisateur). Recomposition : Processus de mise \u00e0 jour de l'IU lorsque l'\u00e9tat change.","title":"Structure de l'application"},{"location":"2.%20Android/02-intro-compose/#composants-typiques","text":"Agencement des composables ( Layout ) : Column , Row , Box pour structurer l'IU. Elements de l'IU : Text , Button , Image , etc., pour afficher du contenu. Modificateurs : Pour personnaliser l'apparence et le comportement des composables. Ascension de l'\u00e9tat ( State Hoisting ) : Technique pour g\u00e9rer et partager l'\u00e9tat entre composants. Navigation : Gestion des diff\u00e9rents \u00e9crans et du flux de l'application. Th\u00e8mes : Personnalisation coh\u00e9rente de l'apparence de l'application. Jetpack Compose offre plusieurs avantages significatifs par rapport aux m\u00e9thodes de d\u00e9veloppement Android traditionnelles bas\u00e9es sur XML et le syst\u00e8me de vues. Voici les principaux avantages de Jetpack Compose :","title":"Composants typiques"},{"location":"2.%20Android/02-intro-compose/#avantages-de-jetpack-compose","text":"","title":"Avantages de Jetpack Compose"},{"location":"2.%20Android/02-intro-compose/#1-simplicite-et-concision-du-code","text":"Moins de code boilerplate : Compose r\u00e9duit consid\u00e9rablement la quantit\u00e9 de code n\u00e9cessaire pour cr\u00e9er des interfaces utilisateur complexes. Code plus lisible : La nature d\u00e9clarative de Compose rend le code plus facile \u00e0 lire et \u00e0 comprendre. Unification du code UI : Plus besoin de jongler entre XML et Java/Kotlin, tout est dans un seul langage (Kotlin).","title":"1. Simplicit\u00e9 et concision du code"},{"location":"2.%20Android/02-intro-compose/#2-developpement-plus-rapide","text":"Pr\u00e9visualisation en temps r\u00e9el : Les d\u00e9veloppeurs peuvent voir les changements d'UI instantan\u00e9ment sans avoir \u00e0 recompiler l'application enti\u00e8re. It\u00e9rations plus rapides : La combinaison de la pr\u00e9visualisation en temps r\u00e9el et du code plus concis permet des it\u00e9rations de d\u00e9veloppement plus rapides.","title":"2. D\u00e9veloppement plus rapide"},{"location":"2.%20Android/02-intro-compose/#3-approche-declarative","text":"Description de l'\u00e9tat final : Les d\u00e9veloppeurs d\u00e9crivent ce que l'UI devrait \u00eatre, plut\u00f4t que les \u00e9tapes pour y arriver. Gestion d'\u00e9tat simplifi\u00e9e : Compose facilite la gestion de l'\u00e9tat de l'application et sa synchronisation avec l'UI.","title":"3. Approche d\u00e9clarative"},{"location":"2.%20Android/02-intro-compose/#4-flexibilite-et-reutilisabilite","text":"Composants hautement r\u00e9utilisables : Il est facile de cr\u00e9er des composants UI r\u00e9utilisables et de les partager entre diff\u00e9rentes parties de l'application. Personnalisation facile : Les composants peuvent \u00eatre facilement personnalis\u00e9s gr\u00e2ce aux modifiers et aux param\u00e8tres.","title":"4. Flexibilit\u00e9 et r\u00e9utilisabilit\u00e9"},{"location":"2.%20Android/02-intro-compose/#5-performance-amelioree","text":"Optimisations automatiques : Compose optimise automatiquement les recompositions pour minimiser les mises \u00e0 jour inutiles de l'UI. Rendu efficace : Le syst\u00e8me de rendu de Compose est con\u00e7u pour \u00eatre plus efficace que le syst\u00e8me de vues traditionnel.","title":"5. Performance am\u00e9lior\u00e9e"},{"location":"2.%20Android/02-intro-compose/#6-meilleure-interoperabilite","text":"Int\u00e9gration avec les vues existantes : Compose peut \u00eatre int\u00e9gr\u00e9 progressivement dans des applications existantes, permettant une migration en douceur. Support des biblioth\u00e8ques Android existantes : Compose fonctionne bien avec les biblioth\u00e8ques et composants Android existants.","title":"6. Meilleure interop\u00e9rabilit\u00e9"},{"location":"2.%20Android/02-intro-compose/#7-tests-simplifies","text":"Tests unitaires plus faciles : Les composables \u00e9tant des fonctions Kotlin, ils sont plus faciles \u00e0 tester unitairement. Moins de tests d'UI n\u00e9cessaires : La nature d\u00e9clarative de Compose r\u00e9duit le besoin de tests d'UI exhaustifs.","title":"7. Tests simplifi\u00e9s"},{"location":"2.%20Android/02-intro-compose/#8-coherence-avec-material-design","text":"Impl\u00e9mentation native de Material Design : Compose fournit des composants Material Design pr\u00eats \u00e0 l'emploi, facilitant la cr\u00e9ation d'interfaces conformes aux directives de Google.","title":"8. Coh\u00e9rence avec Material Design"},{"location":"2.%20Android/02-intro-compose/#9-support-multiplateforme","text":"Potentiel pour le d\u00e9veloppement multiplateforme : Bien que principalement pour Android, Compose a le potentiel d'\u00eatre utilis\u00e9 pour le d\u00e9veloppement d'applications de bureau et web (avec Compose for Desktop et Compose for Web).","title":"9. Support multiplateforme"},{"location":"2.%20Android/02-intro-compose/#10-courbe-dapprentissage-reduite","text":"Concepts unifi\u00e9s : Une fois les concepts de base ma\u00eetris\u00e9s, il est plus facile de cr\u00e9er des interfaces complexes. Documentation et ressources de qualit\u00e9 : Google fournit une documentation extensive et des codelabs pour faciliter l'apprentissage.","title":"10. Courbe d'apprentissage r\u00e9duite"},{"location":"2.%20Android/02-intro-compose/#11-meilleure-gestion-des-animations","text":"API d'animation intuitive : Compose offre des API d'animation plus simples et plus puissantes que les m\u00e9thodes traditionnelles.","title":"11. Meilleure gestion des animations"},{"location":"2.%20Android/02-intro-compose/#12-adaptation-aux-differentes-tailles-decran","text":"Responsive design facilit\u00e9 : Compose simplifie la cr\u00e9ation d'interfaces qui s'adaptent \u00e0 diff\u00e9rentes tailles d'\u00e9cran, un aspect crucial pour les applications Android modernes. En conclusion, Jetpack Compose repr\u00e9sente une \u00e9volution majeure dans le d\u00e9veloppement Android, offrant une approche plus moderne, efficace et agr\u00e9able pour cr\u00e9er des interfaces utilisateur. Bien qu'il y ait une courbe d'apprentissage initiale, les avantages \u00e0 long terme en termes de productivit\u00e9, de maintenabilit\u00e9 et de qualit\u00e9 du code sont significatifs. Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"12. Adaptation aux diff\u00e9rentes tailles d'\u00e9cran"},{"location":"2.%20Android/03-premi%C3%A8re-app/","text":"3. Premi\u00e8re application avec Jetpack Compose Voici un exemple simple d'une application \"Bonjour !\" utilisant Jetpack Compose. Je vais vous pr\u00e9senter le code, puis expliquer chaque \u00e9l\u00e9ment important \u00e9tape par \u00e9tape. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Bonjour !\", modifier = Modifier.align(Alignment.Center) ) } } } } Maintenant, expliquons les \u00e9l\u00e9ments importants de cette application \u00e9tape par \u00e9tape : Explication des \u00e9l\u00e9ments cl\u00e9s 1. Imports import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier Ces imports sont n\u00e9cessaires pour utiliser les classes et fonctions de Jetpack Compose. 2. D\u00e9finition de l'activit\u00e9 principale class MainActivity : ComponentActivity() { // ... } MainActivity h\u00e9rite de ComponentActivity , qui est la classe de base recommand\u00e9e pour les activit\u00e9s utilisant Compose. 3. M\u00e9thode onCreate override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // ... } Cette m\u00e9thode est appel\u00e9e lorsque l'activit\u00e9 est cr\u00e9\u00e9e. 4. setContent setContent { // Contenu Compose } setContent est une fonction sp\u00e9cifique \u00e0 Compose qui d\u00e9finit le contenu de l'interface utilisateur. Tout ce qui est \u00e0 l'int\u00e9rieur de cette fonction est du code Compose. 5. Box Layout Box(modifier = Modifier.fillMaxSize()) { // Contenu du Box } Box est un composant de mise en page qui permet d'empiler des \u00e9l\u00e9ments. Modifier.fillMaxSize() fait en sorte que le Box occupe tout l'espace disponible \u00e0 l'\u00e9cran. 6. Text Composable Text( text = \"Bonjour !\", modifier = Modifier.align(Alignment.Center) ) Text est un composant Compose pour afficher du texte. text = \"Bonjour !\" d\u00e9finit le texte \u00e0 afficher. Modifier.align(Alignment.Center) centre le texte dans le Box. Points cl\u00e9s \u00e0 retenir Composables : Dans Compose, l'interface utilisateur est construite \u00e0 partir de fonctions composables ( comme Text ). D\u00e9claratif : Le code d\u00e9crit ce qui doit \u00eatre affich\u00e9, pas comment le construire \u00e9tape par \u00e9tape. Modifiers : Les Modifier sont utilis\u00e9s pour personnaliser l'apparence et le comportement des composants. Hi\u00e9rarchie : Les composants sont organis\u00e9s de mani\u00e8re hi\u00e9rarchique (ici, Text est \u00e0 l'int\u00e9rieur de Box ). Pas de XML : Contrairement au d\u00e9veloppement Android traditionnel, il n'y a pas de fichiers XML pour d\u00e9finir la mise en page. Cette application simple affiche \"Bonjour !\" au centre de l'\u00e9cran. C'est un point de d\u00e9part id\u00e9al pour commencer \u00e0 explorer Jetpack Compose, car elle illustre les concepts de base sans trop de complexit\u00e9. D\u00e9finition de fonctions composables Excellent ! Voici l'exemple modifi\u00e9 avec une fonction composable d\u00e9finie pour la Box , et son appel dans onCreate . Je vais ensuite expliquer les modifications. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.runtime.Composable import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.tooling.preview.Preview class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { BonjourScreen() } } } @Composable fun BonjourScreen() { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Hello World!\", modifier = Modifier.align(Alignment.Center) ) } } @Preview(showBackground = true) @Composable fun BonjourPreview() { BonjourScreen() } Expliquons maintenant les modifications et leurs implications : Explications des modifications 1. Nouvelle fonction composable BonjourScreen @Composable fun BonjourScreen() { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Hello World!\", modifier = Modifier.align(Alignment.Center) ) } } Cette nouvelle fonction est annot\u00e9e avec @Composable , indiquant qu'il s'agit d'une fonction composable Jetpack Compose. Elle encapsule la logique d'affichage qui \u00e9tait pr\u00e9c\u00e9demment directement dans setContent . Cette approche am\u00e9liore la r\u00e9utilisabilit\u00e9 et la lisibilit\u00e9 du code. 2. Modification de onCreate override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { BonjourScreen() } } Au lieu de d\u00e9finir directement le contenu dans setContent , nous appelons maintenant notre fonction composable BonjourScreen . Cela rend le code de onCreate plus concis et plus clair. 3. Ajout d'une fonction de pr\u00e9visualisation @Preview(showBackground = true) @Composable fun BonjourPreview() { BonjourScreen() } Cette nouvelle fonction est annot\u00e9e avec @Preview , ce qui permet de pr\u00e9visualiser le composant dans Android Studio sans avoir \u00e0 ex\u00e9cuter l'application. showBackground = true ajoute un arri\u00e8re-plan \u00e0 la pr\u00e9visualisation pour une meilleure visibilit\u00e9. Elle appelle BonjourScreen() , permettant de voir exactement ce qui sera affich\u00e9 dans l'application. Implications et avantages de ces modifications S\u00e9paration des pr\u00e9occupations : La logique d'affichage est maintenant s\u00e9par\u00e9e de la logique de l'activit\u00e9, ce qui est une bonne pratique de programmation. R\u00e9utilisabilit\u00e9 : BonjourScreen peut \u00eatre facilement r\u00e9utilis\u00e9 ailleurs dans l'application si n\u00e9cessaire. Testabilit\u00e9 : Il est plus facile de tester BonjourScreen de mani\u00e8re isol\u00e9e. Pr\u00e9visualisation : L'ajout de la fonction de pr\u00e9visualisation permet aux d\u00e9veloppeurs de voir rapidement les changements d'interface sans avoir \u00e0 compiler et ex\u00e9cuter l'application enti\u00e8re. Modularit\u00e9 : Cette structure facilite l'ajout futur de fonctionnalit\u00e9s ou de modifications \u00e0 l'interface utilisateur. Lisibilit\u00e9 : Le code est plus clair et plus facile \u00e0 comprendre, chaque partie ayant un r\u00f4le bien d\u00e9fini. \u00c9volutivit\u00e9 : \u00c0 mesure que l'application se d\u00e9veloppe, cette structure permet d'ajouter facilement de nouveaux composants et \u00e9crans. Cette approche est typique du d\u00e9veloppement avec Jetpack Compose, o\u00f9 l'interface utilisateur est construite \u00e0 partir de composants r\u00e9utilisables et pr\u00e9visualisables. C'est une base solide pour d\u00e9velopper des applications plus complexes tout en maintenant un code propre et organis\u00e9. Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"3. Premi\u00e8re application avec Jetpack Compose"},{"location":"2.%20Android/03-premi%C3%A8re-app/#3-premiere-application-avec-jetpack-compose","text":"Voici un exemple simple d'une application \"Bonjour !\" utilisant Jetpack Compose. Je vais vous pr\u00e9senter le code, puis expliquer chaque \u00e9l\u00e9ment important \u00e9tape par \u00e9tape. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Bonjour !\", modifier = Modifier.align(Alignment.Center) ) } } } } Maintenant, expliquons les \u00e9l\u00e9ments importants de cette application \u00e9tape par \u00e9tape :","title":"3. Premi\u00e8re application avec Jetpack Compose"},{"location":"2.%20Android/03-premi%C3%A8re-app/#explication-des-elements-cles","text":"","title":"Explication des \u00e9l\u00e9ments cl\u00e9s"},{"location":"2.%20Android/03-premi%C3%A8re-app/#1-imports","text":"import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier Ces imports sont n\u00e9cessaires pour utiliser les classes et fonctions de Jetpack Compose.","title":"1. Imports"},{"location":"2.%20Android/03-premi%C3%A8re-app/#2-definition-de-lactivite-principale","text":"class MainActivity : ComponentActivity() { // ... } MainActivity h\u00e9rite de ComponentActivity , qui est la classe de base recommand\u00e9e pour les activit\u00e9s utilisant Compose.","title":"2. D\u00e9finition de l'activit\u00e9 principale"},{"location":"2.%20Android/03-premi%C3%A8re-app/#3-methode-oncreate","text":"override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // ... } Cette m\u00e9thode est appel\u00e9e lorsque l'activit\u00e9 est cr\u00e9\u00e9e.","title":"3. M\u00e9thode onCreate"},{"location":"2.%20Android/03-premi%C3%A8re-app/#4-setcontent","text":"setContent { // Contenu Compose } setContent est une fonction sp\u00e9cifique \u00e0 Compose qui d\u00e9finit le contenu de l'interface utilisateur. Tout ce qui est \u00e0 l'int\u00e9rieur de cette fonction est du code Compose.","title":"4. setContent"},{"location":"2.%20Android/03-premi%C3%A8re-app/#5-box-layout","text":"Box(modifier = Modifier.fillMaxSize()) { // Contenu du Box } Box est un composant de mise en page qui permet d'empiler des \u00e9l\u00e9ments. Modifier.fillMaxSize() fait en sorte que le Box occupe tout l'espace disponible \u00e0 l'\u00e9cran.","title":"5. Box Layout"},{"location":"2.%20Android/03-premi%C3%A8re-app/#6-text-composable","text":"Text( text = \"Bonjour !\", modifier = Modifier.align(Alignment.Center) ) Text est un composant Compose pour afficher du texte. text = \"Bonjour !\" d\u00e9finit le texte \u00e0 afficher. Modifier.align(Alignment.Center) centre le texte dans le Box.","title":"6. Text Composable"},{"location":"2.%20Android/03-premi%C3%A8re-app/#points-cles-a-retenir","text":"Composables : Dans Compose, l'interface utilisateur est construite \u00e0 partir de fonctions composables ( comme Text ). D\u00e9claratif : Le code d\u00e9crit ce qui doit \u00eatre affich\u00e9, pas comment le construire \u00e9tape par \u00e9tape. Modifiers : Les Modifier sont utilis\u00e9s pour personnaliser l'apparence et le comportement des composants. Hi\u00e9rarchie : Les composants sont organis\u00e9s de mani\u00e8re hi\u00e9rarchique (ici, Text est \u00e0 l'int\u00e9rieur de Box ). Pas de XML : Contrairement au d\u00e9veloppement Android traditionnel, il n'y a pas de fichiers XML pour d\u00e9finir la mise en page. Cette application simple affiche \"Bonjour !\" au centre de l'\u00e9cran. C'est un point de d\u00e9part id\u00e9al pour commencer \u00e0 explorer Jetpack Compose, car elle illustre les concepts de base sans trop de complexit\u00e9.","title":"Points cl\u00e9s \u00e0 retenir"},{"location":"2.%20Android/03-premi%C3%A8re-app/#definition-de-fonctions-composables","text":"Excellent ! Voici l'exemple modifi\u00e9 avec une fonction composable d\u00e9finie pour la Box , et son appel dans onCreate . Je vais ensuite expliquer les modifications. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.runtime.Composable import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.tooling.preview.Preview class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { BonjourScreen() } } } @Composable fun BonjourScreen() { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Hello World!\", modifier = Modifier.align(Alignment.Center) ) } } @Preview(showBackground = true) @Composable fun BonjourPreview() { BonjourScreen() } Expliquons maintenant les modifications et leurs implications :","title":"D\u00e9finition de fonctions composables"},{"location":"2.%20Android/03-premi%C3%A8re-app/#explications-des-modifications","text":"","title":"Explications des modifications"},{"location":"2.%20Android/03-premi%C3%A8re-app/#1-nouvelle-fonction-composable-bonjourscreen","text":"@Composable fun BonjourScreen() { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Hello World!\", modifier = Modifier.align(Alignment.Center) ) } } Cette nouvelle fonction est annot\u00e9e avec @Composable , indiquant qu'il s'agit d'une fonction composable Jetpack Compose. Elle encapsule la logique d'affichage qui \u00e9tait pr\u00e9c\u00e9demment directement dans setContent . Cette approche am\u00e9liore la r\u00e9utilisabilit\u00e9 et la lisibilit\u00e9 du code.","title":"1. Nouvelle fonction composable BonjourScreen"},{"location":"2.%20Android/03-premi%C3%A8re-app/#2-modification-de-oncreate","text":"override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { BonjourScreen() } } Au lieu de d\u00e9finir directement le contenu dans setContent , nous appelons maintenant notre fonction composable BonjourScreen . Cela rend le code de onCreate plus concis et plus clair.","title":"2. Modification de onCreate"},{"location":"2.%20Android/03-premi%C3%A8re-app/#3-ajout-dune-fonction-de-previsualisation","text":"@Preview(showBackground = true) @Composable fun BonjourPreview() { BonjourScreen() } Cette nouvelle fonction est annot\u00e9e avec @Preview , ce qui permet de pr\u00e9visualiser le composant dans Android Studio sans avoir \u00e0 ex\u00e9cuter l'application. showBackground = true ajoute un arri\u00e8re-plan \u00e0 la pr\u00e9visualisation pour une meilleure visibilit\u00e9. Elle appelle BonjourScreen() , permettant de voir exactement ce qui sera affich\u00e9 dans l'application.","title":"3. Ajout d'une fonction de pr\u00e9visualisation"},{"location":"2.%20Android/03-premi%C3%A8re-app/#implications-et-avantages-de-ces-modifications","text":"S\u00e9paration des pr\u00e9occupations : La logique d'affichage est maintenant s\u00e9par\u00e9e de la logique de l'activit\u00e9, ce qui est une bonne pratique de programmation. R\u00e9utilisabilit\u00e9 : BonjourScreen peut \u00eatre facilement r\u00e9utilis\u00e9 ailleurs dans l'application si n\u00e9cessaire. Testabilit\u00e9 : Il est plus facile de tester BonjourScreen de mani\u00e8re isol\u00e9e. Pr\u00e9visualisation : L'ajout de la fonction de pr\u00e9visualisation permet aux d\u00e9veloppeurs de voir rapidement les changements d'interface sans avoir \u00e0 compiler et ex\u00e9cuter l'application enti\u00e8re. Modularit\u00e9 : Cette structure facilite l'ajout futur de fonctionnalit\u00e9s ou de modifications \u00e0 l'interface utilisateur. Lisibilit\u00e9 : Le code est plus clair et plus facile \u00e0 comprendre, chaque partie ayant un r\u00f4le bien d\u00e9fini. \u00c9volutivit\u00e9 : \u00c0 mesure que l'application se d\u00e9veloppe, cette structure permet d'ajouter facilement de nouveaux composants et \u00e9crans. Cette approche est typique du d\u00e9veloppement avec Jetpack Compose, o\u00f9 l'interface utilisateur est construite \u00e0 partir de composants r\u00e9utilisables et pr\u00e9visualisables. C'est une base solide pour d\u00e9velopper des applications plus complexes tout en maintenant un code propre et organis\u00e9. Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"Implications et avantages de ces modifications"},{"location":"2.%20Android/04-hockey-v1/","text":"4. Application Hockey Version 1 Ce code d\u00e9finit une structure pour repr\u00e9senter des joueurs de hockey et cr\u00e9e des composants d'interface utilisateur en utilisant Jetpack Compose pour afficher ces joueurs dans une liste. Il comprend une classe de donn\u00e9es pour les joueurs, une fonction pour g\u00e9n\u00e9rer des exemples de joueurs, et deux fonctions composables principales : une pour afficher une carte de joueur individuelle et une autre pour afficher une liste de ces cartes. Explication d\u00e9taill\u00e9e des fonctions composables PlayerCard @Composable fun PlayerCard(player: Player, modifier: Modifier = Modifier) { // ... } Cette fonction composable cr\u00e9e une carte pour afficher les informations d'un joueur individuel. Elle prend en param\u00e8tre un objet Player et un Modifier optionnel. Utilise un composant Card pour cr\u00e9er une carte avec des coins arrondis et une bordure. \u00c0 l'int\u00e9rieur de la carte, elle organise le contenu dans une Column (colonne verticale). La premi\u00e8re Row (ligne horizontale) contient l'image du joueur. La deuxi\u00e8me Row affiche le num\u00e9ro et le nom du joueur. Composants utilis\u00e9s : Card : Cr\u00e9e une surface \u00e9lev\u00e9e avec une ombre et un contenu. Column : Organise les \u00e9l\u00e9ments verticalement. Row : Organise les \u00e9l\u00e9ments horizontalement. Image : Affiche l'image du joueur. Text : Affiche le texte (num\u00e9ro et nom du joueur). Spacer : Cr\u00e9e un espace entre les \u00e9l\u00e9ments. Modificateurs utilis\u00e9s : fillMaxWidth() : Remplit toute la largeur disponible. padding() : Ajoute de l'espace autour des \u00e9l\u00e9ments. background() : D\u00e9finit la couleur de fond. width() : D\u00e9finit une largeur sp\u00e9cifique. PlayerList @Composable fun PlayerList(modifier: Modifier = Modifier) { LazyColumn(modifier = modifier) { items(getSamplePlayers()) { PlayerCard(player = it) } } } Cette fonction composable cr\u00e9e une liste d\u00e9roulante de cartes de joueurs. Elle utilise LazyColumn , qui est optimis\u00e9e pour afficher de longues listes d'\u00e9l\u00e9ments. La fonction items() est utilis\u00e9e pour g\u00e9n\u00e9rer dynamiquement les \u00e9l\u00e9ments de la liste \u00e0 partir de la liste de joueurs retourn\u00e9e par getSamplePlayers() . Pour chaque joueur dans la liste, elle cr\u00e9e une PlayerCard . Composant principal : LazyColumn : Un conteneur de d\u00e9filement vertical qui charge et affiche uniquement les \u00e9l\u00e9ments visibles \u00e0 l'\u00e9cran, ce qui le rend efficace pour les longues listes. Ces deux fonctions composables travaillent ensemble pour cr\u00e9er une interface utilisateur interactive et efficace pour afficher une liste de joueurs de hockey. PlayerCard g\u00e8re l'affichage des d\u00e9tails individuels des joueurs, tandis que PlayerList organise ces cartes dans une liste d\u00e9roulante. Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"4. Application Hockey Version 1"},{"location":"2.%20Android/04-hockey-v1/#4-application-hockey-version-1","text":"Ce code d\u00e9finit une structure pour repr\u00e9senter des joueurs de hockey et cr\u00e9e des composants d'interface utilisateur en utilisant Jetpack Compose pour afficher ces joueurs dans une liste. Il comprend une classe de donn\u00e9es pour les joueurs, une fonction pour g\u00e9n\u00e9rer des exemples de joueurs, et deux fonctions composables principales : une pour afficher une carte de joueur individuelle et une autre pour afficher une liste de ces cartes.","title":"4. Application Hockey Version 1"},{"location":"2.%20Android/04-hockey-v1/#explication-detaillee-des-fonctions-composables","text":"","title":"Explication d\u00e9taill\u00e9e des fonctions composables"},{"location":"2.%20Android/04-hockey-v1/#playercard","text":"@Composable fun PlayerCard(player: Player, modifier: Modifier = Modifier) { // ... } Cette fonction composable cr\u00e9e une carte pour afficher les informations d'un joueur individuel. Elle prend en param\u00e8tre un objet Player et un Modifier optionnel. Utilise un composant Card pour cr\u00e9er une carte avec des coins arrondis et une bordure. \u00c0 l'int\u00e9rieur de la carte, elle organise le contenu dans une Column (colonne verticale). La premi\u00e8re Row (ligne horizontale) contient l'image du joueur. La deuxi\u00e8me Row affiche le num\u00e9ro et le nom du joueur. Composants utilis\u00e9s : Card : Cr\u00e9e une surface \u00e9lev\u00e9e avec une ombre et un contenu. Column : Organise les \u00e9l\u00e9ments verticalement. Row : Organise les \u00e9l\u00e9ments horizontalement. Image : Affiche l'image du joueur. Text : Affiche le texte (num\u00e9ro et nom du joueur). Spacer : Cr\u00e9e un espace entre les \u00e9l\u00e9ments. Modificateurs utilis\u00e9s : fillMaxWidth() : Remplit toute la largeur disponible. padding() : Ajoute de l'espace autour des \u00e9l\u00e9ments. background() : D\u00e9finit la couleur de fond. width() : D\u00e9finit une largeur sp\u00e9cifique.","title":"PlayerCard"},{"location":"2.%20Android/04-hockey-v1/#playerlist","text":"@Composable fun PlayerList(modifier: Modifier = Modifier) { LazyColumn(modifier = modifier) { items(getSamplePlayers()) { PlayerCard(player = it) } } } Cette fonction composable cr\u00e9e une liste d\u00e9roulante de cartes de joueurs. Elle utilise LazyColumn , qui est optimis\u00e9e pour afficher de longues listes d'\u00e9l\u00e9ments. La fonction items() est utilis\u00e9e pour g\u00e9n\u00e9rer dynamiquement les \u00e9l\u00e9ments de la liste \u00e0 partir de la liste de joueurs retourn\u00e9e par getSamplePlayers() . Pour chaque joueur dans la liste, elle cr\u00e9e une PlayerCard . Composant principal : LazyColumn : Un conteneur de d\u00e9filement vertical qui charge et affiche uniquement les \u00e9l\u00e9ments visibles \u00e0 l'\u00e9cran, ce qui le rend efficace pour les longues listes. Ces deux fonctions composables travaillent ensemble pour cr\u00e9er une interface utilisateur interactive et efficace pour afficher une liste de joueurs de hockey. PlayerCard g\u00e8re l'affichage des d\u00e9tails individuels des joueurs, tandis que PlayerList organise ces cartes dans une liste d\u00e9roulante. Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"PlayerList"},{"location":"2.%20Android/05-etats-evenements/","text":"5. Gestion des \u00e9tats et des \u00e9v\u00e9nements Exemple : ExemplesEntrees Exemple sur GitHub Fonction TextLengthCounter La fonction TextLengthCounter est un composable Jetpack Compose qui cr\u00e9e une interface utilisateur permettant \u00e0 l'utilisateur de saisir du texte et d'afficher sa longueur en caract\u00e8res. Elle utilise des \u00e9tats pour g\u00e9rer le texte saisi et sa longueur, et met \u00e0 jour dynamiquement l'affichage. Voici une description d\u00e9taill\u00e9e de la fonction : D\u00e9claration de la fonction : @Composable fun TextLengthCounter(modifier: Modifier = Modifier) C'est une fonction composable qui peut recevoir un Modifier en param\u00e8tre. Gestion de l'\u00e9tat : var text by remember { mutableStateOf(\"\") } var length by remember { mutableIntStateOf(0) } Deux variables d'\u00e9tat sont cr\u00e9\u00e9es : text pour stocker le texte saisi et length pour la longueur du texte. remember est utilis\u00e9 pour conserver ces \u00e9tats entre les recompositions. Structure de l'interface : Column( modifier = Modifier .padding(16.dp) .fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally ) { // Contenu de la colonne } Un Column est utilis\u00e9 pour organiser verticalement les \u00e9l\u00e9ments de l'interface. Un padding de 16dp est appliqu\u00e9, et la colonne occupe toute la largeur disponible. Les \u00e9l\u00e9ments sont centr\u00e9s horizontalement. Champ de saisie : TextField( value = text, onValueChange = { text = it length = text.length }, label = { Text(\"Entrez du texte\") }, modifier = Modifier.fillMaxWidth() ) Un TextField permet \u00e0 l'utilisateur de saisir du texte. La valeur du champ est li\u00e9e \u00e0 l'\u00e9tat text . \u00c0 chaque changement, text est mis \u00e0 jour et length est recalcul\u00e9. Espacement : Spacer(modifier = Modifier.height(16.dp)) Des Spacer sont utilis\u00e9s pour ajouter de l'espace vertical entre les \u00e9l\u00e9ments. Bouton de calcul : Button( onClick = { length = text.length } ) { Text(\"Calculer la longueur\") } Un bouton permet de recalculer manuellement la longueur du texte. Affichage de la longueur : Text(\"Longueur du texte : $length caract\u00e8res\") Un Text affiche la longueur actuelle du texte. Cette fonction illustre plusieurs concepts importants de Jetpack Compose, notamment la gestion de l'\u00e9tat, la r\u00e9activit\u00e9 des composants, et l'organisation de l'interface utilisateur. Elle montre comment cr\u00e9er une interface interactive simple, mais fonctionnelle. Gestion de l'\u00e9tat avec remember et mutableStateOf Dans Jetpack Compose, l'\u00e9tat est un concept crucial. Il repr\u00e9sente toute donn\u00e9e qui peut changer au fil du temps et qui, lorsqu'elle change, peut d\u00e9clencher une recomposition de l'interface utilisateur. var text by remember { mutableStateOf(\"\") } var length by remember { mutableIntStateOf(0) } R\u00f4le de remember remember est une fonction qui permet de conserver un objet entre les recompositions. Sans remember , chaque recomposition cr\u00e9erait un nouvel objet, perdant ainsi l'\u00e9tat pr\u00e9c\u00e9dent. remember \"m\u00e9morise\" l'objet initial et le r\u00e9utilise lors des recompositions suivantes. Fonction de mutableStateOf mutableStateOf cr\u00e9e un objet MutableState<T> qui encapsule une valeur mutable. Lorsque cette valeur change, Compose est notifi\u00e9 et peut d\u00e9clencher une recomposition si n\u00e9cessaire. mutableIntStateOf est une version sp\u00e9cialis\u00e9e pour les entiers, optimis\u00e9e pour les performances. D\u00e9l\u00e9gation avec by Le mot-cl\u00e9 by est utilis\u00e9 pour la d\u00e9l\u00e9gation de propri\u00e9t\u00e9 en Kotlin. Il permet d'utiliser directement text et length comme s'ils \u00e9taient des variables normales, tout en b\u00e9n\u00e9ficiant de la r\u00e9activit\u00e9 de MutableState . Lambdas et mise \u00e0 jour de l'\u00e9tat Les lambdas sont utilis\u00e9es pour d\u00e9finir des comportements en r\u00e9ponse \u00e0 des \u00e9v\u00e9nements, comme les changements de valeur ou les clics. Dans le TextField onValueChange = { text = it length = text.length } Cette lambda est appel\u00e9e chaque fois que le contenu du TextField change. it repr\u00e9sente la nouvelle valeur du champ texte. La lambda met \u00e0 jour text avec la nouvelle valeur et recalcule imm\u00e9diatement length . Ces mises \u00e0 jour d\u00e9clenchent une recomposition, mettant \u00e0 jour l'interface utilisateur. Dans le Button onClick = { length = text.length } Cette lambda est plus simple, elle est appel\u00e9e lors d'un clic sur le bouton. Elle recalcule length bas\u00e9 sur la valeur actuelle de text . Bien que cela semble redondant ici (car length est d\u00e9j\u00e0 \u00e0 jour), cela pourrait \u00eatre utile dans des sc\u00e9narios plus complexes. R\u00e9activit\u00e9 et flux de donn\u00e9es Lorsque l'utilisateur tape du texte, onValueChange est appel\u00e9. text est mis \u00e0 jour, ce qui notifie Compose d'un changement d'\u00e9tat. length est \u00e9galement mis \u00e0 jour imm\u00e9diatement. Compose d\u00e9tecte ces changements d'\u00e9tat et d\u00e9clenche une recomposition. Lors de la recomposition, le TextField affiche le nouveau texte, et le Text en bas affiche la nouvelle longueur. Cette approche assure que l'interface utilisateur reste toujours synchronis\u00e9e avec l'\u00e9tat interne de l'application, offrant une exp\u00e9rience r\u00e9active et coh\u00e9rente \u00e0 l'utilisateur. En r\u00e9sum\u00e9, cet exemple illustre comment Jetpack Compose utilise la gestion de l'\u00e9tat, les lambdas, et la recomposition pour cr\u00e9er une interface utilisateur dynamique et r\u00e9active. La combinaison de remember et mutableStateOf permet de maintenir et de g\u00e9rer efficacement l'\u00e9tat, tandis que les lambdas fournissent un moyen \u00e9l\u00e9gant de r\u00e9agir aux interactions de l'utilisateur et de mettre \u00e0 jour l'\u00e9tat en cons\u00e9quence. Fonction FruitSelector La fonction FruitSelector est un composable Jetpack Compose qui cr\u00e9e un s\u00e9lecteur de fruits sous forme de menu d\u00e9roulant. Elle permet \u00e0 l'utilisateur de choisir un fruit parmi une liste pr\u00e9d\u00e9finie et affiche le fruit s\u00e9lectionn\u00e9. @OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector(modifier: Modifier = Modifier) { D\u00e9claration de la fonction - `@OptIn(ExperimentalMaterial3Api::class)` indique l'utilisation d'API exp\u00e9rimentales de Material 3. - C'est une fonction composable qui accepte un `modifier` optionnel. val fruits = listOf(\"Pomme\", \"Banane\", \"Orange\", \"Fraise\", \"Kiwi\") var expanded by remember { mutableStateOf(false) } var selectedFruit by rememberSaveable { mutableStateOf(\"\") } Initialisation des \u00e9tats fruits est une liste statique de fruits. expanded est un \u00e9tat bool\u00e9en pour contr\u00f4ler l'ouverture/fermeture du menu d\u00e9roulant. selectedFruit est un \u00e9tat pour stocker le fruit s\u00e9lectionn\u00e9. rememberSaveable est utilis\u00e9 pour conserver la s\u00e9lection m\u00eame apr\u00e8s une reconfiguration (comme une rotation d'\u00e9cran). Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) { Structure de l'interface Un Column contient tous les \u00e9l\u00e9ments avec un padding de 16dp. ExposedDropdownMenuBox est le conteneur principal du menu d\u00e9roulant. TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choisissez un fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults .TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() ) Champ de texte du s\u00e9lecteur Un TextField affiche le fruit s\u00e9lectionn\u00e9. Il est en lecture seule ( readOnly = true ). Une ic\u00f4ne de menu d\u00e9roulant est ajout\u00e9e \u00e0 droite. .menuAnchor() lie ce champ au menu d\u00e9roulant. ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { selectedFruit = fruit expanded = false } ) } } Menu d\u00e9roulant ExposedDropdownMenu contient la liste des fruits. Chaque fruit est repr\u00e9sent\u00e9 par un DropdownMenuItem . Lors du clic sur un fruit, selectedFruit est mis \u00e0 jour et le menu se ferme. Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Fruit s\u00e9lectionn\u00e9 : $selectedFruit\") } } } Affichage de la s\u00e9lection Un espace vertical est ajout\u00e9. Si un fruit est s\u00e9lectionn\u00e9, il est affich\u00e9 en dessous du menu. Fonctionnement global L'utilisateur voit un champ de texte avec un label \"Choisissez un fruit\". En cliquant sur le champ, un menu d\u00e9roulant s'ouvre avec la liste des fruits. La s\u00e9lection d'un fruit met \u00e0 jour l'\u00e9tat selectedFruit et ferme le menu. Le fruit s\u00e9lectionn\u00e9 est affich\u00e9 dans le champ de texte et en dessous. Cette fonction illustre plusieurs concepts avanc\u00e9s de Jetpack Compose : Utilisation de composants Material 3 pour cr\u00e9er un menu d\u00e9roulant interactif. Gestion d'\u00e9tats avec remember et rememberSaveable . Cr\u00e9ation d'une interface utilisateur dynamique et r\u00e9active. Utilisation de lambdas pour g\u00e9rer les interactions utilisateur. Conditionnement de l'affichage bas\u00e9 sur l'\u00e9tat ( if (selectedFruit.isNotEmpty()) ). Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"5. Gestion des \u00e9tats et des \u00e9v\u00e9nements"},{"location":"2.%20Android/05-etats-evenements/#5-gestion-des-etats-et-des-evenements","text":"","title":"5. Gestion des \u00e9tats et des \u00e9v\u00e9nements"},{"location":"2.%20Android/05-etats-evenements/#exemple-exemplesentrees","text":"Exemple sur GitHub","title":"Exemple : ExemplesEntrees"},{"location":"2.%20Android/05-etats-evenements/#fonction-textlengthcounter","text":"La fonction TextLengthCounter est un composable Jetpack Compose qui cr\u00e9e une interface utilisateur permettant \u00e0 l'utilisateur de saisir du texte et d'afficher sa longueur en caract\u00e8res. Elle utilise des \u00e9tats pour g\u00e9rer le texte saisi et sa longueur, et met \u00e0 jour dynamiquement l'affichage. Voici une description d\u00e9taill\u00e9e de la fonction :","title":"Fonction TextLengthCounter"},{"location":"2.%20Android/05-etats-evenements/#declaration-de-la-fonction","text":"@Composable fun TextLengthCounter(modifier: Modifier = Modifier) C'est une fonction composable qui peut recevoir un Modifier en param\u00e8tre.","title":"D\u00e9claration de la fonction :"},{"location":"2.%20Android/05-etats-evenements/#gestion-de-letat","text":"var text by remember { mutableStateOf(\"\") } var length by remember { mutableIntStateOf(0) } Deux variables d'\u00e9tat sont cr\u00e9\u00e9es : text pour stocker le texte saisi et length pour la longueur du texte. remember est utilis\u00e9 pour conserver ces \u00e9tats entre les recompositions.","title":"Gestion de l'\u00e9tat :"},{"location":"2.%20Android/05-etats-evenements/#structure-de-linterface","text":"Column( modifier = Modifier .padding(16.dp) .fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally ) { // Contenu de la colonne } Un Column est utilis\u00e9 pour organiser verticalement les \u00e9l\u00e9ments de l'interface. Un padding de 16dp est appliqu\u00e9, et la colonne occupe toute la largeur disponible. Les \u00e9l\u00e9ments sont centr\u00e9s horizontalement.","title":"Structure de l'interface :"},{"location":"2.%20Android/05-etats-evenements/#champ-de-saisie","text":"TextField( value = text, onValueChange = { text = it length = text.length }, label = { Text(\"Entrez du texte\") }, modifier = Modifier.fillMaxWidth() ) Un TextField permet \u00e0 l'utilisateur de saisir du texte. La valeur du champ est li\u00e9e \u00e0 l'\u00e9tat text . \u00c0 chaque changement, text est mis \u00e0 jour et length est recalcul\u00e9.","title":"Champ de saisie :"},{"location":"2.%20Android/05-etats-evenements/#espacement","text":"Spacer(modifier = Modifier.height(16.dp)) Des Spacer sont utilis\u00e9s pour ajouter de l'espace vertical entre les \u00e9l\u00e9ments.","title":"Espacement :"},{"location":"2.%20Android/05-etats-evenements/#bouton-de-calcul","text":"Button( onClick = { length = text.length } ) { Text(\"Calculer la longueur\") } Un bouton permet de recalculer manuellement la longueur du texte.","title":"Bouton de calcul :"},{"location":"2.%20Android/05-etats-evenements/#affichage-de-la-longueur","text":"Text(\"Longueur du texte : $length caract\u00e8res\") Un Text affiche la longueur actuelle du texte. Cette fonction illustre plusieurs concepts importants de Jetpack Compose, notamment la gestion de l'\u00e9tat, la r\u00e9activit\u00e9 des composants, et l'organisation de l'interface utilisateur. Elle montre comment cr\u00e9er une interface interactive simple, mais fonctionnelle.","title":"Affichage de la longueur :"},{"location":"2.%20Android/05-etats-evenements/#gestion-de-letat-avec-remember-et-mutablestateof","text":"Dans Jetpack Compose, l'\u00e9tat est un concept crucial. Il repr\u00e9sente toute donn\u00e9e qui peut changer au fil du temps et qui, lorsqu'elle change, peut d\u00e9clencher une recomposition de l'interface utilisateur. var text by remember { mutableStateOf(\"\") } var length by remember { mutableIntStateOf(0) }","title":"Gestion de l'\u00e9tat avec remember et mutableStateOf"},{"location":"2.%20Android/05-etats-evenements/#role-de-remember","text":"remember est une fonction qui permet de conserver un objet entre les recompositions. Sans remember , chaque recomposition cr\u00e9erait un nouvel objet, perdant ainsi l'\u00e9tat pr\u00e9c\u00e9dent. remember \"m\u00e9morise\" l'objet initial et le r\u00e9utilise lors des recompositions suivantes.","title":"R\u00f4le de remember"},{"location":"2.%20Android/05-etats-evenements/#fonction-de-mutablestateof","text":"mutableStateOf cr\u00e9e un objet MutableState<T> qui encapsule une valeur mutable. Lorsque cette valeur change, Compose est notifi\u00e9 et peut d\u00e9clencher une recomposition si n\u00e9cessaire. mutableIntStateOf est une version sp\u00e9cialis\u00e9e pour les entiers, optimis\u00e9e pour les performances.","title":"Fonction de mutableStateOf"},{"location":"2.%20Android/05-etats-evenements/#delegation-avec-by","text":"Le mot-cl\u00e9 by est utilis\u00e9 pour la d\u00e9l\u00e9gation de propri\u00e9t\u00e9 en Kotlin. Il permet d'utiliser directement text et length comme s'ils \u00e9taient des variables normales, tout en b\u00e9n\u00e9ficiant de la r\u00e9activit\u00e9 de MutableState .","title":"D\u00e9l\u00e9gation avec by"},{"location":"2.%20Android/05-etats-evenements/#lambdas-et-mise-a-jour-de-letat","text":"Les lambdas sont utilis\u00e9es pour d\u00e9finir des comportements en r\u00e9ponse \u00e0 des \u00e9v\u00e9nements, comme les changements de valeur ou les clics.","title":"Lambdas et mise \u00e0 jour de l'\u00e9tat"},{"location":"2.%20Android/05-etats-evenements/#dans-le-textfield","text":"onValueChange = { text = it length = text.length } Cette lambda est appel\u00e9e chaque fois que le contenu du TextField change. it repr\u00e9sente la nouvelle valeur du champ texte. La lambda met \u00e0 jour text avec la nouvelle valeur et recalcule imm\u00e9diatement length . Ces mises \u00e0 jour d\u00e9clenchent une recomposition, mettant \u00e0 jour l'interface utilisateur.","title":"Dans le TextField"},{"location":"2.%20Android/05-etats-evenements/#dans-le-button","text":"onClick = { length = text.length } Cette lambda est plus simple, elle est appel\u00e9e lors d'un clic sur le bouton. Elle recalcule length bas\u00e9 sur la valeur actuelle de text . Bien que cela semble redondant ici (car length est d\u00e9j\u00e0 \u00e0 jour), cela pourrait \u00eatre utile dans des sc\u00e9narios plus complexes.","title":"Dans le Button"},{"location":"2.%20Android/05-etats-evenements/#reactivite-et-flux-de-donnees","text":"Lorsque l'utilisateur tape du texte, onValueChange est appel\u00e9. text est mis \u00e0 jour, ce qui notifie Compose d'un changement d'\u00e9tat. length est \u00e9galement mis \u00e0 jour imm\u00e9diatement. Compose d\u00e9tecte ces changements d'\u00e9tat et d\u00e9clenche une recomposition. Lors de la recomposition, le TextField affiche le nouveau texte, et le Text en bas affiche la nouvelle longueur. Cette approche assure que l'interface utilisateur reste toujours synchronis\u00e9e avec l'\u00e9tat interne de l'application, offrant une exp\u00e9rience r\u00e9active et coh\u00e9rente \u00e0 l'utilisateur. En r\u00e9sum\u00e9, cet exemple illustre comment Jetpack Compose utilise la gestion de l'\u00e9tat, les lambdas, et la recomposition pour cr\u00e9er une interface utilisateur dynamique et r\u00e9active. La combinaison de remember et mutableStateOf permet de maintenir et de g\u00e9rer efficacement l'\u00e9tat, tandis que les lambdas fournissent un moyen \u00e9l\u00e9gant de r\u00e9agir aux interactions de l'utilisateur et de mettre \u00e0 jour l'\u00e9tat en cons\u00e9quence.","title":"R\u00e9activit\u00e9 et flux de donn\u00e9es"},{"location":"2.%20Android/05-etats-evenements/#fonction-fruitselector","text":"La fonction FruitSelector est un composable Jetpack Compose qui cr\u00e9e un s\u00e9lecteur de fruits sous forme de menu d\u00e9roulant. Elle permet \u00e0 l'utilisateur de choisir un fruit parmi une liste pr\u00e9d\u00e9finie et affiche le fruit s\u00e9lectionn\u00e9. @OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector(modifier: Modifier = Modifier) {","title":"Fonction FruitSelector"},{"location":"2.%20Android/05-etats-evenements/#declaration-de-la-fonction_1","text":"- `@OptIn(ExperimentalMaterial3Api::class)` indique l'utilisation d'API exp\u00e9rimentales de Material 3. - C'est une fonction composable qui accepte un `modifier` optionnel. val fruits = listOf(\"Pomme\", \"Banane\", \"Orange\", \"Fraise\", \"Kiwi\") var expanded by remember { mutableStateOf(false) } var selectedFruit by rememberSaveable { mutableStateOf(\"\") }","title":"D\u00e9claration de la fonction"},{"location":"2.%20Android/05-etats-evenements/#initialisation-des-etats","text":"fruits est une liste statique de fruits. expanded est un \u00e9tat bool\u00e9en pour contr\u00f4ler l'ouverture/fermeture du menu d\u00e9roulant. selectedFruit est un \u00e9tat pour stocker le fruit s\u00e9lectionn\u00e9. rememberSaveable est utilis\u00e9 pour conserver la s\u00e9lection m\u00eame apr\u00e8s une reconfiguration (comme une rotation d'\u00e9cran). Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) {","title":"Initialisation des \u00e9tats"},{"location":"2.%20Android/05-etats-evenements/#structure-de-linterface_1","text":"Un Column contient tous les \u00e9l\u00e9ments avec un padding de 16dp. ExposedDropdownMenuBox est le conteneur principal du menu d\u00e9roulant. TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choisissez un fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults .TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() )","title":"Structure de l'interface"},{"location":"2.%20Android/05-etats-evenements/#champ-de-texte-du-selecteur","text":"Un TextField affiche le fruit s\u00e9lectionn\u00e9. Il est en lecture seule ( readOnly = true ). Une ic\u00f4ne de menu d\u00e9roulant est ajout\u00e9e \u00e0 droite. .menuAnchor() lie ce champ au menu d\u00e9roulant. ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { selectedFruit = fruit expanded = false } ) } }","title":"Champ de texte du s\u00e9lecteur"},{"location":"2.%20Android/05-etats-evenements/#menu-deroulant","text":"ExposedDropdownMenu contient la liste des fruits. Chaque fruit est repr\u00e9sent\u00e9 par un DropdownMenuItem . Lors du clic sur un fruit, selectedFruit est mis \u00e0 jour et le menu se ferme. Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Fruit s\u00e9lectionn\u00e9 : $selectedFruit\") } } }","title":"Menu d\u00e9roulant"},{"location":"2.%20Android/05-etats-evenements/#affichage-de-la-selection","text":"Un espace vertical est ajout\u00e9. Si un fruit est s\u00e9lectionn\u00e9, il est affich\u00e9 en dessous du menu.","title":"Affichage de la s\u00e9lection"},{"location":"2.%20Android/05-etats-evenements/#fonctionnement-global","text":"L'utilisateur voit un champ de texte avec un label \"Choisissez un fruit\". En cliquant sur le champ, un menu d\u00e9roulant s'ouvre avec la liste des fruits. La s\u00e9lection d'un fruit met \u00e0 jour l'\u00e9tat selectedFruit et ferme le menu. Le fruit s\u00e9lectionn\u00e9 est affich\u00e9 dans le champ de texte et en dessous. Cette fonction illustre plusieurs concepts avanc\u00e9s de Jetpack Compose : Utilisation de composants Material 3 pour cr\u00e9er un menu d\u00e9roulant interactif. Gestion d'\u00e9tats avec remember et rememberSaveable . Cr\u00e9ation d'une interface utilisateur dynamique et r\u00e9active. Utilisation de lambdas pour g\u00e9rer les interactions utilisateur. Conditionnement de l'affichage bas\u00e9 sur l'\u00e9tat ( if (selectedFruit.isNotEmpty()) ). Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"Fonctionnement global"},{"location":"2.%20Android/06-hockey-v2/","text":"6. Application Hockey Version 2 Explication de PlayerListWithSearch Cette nouvelle version ajoute une fonctionnalit\u00e9 de recherche \u00e0 la liste des joueurs. Voici une explication d\u00e9taill\u00e9e des modifications : Fonction getPlayers fun getPlayers(name: String? = null): List<Player> = if (name == null) getSamplePlayers() else getSamplePlayers().filter { it.name.lowercase().contains(name.lowercase()) }.toList() Cette fonction permet de filtrer la liste des joueurs en fonction d'un crit\u00e8re de recherche : Si name est null , elle retourne tous les joueurs. Sinon, elle filtre la liste pour ne retourner que les joueurs dont le nom contient la cha\u00eene de recherche (insensible \u00e0 la casse). Composable PlayerListWithSearch @Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var searchCriteria by rememberSaveable { mutableStateOf(\"\") } Column { TextField( value = searchCriteria, onValueChange = { searchCriteria = it }, modifier = modifier ) LazyColumn(modifier = modifier.fillMaxSize()) { items(getPlayers(searchCriteria)) { PlayerCard(player = it) } } } } Ce composable remplace PlayerList et ajoute une fonctionnalit\u00e9 de recherche : searchCriteria : Utilise rememberSaveable pour conserver l'\u00e9tat de la recherche m\u00eame lors des recompositions. mutableStateOf(\"\") initialise la valeur de recherche \u00e0 une cha\u00eene vide. Column : Organise verticalement le champ de recherche et la liste des joueurs. TextField : Permet \u00e0 l'utilisateur d'entrer un crit\u00e8re de recherche. value = searchCriteria affiche la valeur actuelle. onValueChange = { searchCriteria = it } met \u00e0 jour searchCriteria \u00e0 chaque modification. LazyColumn : Similaire \u00e0 la version pr\u00e9c\u00e9dente, mais utilise maintenant getPlayers(searchCriteria) . Cela filtre dynamiquement la liste des joueurs en fonction du crit\u00e8re de recherche. items : Cr\u00e9e une PlayerCard pour chaque joueur filtr\u00e9. Cette nouvelle version offre une exp\u00e9rience utilisateur plus interactive, permettant de rechercher des joueurs sp\u00e9cifiques dans la liste. La liste se met \u00e0 jour automatiquement \u00e0 chaque modification du texte dans le champ de recherche, gr\u00e2ce \u00e0 l'utilisation de l'\u00e9tat ( searchCriteria ) et de la recomposition automatique de Jetpack Compose. Certainement. Voici une explication plus d\u00e9taill\u00e9e des connexions entre ces \u00e9l\u00e9ments, format\u00e9e en markdown avec le code Kotlin appropri\u00e9 : Connexions entre TextField , mutableStateOf , onValueChange , et getPlayers() 1. mutableStateOf et \u00c9tat Composable var searchCriteria by rememberSaveable { mutableStateOf(\"\") } mutableStateOf(\"\") cr\u00e9e un \u00e9tat mutable initialis\u00e9 avec une cha\u00eene vide. rememberSaveable permet de conserver cet \u00e9tat m\u00eame lors des recompositions ou des changements de configuration. by est utilis\u00e9 pour d\u00e9l\u00e9guer la propri\u00e9t\u00e9, permettant d'acc\u00e9der et de modifier searchCriteria directement. 2. TextField et onValueChange TextField( value = searchCriteria, onValueChange = { searchCriteria = it }, modifier = modifier ) value = searchCriteria : Le TextField affiche la valeur actuelle de searchCriteria . onValueChange = { searchCriteria = it } : Lorsque l'utilisateur tape dans le champ : it repr\u00e9sente la nouvelle valeur du champ. Cette nouvelle valeur est assign\u00e9e \u00e0 searchCriteria . Cela d\u00e9clenche une recomposition du composable. 3. Connexion avec getPlayers() LazyColumn(modifier = modifier.fillMaxSize()) { items(getPlayers(searchCriteria)) { PlayerCard(player = it) } } getPlayers(searchCriteria) est appel\u00e9 avec la valeur actuelle de searchCriteria . Chaque fois que searchCriteria change : getPlayers() est rappel\u00e9 avec la nouvelle valeur. La liste des joueurs est filtr\u00e9e en fonction de cette nouvelle valeur. LazyColumn se recompose avec la nouvelle liste filtr\u00e9e. 4. Flux de donn\u00e9es et recomposition L'utilisateur tape dans le TextField . onValueChange est appel\u00e9, mettant \u00e0 jour searchCriteria . La mise \u00e0 jour de searchCriteria d\u00e9clenche une recomposition. Lors de la recomposition : TextField affiche la nouvelle valeur de searchCriteria . getPlayers(searchCriteria) est appel\u00e9 avec la nouvelle valeur. LazyColumn se recompose avec la nouvelle liste filtr\u00e9e. Cette architecture r\u00e9active permet une mise \u00e0 jour en temps r\u00e9el de l'interface utilisateur. Chaque frappe dans le champ de recherche d\u00e9clenche une cha\u00eene de r\u00e9actions qui aboutit \u00e0 l'affichage filtr\u00e9 des joueurs, offrant une exp\u00e9rience utilisateur fluide et r\u00e9active. Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"6. Application Hockey Version 2"},{"location":"2.%20Android/06-hockey-v2/#6-application-hockey-version-2","text":"","title":"6. Application Hockey Version 2"},{"location":"2.%20Android/06-hockey-v2/#explication-de-playerlistwithsearch","text":"Cette nouvelle version ajoute une fonctionnalit\u00e9 de recherche \u00e0 la liste des joueurs. Voici une explication d\u00e9taill\u00e9e des modifications :","title":"Explication de PlayerListWithSearch"},{"location":"2.%20Android/06-hockey-v2/#fonction-getplayers","text":"fun getPlayers(name: String? = null): List<Player> = if (name == null) getSamplePlayers() else getSamplePlayers().filter { it.name.lowercase().contains(name.lowercase()) }.toList() Cette fonction permet de filtrer la liste des joueurs en fonction d'un crit\u00e8re de recherche : Si name est null , elle retourne tous les joueurs. Sinon, elle filtre la liste pour ne retourner que les joueurs dont le nom contient la cha\u00eene de recherche (insensible \u00e0 la casse).","title":"Fonction getPlayers"},{"location":"2.%20Android/06-hockey-v2/#composable-playerlistwithsearch","text":"@Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var searchCriteria by rememberSaveable { mutableStateOf(\"\") } Column { TextField( value = searchCriteria, onValueChange = { searchCriteria = it }, modifier = modifier ) LazyColumn(modifier = modifier.fillMaxSize()) { items(getPlayers(searchCriteria)) { PlayerCard(player = it) } } } } Ce composable remplace PlayerList et ajoute une fonctionnalit\u00e9 de recherche : searchCriteria : Utilise rememberSaveable pour conserver l'\u00e9tat de la recherche m\u00eame lors des recompositions. mutableStateOf(\"\") initialise la valeur de recherche \u00e0 une cha\u00eene vide. Column : Organise verticalement le champ de recherche et la liste des joueurs. TextField : Permet \u00e0 l'utilisateur d'entrer un crit\u00e8re de recherche. value = searchCriteria affiche la valeur actuelle. onValueChange = { searchCriteria = it } met \u00e0 jour searchCriteria \u00e0 chaque modification. LazyColumn : Similaire \u00e0 la version pr\u00e9c\u00e9dente, mais utilise maintenant getPlayers(searchCriteria) . Cela filtre dynamiquement la liste des joueurs en fonction du crit\u00e8re de recherche. items : Cr\u00e9e une PlayerCard pour chaque joueur filtr\u00e9. Cette nouvelle version offre une exp\u00e9rience utilisateur plus interactive, permettant de rechercher des joueurs sp\u00e9cifiques dans la liste. La liste se met \u00e0 jour automatiquement \u00e0 chaque modification du texte dans le champ de recherche, gr\u00e2ce \u00e0 l'utilisation de l'\u00e9tat ( searchCriteria ) et de la recomposition automatique de Jetpack Compose. Certainement. Voici une explication plus d\u00e9taill\u00e9e des connexions entre ces \u00e9l\u00e9ments, format\u00e9e en markdown avec le code Kotlin appropri\u00e9 :","title":"Composable PlayerListWithSearch"},{"location":"2.%20Android/06-hockey-v2/#connexions-entre-textfield-mutablestateof-onvaluechange-et-getplayers","text":"","title":"Connexions entre TextField, mutableStateOf, onValueChange, et getPlayers()"},{"location":"2.%20Android/06-hockey-v2/#1-mutablestateof-et-etat-composable","text":"var searchCriteria by rememberSaveable { mutableStateOf(\"\") } mutableStateOf(\"\") cr\u00e9e un \u00e9tat mutable initialis\u00e9 avec une cha\u00eene vide. rememberSaveable permet de conserver cet \u00e9tat m\u00eame lors des recompositions ou des changements de configuration. by est utilis\u00e9 pour d\u00e9l\u00e9guer la propri\u00e9t\u00e9, permettant d'acc\u00e9der et de modifier searchCriteria directement.","title":"1. mutableStateOf et \u00c9tat Composable"},{"location":"2.%20Android/06-hockey-v2/#2-textfield-et-onvaluechange","text":"TextField( value = searchCriteria, onValueChange = { searchCriteria = it }, modifier = modifier ) value = searchCriteria : Le TextField affiche la valeur actuelle de searchCriteria . onValueChange = { searchCriteria = it } : Lorsque l'utilisateur tape dans le champ : it repr\u00e9sente la nouvelle valeur du champ. Cette nouvelle valeur est assign\u00e9e \u00e0 searchCriteria . Cela d\u00e9clenche une recomposition du composable.","title":"2. TextField et onValueChange"},{"location":"2.%20Android/06-hockey-v2/#3-connexion-avec-getplayers","text":"LazyColumn(modifier = modifier.fillMaxSize()) { items(getPlayers(searchCriteria)) { PlayerCard(player = it) } } getPlayers(searchCriteria) est appel\u00e9 avec la valeur actuelle de searchCriteria . Chaque fois que searchCriteria change : getPlayers() est rappel\u00e9 avec la nouvelle valeur. La liste des joueurs est filtr\u00e9e en fonction de cette nouvelle valeur. LazyColumn se recompose avec la nouvelle liste filtr\u00e9e.","title":"3. Connexion avec getPlayers()"},{"location":"2.%20Android/06-hockey-v2/#4-flux-de-donnees-et-recomposition","text":"L'utilisateur tape dans le TextField . onValueChange est appel\u00e9, mettant \u00e0 jour searchCriteria . La mise \u00e0 jour de searchCriteria d\u00e9clenche une recomposition. Lors de la recomposition : TextField affiche la nouvelle valeur de searchCriteria . getPlayers(searchCriteria) est appel\u00e9 avec la nouvelle valeur. LazyColumn se recompose avec la nouvelle liste filtr\u00e9e. Cette architecture r\u00e9active permet une mise \u00e0 jour en temps r\u00e9el de l'interface utilisateur. Chaque frappe dans le champ de recherche d\u00e9clenche une cha\u00eene de r\u00e9actions qui aboutit \u00e0 l'affichage filtr\u00e9 des joueurs, offrant une exp\u00e9rience utilisateur fluide et r\u00e9active. Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"4. Flux de donn\u00e9es et recomposition"},{"location":"2.%20Android/07-orientation/","text":"7. Orientation de l'\u00e9cran Pour d\u00e9tecter l'orientation de l'\u00e9cran (portrait ou paysage) avec Jetpack Compose, vous pouvez utiliser le LocalConfiguration composable. Voici comment proc\u00e9der : 1- Importez les d\u00e9pendances n\u00e9cessaires : import android.content.res.Configuration import androidx.compose.runtime.Composable import androidx.compose.ui.platform.LocalConfiguration 2- Utilisez le LocalConfiguration dans votre composable pour obtenir la configuration actuelle : @Composable fun MyScreen() { val configuration = LocalConfiguration.current when (configuration.orientation) { Configuration.ORIENTATION_LANDSCAPE -> { // Code pour l'orientation paysage Text(\"L'\u00e9cran est en mode paysage\") } else -> { // Code pour l'orientation portrait Text(\"L'\u00e9cran est en mode portrait\") } } } 3- Pour observer les changements d'orientation, vous pouvez utiliser un State : @Composable fun OrientationAwareLayout() { val configuration = LocalConfiguration.current val orientation by remember { mutableStateOf(configuration.orientation) } LaunchedEffect(configuration) { snapshotFlow { configuration.orientation } .collect { orientation = it } } when (orientation) { Configuration.ORIENTATION_LANDSCAPE -> { // Mise en page pour le mode paysage } else -> { // Mise en page pour le mode portrait } } } Cette approche permet \u00e0 votre composable de se recomposer automatiquement lorsque l'orientation change[2]. En utilisant ces m\u00e9thodes, vous pouvez cr\u00e9er des interfaces utilisateur r\u00e9actives qui s'adaptent \u00e0 l'orientation de l'\u00e9cran. Cela est particuli\u00e8rement utile pour optimiser l'exp\u00e9rience utilisateur sur diff\u00e9rents appareils et dans diff\u00e9rentes configurations d'\u00e9cran[1][2]. Citations: [1] https://developer.android.com/guide/practices/device-compatibility-mode?hl=fr [2] https://www.geeksforgeeks.org/detect-screen-orientation-in-android-using-jetpack-compose/ [3] https://blog.ippon.fr/2023/04/28/developper-app-jetpack-compose-smartphones-pliables/ [4] https://developer.android.com/develop/ui/compose/touch-input/pointer-input/drag-swipe-fling?hl=fr [5] https://developer.android.com/develop/ui/compose/touch-input/stylus-input/advanced-stylus-features?hl=fr [6] https://stackoverflow.com/questions/64753944/orientation-on-jetpack-compose [7] https://appmaster.io/fr/blog/comment-creer-une-interface-utilisateur-adaptative-avec-jetpack-compose Exemple complet import android.content.res.Configuration import androidx.compose.foundation.layout.* import androidx.compose.material3.Button import androidx.compose.material3.ExperimentalMaterial3Api import androidx.compose.material3.Text import androidx.compose.material3.TextField import androidx.compose.runtime.* import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.platform.LocalConfiguration import androidx.compose.ui.unit.dp @OptIn(ExperimentalMaterial3Api::class) @Composable fun OrientationResponsiveLayout(modifier: Modifier = Modifier) { var text1 by remember { mutableStateOf(\"\") } var text2 by remember { mutableStateOf(\"\") } val configuration = LocalConfiguration.current val isLandscape = configuration.orientation == Configuration.ORIENTATION_LANDSCAPE if (isLandscape) { Column( modifier = modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally ) { Row( modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween ) { TextField( value = text1, onValueChange = { text1 = it }, label = { Text(\"Champ 1\") }, modifier = Modifier.weight(1f).padding(end = 8.dp) ) TextField( value = text2, onValueChange = { text2 = it }, label = { Text(\"Champ 2\") }, modifier = Modifier.weight(1f).padding(start = 8.dp) ) } Spacer(modifier = Modifier.height(16.dp)) Button(onClick = { /* Action du bouton */ }) { Text(\"Valider\") } } } else { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.spacedBy(16.dp) ) { TextField( value = text1, onValueChange = { text1 = it }, label = { Text(\"Champ 1\") }, modifier = Modifier.fillMaxWidth() ) TextField( value = text2, onValueChange = { text2 = it }, label = { Text(\"Champ 2\") }, modifier = Modifier.fillMaxWidth() ) Button(onClick = { /* Action du bouton */ }) { Text(\"Valider\") } } } } Dans cet exemple : Nous utilisons LocalConfiguration.current pour obtenir la configuration actuelle de l'\u00e9cran[5]. Nous v\u00e9rifions si l'orientation est en mode paysage en comparant configuration.orientation avec Configuration.ORIENTATION_LANDSCAPE [5]. En mode portrait (par d\u00e9faut) : Nous utilisons une Column pour agencer verticalement deux TextField et un Button [5]. Les \u00e9l\u00e9ments sont espac\u00e9s uniform\u00e9ment gr\u00e2ce \u00e0 verticalArrangement = Arrangement.spacedBy(16.dp) . En mode paysage : Nous utilisons une Column principale pour l'agencement global. \u00c0 l'int\u00e9rieur, nous utilisons une Row pour placer les deux TextField c\u00f4te \u00e0 c\u00f4te. Le Button est plac\u00e9 en dessous de la Row avec un Spacer pour ajouter un espacement. Les TextField utilisent Modifier.weight(1f) en mode paysage pour occuper un espace \u00e9gal dans la Row [2]. Nous utilisons remember et mutableStateOf pour g\u00e9rer l'\u00e9tat des champs de texte, permettant ainsi \u00e0 l'utilisateur d'interagir avec eux[5]. Ce composable s'adaptera automatiquement \u00e0 l'orientation de l'\u00e9cran, offrant une mise en page optimis\u00e9e pour les modes portrait et paysage. Il d\u00e9montre comment cr\u00e9er des interfaces utilisateur r\u00e9actives qui s'adaptent aux diff\u00e9rentes configurations d'\u00e9cran en utilisant Jetpack Compose. Citations: [1] https://developer.android.com/develop/ui/compose/layouts/adaptive [2] https://www.blog.finotes.com/post/creating-responsive-layouts-in-android-using-jetpack-compose [3] https://stackoverflow.com/questions/67157309/how-to-create-responsive-layouts-with-jetpack-compose [4] https://composables.com/jetpack-compose-tutorials/responsive-layout [5] https://www.geeksforgeeks.org/detect-screen-orientation-in-android-using-jetpack-compose/ [6] https://eevis.codes/blog/2024-07-18/dont-lock-the-screen-orientation-handling-orientation-in-compose/ Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"7. Orientation de l'\u00e9cran"},{"location":"2.%20Android/07-orientation/#7-orientation-de-lecran","text":"Pour d\u00e9tecter l'orientation de l'\u00e9cran (portrait ou paysage) avec Jetpack Compose, vous pouvez utiliser le LocalConfiguration composable. Voici comment proc\u00e9der : 1- Importez les d\u00e9pendances n\u00e9cessaires : import android.content.res.Configuration import androidx.compose.runtime.Composable import androidx.compose.ui.platform.LocalConfiguration 2- Utilisez le LocalConfiguration dans votre composable pour obtenir la configuration actuelle : @Composable fun MyScreen() { val configuration = LocalConfiguration.current when (configuration.orientation) { Configuration.ORIENTATION_LANDSCAPE -> { // Code pour l'orientation paysage Text(\"L'\u00e9cran est en mode paysage\") } else -> { // Code pour l'orientation portrait Text(\"L'\u00e9cran est en mode portrait\") } } } 3- Pour observer les changements d'orientation, vous pouvez utiliser un State : @Composable fun OrientationAwareLayout() { val configuration = LocalConfiguration.current val orientation by remember { mutableStateOf(configuration.orientation) } LaunchedEffect(configuration) { snapshotFlow { configuration.orientation } .collect { orientation = it } } when (orientation) { Configuration.ORIENTATION_LANDSCAPE -> { // Mise en page pour le mode paysage } else -> { // Mise en page pour le mode portrait } } } Cette approche permet \u00e0 votre composable de se recomposer automatiquement lorsque l'orientation change[2]. En utilisant ces m\u00e9thodes, vous pouvez cr\u00e9er des interfaces utilisateur r\u00e9actives qui s'adaptent \u00e0 l'orientation de l'\u00e9cran. Cela est particuli\u00e8rement utile pour optimiser l'exp\u00e9rience utilisateur sur diff\u00e9rents appareils et dans diff\u00e9rentes configurations d'\u00e9cran[1][2]. Citations: [1] https://developer.android.com/guide/practices/device-compatibility-mode?hl=fr [2] https://www.geeksforgeeks.org/detect-screen-orientation-in-android-using-jetpack-compose/ [3] https://blog.ippon.fr/2023/04/28/developper-app-jetpack-compose-smartphones-pliables/ [4] https://developer.android.com/develop/ui/compose/touch-input/pointer-input/drag-swipe-fling?hl=fr [5] https://developer.android.com/develop/ui/compose/touch-input/stylus-input/advanced-stylus-features?hl=fr [6] https://stackoverflow.com/questions/64753944/orientation-on-jetpack-compose [7] https://appmaster.io/fr/blog/comment-creer-une-interface-utilisateur-adaptative-avec-jetpack-compose","title":"7. Orientation de l'\u00e9cran"},{"location":"2.%20Android/07-orientation/#exemple-complet","text":"import android.content.res.Configuration import androidx.compose.foundation.layout.* import androidx.compose.material3.Button import androidx.compose.material3.ExperimentalMaterial3Api import androidx.compose.material3.Text import androidx.compose.material3.TextField import androidx.compose.runtime.* import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.platform.LocalConfiguration import androidx.compose.ui.unit.dp @OptIn(ExperimentalMaterial3Api::class) @Composable fun OrientationResponsiveLayout(modifier: Modifier = Modifier) { var text1 by remember { mutableStateOf(\"\") } var text2 by remember { mutableStateOf(\"\") } val configuration = LocalConfiguration.current val isLandscape = configuration.orientation == Configuration.ORIENTATION_LANDSCAPE if (isLandscape) { Column( modifier = modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally ) { Row( modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween ) { TextField( value = text1, onValueChange = { text1 = it }, label = { Text(\"Champ 1\") }, modifier = Modifier.weight(1f).padding(end = 8.dp) ) TextField( value = text2, onValueChange = { text2 = it }, label = { Text(\"Champ 2\") }, modifier = Modifier.weight(1f).padding(start = 8.dp) ) } Spacer(modifier = Modifier.height(16.dp)) Button(onClick = { /* Action du bouton */ }) { Text(\"Valider\") } } } else { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.spacedBy(16.dp) ) { TextField( value = text1, onValueChange = { text1 = it }, label = { Text(\"Champ 1\") }, modifier = Modifier.fillMaxWidth() ) TextField( value = text2, onValueChange = { text2 = it }, label = { Text(\"Champ 2\") }, modifier = Modifier.fillMaxWidth() ) Button(onClick = { /* Action du bouton */ }) { Text(\"Valider\") } } } } Dans cet exemple : Nous utilisons LocalConfiguration.current pour obtenir la configuration actuelle de l'\u00e9cran[5]. Nous v\u00e9rifions si l'orientation est en mode paysage en comparant configuration.orientation avec Configuration.ORIENTATION_LANDSCAPE [5]. En mode portrait (par d\u00e9faut) : Nous utilisons une Column pour agencer verticalement deux TextField et un Button [5]. Les \u00e9l\u00e9ments sont espac\u00e9s uniform\u00e9ment gr\u00e2ce \u00e0 verticalArrangement = Arrangement.spacedBy(16.dp) . En mode paysage : Nous utilisons une Column principale pour l'agencement global. \u00c0 l'int\u00e9rieur, nous utilisons une Row pour placer les deux TextField c\u00f4te \u00e0 c\u00f4te. Le Button est plac\u00e9 en dessous de la Row avec un Spacer pour ajouter un espacement. Les TextField utilisent Modifier.weight(1f) en mode paysage pour occuper un espace \u00e9gal dans la Row [2]. Nous utilisons remember et mutableStateOf pour g\u00e9rer l'\u00e9tat des champs de texte, permettant ainsi \u00e0 l'utilisateur d'interagir avec eux[5]. Ce composable s'adaptera automatiquement \u00e0 l'orientation de l'\u00e9cran, offrant une mise en page optimis\u00e9e pour les modes portrait et paysage. Il d\u00e9montre comment cr\u00e9er des interfaces utilisateur r\u00e9actives qui s'adaptent aux diff\u00e9rentes configurations d'\u00e9cran en utilisant Jetpack Compose. Citations: [1] https://developer.android.com/develop/ui/compose/layouts/adaptive [2] https://www.blog.finotes.com/post/creating-responsive-layouts-in-android-using-jetpack-compose [3] https://stackoverflow.com/questions/67157309/how-to-create-responsive-layouts-with-jetpack-compose [4] https://composables.com/jetpack-compose-tutorials/responsive-layout [5] https://www.geeksforgeeks.org/detect-screen-orientation-in-android-using-jetpack-compose/ [6] https://eevis.codes/blog/2024-07-18/dont-lock-the-screen-orientation-handling-orientation-in-compose/ Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"Exemple complet"},{"location":"2.%20Android/08-hockey-v3/","text":"8. Application Hockey Version 3 Diff\u00e9rentes versions de PlayerListWithSearch Version pr\u00e9c\u00e9dente @Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } Column(modifier = modifier) { Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { TextField( value = nameSearch, label = { Text(text = \"Nom\") }, onValueChange = { nameSearch = it }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Num\u00e9ro\") }, onValueChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) } LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } } } Description g\u00e9n\u00e9rale Ce code d\u00e9finit une fonction composable nomm\u00e9e PlayerListWithSearch qui cr\u00e9e une interface utilisateur pour afficher une liste de joueurs de hockey avec une fonctionnalit\u00e9 de recherche. L'interface comprend deux champs de texte pour la recherche (un pour le nom et un pour le num\u00e9ro) et une liste d\u00e9roulante des joueurs correspondant aux crit\u00e8res de recherche. Description d\u00e9taill\u00e9e D\u00e9claration de la fonction : kotlin @Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) C'est une fonction composable qui accepte un modifier optionnel comme param\u00e8tre. Variables d'\u00e9tat : kotlin var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } nameSearch : Une cha\u00eene de caract\u00e8res pour stocker la recherche par nom. numberSearch : Un entier nullable pour stocker la recherche par num\u00e9ro. Ces variables utilisent rememberSaveable pour conserver leur \u00e9tat m\u00eame apr\u00e8s une reconfiguration. Structure principale : kotlin Column(modifier = modifier) { // Contenu } Utilise un Column comme conteneur principal avec le modificateur pass\u00e9 en param\u00e8tre. Champs de recherche : kotlin Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { // Champs de texte } Un Column interne avec un padding pour contenir les champs de recherche. Champ de recherche par nom : kotlin TextField( value = nameSearch, label = { Text(text = \"Nom\") }, onValueChange = { nameSearch = it }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) Un TextField pour la recherche par nom. La valeur est li\u00e9e \u00e0 nameSearch . Le label affiche \"Nom\". onValueChange met \u00e0 jour nameSearch avec la nouvelle valeur. Champ de recherche par num\u00e9ro : kotlin TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Num\u00e9ro\") }, onValueChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) Un TextField pour la recherche par num\u00e9ro. La valeur affich\u00e9e est la conversion en cha\u00eene de numberSearch (ou une cha\u00eene vide si null). Le label affiche \"Num\u00e9ro\". onValueChange tente de convertir l'entr\u00e9e en entier, conservant la valeur pr\u00e9c\u00e9dente si la conversion \u00e9choue. Liste des joueurs : kotlin LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } Utilise un LazyColumn pour afficher efficacement une liste potentiellement longue de joueurs. getPlayers(nameSearch, numberSearch) est appel\u00e9 pour obtenir la liste filtr\u00e9e des joueurs. Chaque joueur est affich\u00e9 en utilisant un composant HockeyPlayerCard . Ce code cr\u00e9e une interface utilisateur interactive permettant aux utilisateurs de rechercher des joueurs de hockey par nom et num\u00e9ro, avec une mise \u00e0 jour dynamique de la liste affich\u00e9e en fonction des crit\u00e8res de recherche. Nouvelle version @Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } Column(modifier = modifier) { SearchTextFields( nameSearch = nameSearch, onNameChange = { nameSearch = it }, numberSearch = numberSearch, onNumberChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }) LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } } } @Composable private fun SearchTextFields( nameSearch: String, onNameChange: (String) -> Unit, numberSearch: Int?, onNumberChange: (String) -> Unit, ) { Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { TextField( value = nameSearch, label = { Text(text = \"Nom\") }, onValueChange = onNameChange, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Num\u00e9ro\") }, onValueChange = onNumberChange, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) } } Cette refactorisation illustre bien comment on peut am\u00e9liorer la structure et la r\u00e9utilisabilit\u00e9 du code en Jetpack Compose. Voici une explication d\u00e9taill\u00e9e de la transition entre les deux versions, en mettant l'accent sur la gestion des variables d'\u00e9tat et des fonctions lambda : Cr\u00e9ation du nouveau composable SearchTextFields : Un nouveau composable priv\u00e9 a \u00e9t\u00e9 cr\u00e9\u00e9 pour encapsuler la logique des champs de recherche. Cela am\u00e9liore la lisibilit\u00e9 et la r\u00e9utilisabilit\u00e9 du code. Param\u00e8tres du nouveau composable : nameSearch: String : La valeur actuelle de la recherche par nom. onNameChange: (String) -> Unit : Une fonction lambda pour g\u00e9rer les changements de nom. numberSearch: Int? : La valeur actuelle de la recherche par num\u00e9ro. onNumberChange: (String) -> Unit : Une fonction lambda pour g\u00e9rer les changements de num\u00e9ro. Passage des variables d'\u00e9tat : Dans PlayerListWithSearch , les variables d'\u00e9tat nameSearch et numberSearch sont pass\u00e9es directement \u00e0 SearchTextFields . Cela permet \u00e0 SearchTextFields d'utiliser ces valeurs sans les poss\u00e9der ou les modifier directement. Passage des fonctions lambda : Pour onNameChange , une simple lambda est pass\u00e9e : { nameSearch = it } . Cette lambda met \u00e0 jour directement la variable d'\u00e9tat nameSearch . Pour onNumberChange , la logique de conversion est pass\u00e9e en tant que lambda : kotlin { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch } Cette lambda g\u00e8re la conversion de la cha\u00eene en entier et la mise \u00e0 jour de numberSearch . Utilisation dans SearchTextFields : Les TextField utilisent maintenant les param\u00e8tres pass\u00e9s au lieu d'acc\u00e9der directement aux variables d'\u00e9tat. value = nameSearch et value = (numberSearch ?: \"\").toString() utilisent les valeurs pass\u00e9es. onValueChange = onNameChange et onValueChange = onNumberChange utilisent les lambdas pass\u00e9es. Avantages de cette approche : S\u00e9paration des pr\u00e9occupations : SearchTextFields ne g\u00e8re que l'affichage et la collecte des entr\u00e9es. \u00c9tat \u00e9lev\u00e9 (State hoisting) : L'\u00e9tat reste dans le composant parent, rendant SearchTextFields plus flexible et r\u00e9utilisable. Testabilit\u00e9 am\u00e9lior\u00e9e : Il est plus facile de tester SearchTextFields ind\u00e9pendamment. Implications pour la gestion de l'\u00e9tat : L'\u00e9tat ( nameSearch et numberSearch ) est toujours g\u00e9r\u00e9 dans PlayerListWithSearch . SearchTextFields devient un composant \"sans \u00e9tat\" (stateless), ne faisant que refl\u00e9ter l'\u00e9tat qui lui est pass\u00e9. Cette refactorisation est un excellent exemple de la fa\u00e7on dont on peut appliquer le principe de \"state hoisting\" en Jetpack Compose, en \u00e9levant l'\u00e9tat et les fonctions de modification d'\u00e9tat vers le composant parent. Cela rend le code plus modulaire, plus facile \u00e0 maintenir et \u00e0 tester, tout en conservant une s\u00e9paration claire des responsabilit\u00e9s entre les composants.","title":"8. Application Hockey Version 3"},{"location":"2.%20Android/08-hockey-v3/#8-application-hockey-version-3","text":"","title":"8. Application Hockey Version 3"},{"location":"2.%20Android/08-hockey-v3/#differentes-versions-de-playerlistwithsearch","text":"","title":"Diff\u00e9rentes versions de PlayerListWithSearch"},{"location":"2.%20Android/08-hockey-v3/#version-precedente","text":"@Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } Column(modifier = modifier) { Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { TextField( value = nameSearch, label = { Text(text = \"Nom\") }, onValueChange = { nameSearch = it }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Num\u00e9ro\") }, onValueChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) } LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } } }","title":"Version pr\u00e9c\u00e9dente"},{"location":"2.%20Android/08-hockey-v3/#description-generale","text":"Ce code d\u00e9finit une fonction composable nomm\u00e9e PlayerListWithSearch qui cr\u00e9e une interface utilisateur pour afficher une liste de joueurs de hockey avec une fonctionnalit\u00e9 de recherche. L'interface comprend deux champs de texte pour la recherche (un pour le nom et un pour le num\u00e9ro) et une liste d\u00e9roulante des joueurs correspondant aux crit\u00e8res de recherche.","title":"Description g\u00e9n\u00e9rale"},{"location":"2.%20Android/08-hockey-v3/#description-detaillee","text":"D\u00e9claration de la fonction : kotlin @Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) C'est une fonction composable qui accepte un modifier optionnel comme param\u00e8tre. Variables d'\u00e9tat : kotlin var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } nameSearch : Une cha\u00eene de caract\u00e8res pour stocker la recherche par nom. numberSearch : Un entier nullable pour stocker la recherche par num\u00e9ro. Ces variables utilisent rememberSaveable pour conserver leur \u00e9tat m\u00eame apr\u00e8s une reconfiguration. Structure principale : kotlin Column(modifier = modifier) { // Contenu } Utilise un Column comme conteneur principal avec le modificateur pass\u00e9 en param\u00e8tre. Champs de recherche : kotlin Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { // Champs de texte } Un Column interne avec un padding pour contenir les champs de recherche. Champ de recherche par nom : kotlin TextField( value = nameSearch, label = { Text(text = \"Nom\") }, onValueChange = { nameSearch = it }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) Un TextField pour la recherche par nom. La valeur est li\u00e9e \u00e0 nameSearch . Le label affiche \"Nom\". onValueChange met \u00e0 jour nameSearch avec la nouvelle valeur. Champ de recherche par num\u00e9ro : kotlin TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Num\u00e9ro\") }, onValueChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) Un TextField pour la recherche par num\u00e9ro. La valeur affich\u00e9e est la conversion en cha\u00eene de numberSearch (ou une cha\u00eene vide si null). Le label affiche \"Num\u00e9ro\". onValueChange tente de convertir l'entr\u00e9e en entier, conservant la valeur pr\u00e9c\u00e9dente si la conversion \u00e9choue. Liste des joueurs : kotlin LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } Utilise un LazyColumn pour afficher efficacement une liste potentiellement longue de joueurs. getPlayers(nameSearch, numberSearch) est appel\u00e9 pour obtenir la liste filtr\u00e9e des joueurs. Chaque joueur est affich\u00e9 en utilisant un composant HockeyPlayerCard . Ce code cr\u00e9e une interface utilisateur interactive permettant aux utilisateurs de rechercher des joueurs de hockey par nom et num\u00e9ro, avec une mise \u00e0 jour dynamique de la liste affich\u00e9e en fonction des crit\u00e8res de recherche.","title":"Description d\u00e9taill\u00e9e"},{"location":"2.%20Android/08-hockey-v3/#nouvelle-version","text":"@Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } Column(modifier = modifier) { SearchTextFields( nameSearch = nameSearch, onNameChange = { nameSearch = it }, numberSearch = numberSearch, onNumberChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }) LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } } } @Composable private fun SearchTextFields( nameSearch: String, onNameChange: (String) -> Unit, numberSearch: Int?, onNumberChange: (String) -> Unit, ) { Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { TextField( value = nameSearch, label = { Text(text = \"Nom\") }, onValueChange = onNameChange, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Num\u00e9ro\") }, onValueChange = onNumberChange, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) } } Cette refactorisation illustre bien comment on peut am\u00e9liorer la structure et la r\u00e9utilisabilit\u00e9 du code en Jetpack Compose. Voici une explication d\u00e9taill\u00e9e de la transition entre les deux versions, en mettant l'accent sur la gestion des variables d'\u00e9tat et des fonctions lambda : Cr\u00e9ation du nouveau composable SearchTextFields : Un nouveau composable priv\u00e9 a \u00e9t\u00e9 cr\u00e9\u00e9 pour encapsuler la logique des champs de recherche. Cela am\u00e9liore la lisibilit\u00e9 et la r\u00e9utilisabilit\u00e9 du code. Param\u00e8tres du nouveau composable : nameSearch: String : La valeur actuelle de la recherche par nom. onNameChange: (String) -> Unit : Une fonction lambda pour g\u00e9rer les changements de nom. numberSearch: Int? : La valeur actuelle de la recherche par num\u00e9ro. onNumberChange: (String) -> Unit : Une fonction lambda pour g\u00e9rer les changements de num\u00e9ro. Passage des variables d'\u00e9tat : Dans PlayerListWithSearch , les variables d'\u00e9tat nameSearch et numberSearch sont pass\u00e9es directement \u00e0 SearchTextFields . Cela permet \u00e0 SearchTextFields d'utiliser ces valeurs sans les poss\u00e9der ou les modifier directement. Passage des fonctions lambda : Pour onNameChange , une simple lambda est pass\u00e9e : { nameSearch = it } . Cette lambda met \u00e0 jour directement la variable d'\u00e9tat nameSearch . Pour onNumberChange , la logique de conversion est pass\u00e9e en tant que lambda : kotlin { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch } Cette lambda g\u00e8re la conversion de la cha\u00eene en entier et la mise \u00e0 jour de numberSearch . Utilisation dans SearchTextFields : Les TextField utilisent maintenant les param\u00e8tres pass\u00e9s au lieu d'acc\u00e9der directement aux variables d'\u00e9tat. value = nameSearch et value = (numberSearch ?: \"\").toString() utilisent les valeurs pass\u00e9es. onValueChange = onNameChange et onValueChange = onNumberChange utilisent les lambdas pass\u00e9es. Avantages de cette approche : S\u00e9paration des pr\u00e9occupations : SearchTextFields ne g\u00e8re que l'affichage et la collecte des entr\u00e9es. \u00c9tat \u00e9lev\u00e9 (State hoisting) : L'\u00e9tat reste dans le composant parent, rendant SearchTextFields plus flexible et r\u00e9utilisable. Testabilit\u00e9 am\u00e9lior\u00e9e : Il est plus facile de tester SearchTextFields ind\u00e9pendamment. Implications pour la gestion de l'\u00e9tat : L'\u00e9tat ( nameSearch et numberSearch ) est toujours g\u00e9r\u00e9 dans PlayerListWithSearch . SearchTextFields devient un composant \"sans \u00e9tat\" (stateless), ne faisant que refl\u00e9ter l'\u00e9tat qui lui est pass\u00e9. Cette refactorisation est un excellent exemple de la fa\u00e7on dont on peut appliquer le principe de \"state hoisting\" en Jetpack Compose, en \u00e9levant l'\u00e9tat et les fonctions de modification d'\u00e9tat vers le composant parent. Cela rend le code plus modulaire, plus facile \u00e0 maintenir et \u00e0 tester, tout en conservant une s\u00e9paration claire des responsabilit\u00e9s entre les composants.","title":"Nouvelle version"},{"location":"2.%20Android/09-etats-evenements-v2/","text":"9. Gestion des \u00e9tats et des \u00e9v\u00e9nements Exemple : ExemplesEntrees Exemple sur GitHub Premi\u00e8re version @OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector(modifier: Modifier = Modifier) { val fruits = listOf(\"Pomme\", \"Banane\", \"Orange\", \"Fraise\", \"Kiwi\") var expanded by remember { mutableStateOf(false) } var selectedFruit by remember { mutableStateOf(\"\") } Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) { TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choisissez un fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() ) ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { selectedFruit = fruit expanded = false } ) } } } Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Fruit s\u00e9lectionn\u00e9 : $selectedFruit\") } } } @Composable fun App(modifier: Modifier = Modifier) { Column(modifier = modifier) { TextLengthCounter() Spacer(modifier = Modifier.height(100.dp)) FruitSelector() } } Bien s\u00fbr, je vais vous donner une description g\u00e9n\u00e9rale de ces deux fonctions, en me concentrant particuli\u00e8rement sur FruitSelector . Description g\u00e9n\u00e9rale FruitSelector : C'est une fonction composable qui cr\u00e9e un s\u00e9lecteur de fruits sous forme de menu d\u00e9roulant. App : C'est la fonction composable principale qui structure l'interface utilisateur de l'application en combinant diff\u00e9rents composants. Focus sur FruitSelector La fonction FruitSelector est un composant Jetpack Compose qui cr\u00e9e un menu d\u00e9roulant permettant \u00e0 l'utilisateur de s\u00e9lectionner un fruit parmi une liste pr\u00e9d\u00e9finie. Voici ses principales caract\u00e9ristiques : Liste de fruits : Une liste statique de fruits est d\u00e9finie au d\u00e9but de la fonction. \u00c9tats : expanded : Un \u00e9tat bool\u00e9en qui contr\u00f4le si le menu d\u00e9roulant est ouvert ou ferm\u00e9. selectedFruit : Un \u00e9tat qui stocke le fruit actuellement s\u00e9lectionn\u00e9. Interface utilisateur : Utilise ExposedDropdownMenuBox pour cr\u00e9er le conteneur du menu d\u00e9roulant. Affiche un TextField qui sert de d\u00e9clencheur pour ouvrir le menu. Ce champ est en lecture seule et affiche le fruit s\u00e9lectionn\u00e9. Le menu d\u00e9roulant ( ExposedDropdownMenu ) contient la liste des fruits, chacun repr\u00e9sent\u00e9 par un DropdownMenuItem . Interaction : Lorsqu'un fruit est s\u00e9lectionn\u00e9, le menu se ferme et le fruit choisi est affich\u00e9 dans le TextField. Un texte suppl\u00e9mentaire s'affiche en dessous pour confirmer le fruit s\u00e9lectionn\u00e9. Mise en page : Utilise une Column pour organiser verticalement les \u00e9l\u00e9ments. Ajoute des espacements et du rembourrage pour am\u00e9liorer l'apparence. Personnalisation : Accepte un modifier en param\u00e8tre pour permettre une personnalisation suppl\u00e9mentaire si n\u00e9cessaire. Cette fonction d\u00e9montre l'utilisation de plusieurs concepts importants de Jetpack Compose, tels que la gestion d'\u00e9tat, les composants d'interface utilisateur Material 3, et la cr\u00e9ation de composants interactifs. Elle offre une interface utilisateur intuitive pour la s\u00e9lection d'\u00e9l\u00e9ments dans une liste, ce qui est une fonctionnalit\u00e9 courante dans de nombreuses applications. Deuxi\u00e8me version @OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector( modifier: Modifier = Modifier, fruits: List<String>, selectedFruit: String, onFruitSelected: (String) -> Unit = {} ) { var expanded by remember { mutableStateOf(false) } Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) { TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choisissez un fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults .TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() ) ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { onFruitSelected(fruit) expanded = false } ) } } } Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Fruit s\u00e9lectionn\u00e9 : $selectedFruit\") } } } @Composable fun App(modifier: Modifier = Modifier) { var selectedFruit1 by rememberSaveable { mutableStateOf(\"\") } var selectedFruit2 by rememberSaveable { mutableStateOf(\"\") } Column(modifier = modifier) { TextLengthCounter() Spacer(modifier = Modifier.height(100.dp)) FruitSelector( fruits = listOf(\"Pomme\", \"Banane\", \"Orange\", \"Fraise\", \"Kiwi\"), selectedFruit = selectedFruit1, onFruitSelected = { fruit -> selectedFruit1 = fruit } ) Spacer(modifier = Modifier.height(10.dp)) FruitSelector( fruits = listOf(\"Poire\", \"Mangue\", \"Orange\", \"Bleuet\", \"Pamplemousse\"), selectedFruit = selectedFruit2, onFruitSelected = { fruit -> selectedFruit2 = fruit } ) Spacer(modifier = Modifier.height(10.dp)) Text(\"Fruit s\u00e9lectionn\u00e9 1 : ${selectedFruit1 ?: \"Aucun\"}\") Text(\"Fruit s\u00e9lectionn\u00e9 2 : ${selectedFruit2 ?: \"Aucun\"}\") } } Cette nouvelle version de l'application d\u00e9montre une refactorisation importante, principalement ax\u00e9e sur l'\u00e9l\u00e9vation de l'\u00e9tat (state hoisting) et la r\u00e9utilisabilit\u00e9 des composants. Examinons en d\u00e9tail les changements et leurs implications : Refactorisation de FruitSelector \u00c9l\u00e9vation de l'\u00e9tat : selectedFruit n'est plus g\u00e9r\u00e9 \u00e0 l'int\u00e9rieur de FruitSelector . Il est maintenant pass\u00e9 en tant que param\u00e8tre. Une nouvelle fonction onFruitSelected est ajout\u00e9e comme param\u00e8tre pour g\u00e9rer les changements de s\u00e9lection. Param\u00e8tres ajout\u00e9s : fruits: List<String> : La liste des fruits est maintenant un param\u00e8tre, rendant le composant plus flexible. selectedFruit: String : L'\u00e9tat du fruit s\u00e9lectionn\u00e9 est pass\u00e9 en param\u00e8tre. onFruitSelected: (String) -> Unit : Une fonction de rappel pour g\u00e9rer la s\u00e9lection d'un fruit. \u00c9tat local restant : expanded reste un \u00e9tat local car il concerne uniquement l'affichage du menu d\u00e9roulant. Modifications dans App Gestion de l'\u00e9tat : Deux nouvelles variables d'\u00e9tat sont introduites : selectedFruit1 et selectedFruit2 . Ces \u00e9tats sont cr\u00e9\u00e9s avec rememberSaveable pour persister \u00e0 travers les recompositions et les changements de configuration. Utilisation de FruitSelector : Deux instances de FruitSelector sont cr\u00e9\u00e9es, chacune avec sa propre liste de fruits et son propre \u00e9tat. L'\u00e9tat et la fonction de mise \u00e0 jour sont pass\u00e9s \u00e0 chaque FruitSelector . Affichage des s\u00e9lections : Les fruits s\u00e9lectionn\u00e9s sont affich\u00e9s en bas de l'App, d\u00e9montrant que l'\u00e9tat est maintenant g\u00e9r\u00e9 au niveau sup\u00e9rieur. Avantages de cette refactorisation R\u00e9utilisabilit\u00e9 : FruitSelector peut maintenant \u00eatre utilis\u00e9 plusieurs fois avec diff\u00e9rentes listes de fruits. S\u00e9paration des responsabilit\u00e9s : La gestion de l'\u00e9tat est s\u00e9par\u00e9e de l'affichage, rendant le code plus modulaire. Contr\u00f4le accru : L'App a maintenant un contr\u00f4le total sur l'\u00e9tat des s\u00e9lections, permettant des interactions plus complexes si n\u00e9cessaire. Testabilit\u00e9 am\u00e9lior\u00e9e : Il est plus facile de tester FruitSelector car son comportement d\u00e9pend enti\u00e8rement des props pass\u00e9es. Flexibilit\u00e9 : La liste de fruits peut \u00eatre dynamique, provenant par exemple d'une API ou d'une base de donn\u00e9es. Focus sur les variables d'\u00e9tat Dans App , selectedFruit1 et selectedFruit2 sont des variables d'\u00e9tat cr\u00e9\u00e9es avec rememberSaveable . Cela signifie qu'elles conserveront leur valeur m\u00eame lors des changements de configuration (comme la rotation de l'\u00e9cran). Dans FruitSelector , seul expanded reste une variable d'\u00e9tat locale, car elle ne concerne que l'affichage interne du composant. Cette refactorisation illustre des principes importants de Jetpack Compose, notamment l'\u00e9l\u00e9vation de l'\u00e9tat et la cr\u00e9ation de composants r\u00e9utilisables et ind\u00e9pendants. Elle permet une meilleure gestion de l'\u00e9tat de l'application et une plus grande flexibilit\u00e9 dans la construction de l'interface utilisateur.","title":"9. Gestion des \u00e9tats et des \u00e9v\u00e9nements"},{"location":"2.%20Android/09-etats-evenements-v2/#9-gestion-des-etats-et-des-evenements","text":"","title":"9. Gestion des \u00e9tats et des \u00e9v\u00e9nements"},{"location":"2.%20Android/09-etats-evenements-v2/#exemple-exemplesentrees","text":"Exemple sur GitHub","title":"Exemple : ExemplesEntrees"},{"location":"2.%20Android/09-etats-evenements-v2/#premiere-version","text":"@OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector(modifier: Modifier = Modifier) { val fruits = listOf(\"Pomme\", \"Banane\", \"Orange\", \"Fraise\", \"Kiwi\") var expanded by remember { mutableStateOf(false) } var selectedFruit by remember { mutableStateOf(\"\") } Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) { TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choisissez un fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() ) ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { selectedFruit = fruit expanded = false } ) } } } Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Fruit s\u00e9lectionn\u00e9 : $selectedFruit\") } } } @Composable fun App(modifier: Modifier = Modifier) { Column(modifier = modifier) { TextLengthCounter() Spacer(modifier = Modifier.height(100.dp)) FruitSelector() } } Bien s\u00fbr, je vais vous donner une description g\u00e9n\u00e9rale de ces deux fonctions, en me concentrant particuli\u00e8rement sur FruitSelector .","title":"Premi\u00e8re version"},{"location":"2.%20Android/09-etats-evenements-v2/#description-generale","text":"FruitSelector : C'est une fonction composable qui cr\u00e9e un s\u00e9lecteur de fruits sous forme de menu d\u00e9roulant. App : C'est la fonction composable principale qui structure l'interface utilisateur de l'application en combinant diff\u00e9rents composants.","title":"Description g\u00e9n\u00e9rale"},{"location":"2.%20Android/09-etats-evenements-v2/#focus-sur-fruitselector","text":"La fonction FruitSelector est un composant Jetpack Compose qui cr\u00e9e un menu d\u00e9roulant permettant \u00e0 l'utilisateur de s\u00e9lectionner un fruit parmi une liste pr\u00e9d\u00e9finie. Voici ses principales caract\u00e9ristiques : Liste de fruits : Une liste statique de fruits est d\u00e9finie au d\u00e9but de la fonction. \u00c9tats : expanded : Un \u00e9tat bool\u00e9en qui contr\u00f4le si le menu d\u00e9roulant est ouvert ou ferm\u00e9. selectedFruit : Un \u00e9tat qui stocke le fruit actuellement s\u00e9lectionn\u00e9. Interface utilisateur : Utilise ExposedDropdownMenuBox pour cr\u00e9er le conteneur du menu d\u00e9roulant. Affiche un TextField qui sert de d\u00e9clencheur pour ouvrir le menu. Ce champ est en lecture seule et affiche le fruit s\u00e9lectionn\u00e9. Le menu d\u00e9roulant ( ExposedDropdownMenu ) contient la liste des fruits, chacun repr\u00e9sent\u00e9 par un DropdownMenuItem . Interaction : Lorsqu'un fruit est s\u00e9lectionn\u00e9, le menu se ferme et le fruit choisi est affich\u00e9 dans le TextField. Un texte suppl\u00e9mentaire s'affiche en dessous pour confirmer le fruit s\u00e9lectionn\u00e9. Mise en page : Utilise une Column pour organiser verticalement les \u00e9l\u00e9ments. Ajoute des espacements et du rembourrage pour am\u00e9liorer l'apparence. Personnalisation : Accepte un modifier en param\u00e8tre pour permettre une personnalisation suppl\u00e9mentaire si n\u00e9cessaire. Cette fonction d\u00e9montre l'utilisation de plusieurs concepts importants de Jetpack Compose, tels que la gestion d'\u00e9tat, les composants d'interface utilisateur Material 3, et la cr\u00e9ation de composants interactifs. Elle offre une interface utilisateur intuitive pour la s\u00e9lection d'\u00e9l\u00e9ments dans une liste, ce qui est une fonctionnalit\u00e9 courante dans de nombreuses applications.","title":"Focus sur FruitSelector"},{"location":"2.%20Android/09-etats-evenements-v2/#deuxieme-version","text":"@OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector( modifier: Modifier = Modifier, fruits: List<String>, selectedFruit: String, onFruitSelected: (String) -> Unit = {} ) { var expanded by remember { mutableStateOf(false) } Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) { TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choisissez un fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults .TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() ) ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { onFruitSelected(fruit) expanded = false } ) } } } Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Fruit s\u00e9lectionn\u00e9 : $selectedFruit\") } } } @Composable fun App(modifier: Modifier = Modifier) { var selectedFruit1 by rememberSaveable { mutableStateOf(\"\") } var selectedFruit2 by rememberSaveable { mutableStateOf(\"\") } Column(modifier = modifier) { TextLengthCounter() Spacer(modifier = Modifier.height(100.dp)) FruitSelector( fruits = listOf(\"Pomme\", \"Banane\", \"Orange\", \"Fraise\", \"Kiwi\"), selectedFruit = selectedFruit1, onFruitSelected = { fruit -> selectedFruit1 = fruit } ) Spacer(modifier = Modifier.height(10.dp)) FruitSelector( fruits = listOf(\"Poire\", \"Mangue\", \"Orange\", \"Bleuet\", \"Pamplemousse\"), selectedFruit = selectedFruit2, onFruitSelected = { fruit -> selectedFruit2 = fruit } ) Spacer(modifier = Modifier.height(10.dp)) Text(\"Fruit s\u00e9lectionn\u00e9 1 : ${selectedFruit1 ?: \"Aucun\"}\") Text(\"Fruit s\u00e9lectionn\u00e9 2 : ${selectedFruit2 ?: \"Aucun\"}\") } } Cette nouvelle version de l'application d\u00e9montre une refactorisation importante, principalement ax\u00e9e sur l'\u00e9l\u00e9vation de l'\u00e9tat (state hoisting) et la r\u00e9utilisabilit\u00e9 des composants. Examinons en d\u00e9tail les changements et leurs implications :","title":"Deuxi\u00e8me version"},{"location":"2.%20Android/09-etats-evenements-v2/#refactorisation-de-fruitselector","text":"\u00c9l\u00e9vation de l'\u00e9tat : selectedFruit n'est plus g\u00e9r\u00e9 \u00e0 l'int\u00e9rieur de FruitSelector . Il est maintenant pass\u00e9 en tant que param\u00e8tre. Une nouvelle fonction onFruitSelected est ajout\u00e9e comme param\u00e8tre pour g\u00e9rer les changements de s\u00e9lection. Param\u00e8tres ajout\u00e9s : fruits: List<String> : La liste des fruits est maintenant un param\u00e8tre, rendant le composant plus flexible. selectedFruit: String : L'\u00e9tat du fruit s\u00e9lectionn\u00e9 est pass\u00e9 en param\u00e8tre. onFruitSelected: (String) -> Unit : Une fonction de rappel pour g\u00e9rer la s\u00e9lection d'un fruit. \u00c9tat local restant : expanded reste un \u00e9tat local car il concerne uniquement l'affichage du menu d\u00e9roulant.","title":"Refactorisation de FruitSelector"},{"location":"2.%20Android/09-etats-evenements-v2/#modifications-dans-app","text":"Gestion de l'\u00e9tat : Deux nouvelles variables d'\u00e9tat sont introduites : selectedFruit1 et selectedFruit2 . Ces \u00e9tats sont cr\u00e9\u00e9s avec rememberSaveable pour persister \u00e0 travers les recompositions et les changements de configuration. Utilisation de FruitSelector : Deux instances de FruitSelector sont cr\u00e9\u00e9es, chacune avec sa propre liste de fruits et son propre \u00e9tat. L'\u00e9tat et la fonction de mise \u00e0 jour sont pass\u00e9s \u00e0 chaque FruitSelector . Affichage des s\u00e9lections : Les fruits s\u00e9lectionn\u00e9s sont affich\u00e9s en bas de l'App, d\u00e9montrant que l'\u00e9tat est maintenant g\u00e9r\u00e9 au niveau sup\u00e9rieur.","title":"Modifications dans App"},{"location":"2.%20Android/09-etats-evenements-v2/#avantages-de-cette-refactorisation","text":"R\u00e9utilisabilit\u00e9 : FruitSelector peut maintenant \u00eatre utilis\u00e9 plusieurs fois avec diff\u00e9rentes listes de fruits. S\u00e9paration des responsabilit\u00e9s : La gestion de l'\u00e9tat est s\u00e9par\u00e9e de l'affichage, rendant le code plus modulaire. Contr\u00f4le accru : L'App a maintenant un contr\u00f4le total sur l'\u00e9tat des s\u00e9lections, permettant des interactions plus complexes si n\u00e9cessaire. Testabilit\u00e9 am\u00e9lior\u00e9e : Il est plus facile de tester FruitSelector car son comportement d\u00e9pend enti\u00e8rement des props pass\u00e9es. Flexibilit\u00e9 : La liste de fruits peut \u00eatre dynamique, provenant par exemple d'une API ou d'une base de donn\u00e9es.","title":"Avantages de cette refactorisation"},{"location":"2.%20Android/09-etats-evenements-v2/#focus-sur-les-variables-detat","text":"Dans App , selectedFruit1 et selectedFruit2 sont des variables d'\u00e9tat cr\u00e9\u00e9es avec rememberSaveable . Cela signifie qu'elles conserveront leur valeur m\u00eame lors des changements de configuration (comme la rotation de l'\u00e9cran). Dans FruitSelector , seul expanded reste une variable d'\u00e9tat locale, car elle ne concerne que l'affichage interne du composant. Cette refactorisation illustre des principes importants de Jetpack Compose, notamment l'\u00e9l\u00e9vation de l'\u00e9tat et la cr\u00e9ation de composants r\u00e9utilisables et ind\u00e9pendants. Elle permet une meilleure gestion de l'\u00e9tat de l'application et une plus grande flexibilit\u00e9 dans la construction de l'interface utilisateur.","title":"Focus sur les variables d'\u00e9tat"},{"location":"2.%20Android/10-localisation/","text":"10. Localisation Voici un guide pour int\u00e9grer la localisation dans une application Android d\u00e9velopp\u00e9e avec Jetpack Compose : Principes g\u00e9n\u00e9raux de la localisation La localisation d'une application Android consiste \u00e0 adapter son contenu et son interface utilisateur \u00e0 diff\u00e9rentes langues et cultures. Voici les principes cl\u00e9s \u00e0 suivre : Externalisez toutes les cha\u00eenes de caract\u00e8res dans des fichiers de ressources. Utilisez des identifiants neutres pour les ressources (ex: \"welcome_message\" au lieu de \"english_welcome\"). \u00c9vitez de coder en dur du texte dans votre code. Tenez compte des diff\u00e9rences culturelles (formats de date, unit\u00e9s de mesure, etc.). Pr\u00e9voyez de l'espace suppl\u00e9mentaire dans votre interface pour les traductions plus longues. Testez votre application dans diff\u00e9rentes langues et configurations. Exemple simple avec des String en anglais et fran\u00e7ais \u00c9tape 1 : Configurer les ressources linguistiques 1- Dans le dossier res , cr\u00e9ez un dossier values-fr pour les ressources en fran\u00e7ais. 2- Dans res/values/strings.xml (anglais par d\u00e9faut) : <resources> <string name=\"app_name\">My App</string> <string name=\"welcome_message\">Welcome to My App!</string> <string name=\"language_selection\">Select a language</string> </resources> 3- Dans res/values-fr/strings.xml : <resources> <string name=\"app_name\">Mon Application</string> <string name=\"welcome_message\">Bienvenue dans Mon Application !</string> <string name=\"language_selection\">S\u00e9lectionnez une langue</string> </resources> \u00c9tape 2 : Utiliser les cha\u00eenes localis\u00e9es dans Jetpack Compose @Composable fun WelcomeScreen() { Column( modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Text( text = stringResource(R.string.welcome_message), style = MaterialTheme.typography.h4 ) Spacer(modifier = Modifier.height(16.dp)) Text( text = stringResource(R.string.language_selection), style = MaterialTheme.typography.body1 ) } } Formatage des dates Pour formater les dates en fonction de la locale de l'utilisateur, utilisez la classe DateTimeFormatter avec ofLocalizedDate() : import java.time.LocalDate import java.time.format.DateTimeFormatter import java.time.format.FormatStyle @Composable fun DisplayLocalizedDate() { val currentDate = LocalDate.now() val dateFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG) val formattedDate = remember(currentDate) { currentDate.format(dateFormatter) } Text( text = formattedDate, style = MaterialTheme.typography.body1 ) } Ce code affichera la date actuelle dans le format long appropri\u00e9 pour la locale de l'utilisateur. Par exemple : En anglais (US) : \"September 18, 2024\" En fran\u00e7ais : \"18 septembre 2024\" En suivant ces \u00e9tapes, votre application Jetpack Compose sera correctement localis\u00e9e en anglais et en fran\u00e7ais, avec la possibilit\u00e9 d'ajouter facilement d'autres langues \u00e0 l'avenir[1][2][4]. Citations: [1] https://www.translized.com/blog/android-localization-with-jetpack-compose---a-comprehensive-guide [2] https://phrase.com/blog/posts/localized-date-time-android/ [3] https://www.youtube.com/watch?v=VdwDawvfH98 [4] https://phrase.com/blog/posts/internationalizing-jetpack-compose-android-apps/ [5] https://www.adamormsby.com/posts/013-android-localization-formatting-dates/ Exemple complet Voici un exemple complet d'une application simple utilisant Jetpack Compose avec localisation, sans les boutons pour changer la langue. Cette application affichera un message de bienvenue localis\u00e9 et la date actuelle format\u00e9e selon la locale de l'appareil. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.* import androidx.compose.material.* import androidx.compose.runtime.* import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.res.stringResource import androidx.compose.ui.unit.dp import java.time.LocalDate import java.time.format.DateTimeFormatter import java.time.format.FormatStyle class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyApp() } } } @Composable fun MyApp() { MaterialTheme { Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.background ) { LocalizedContent() } } } @Composable fun LocalizedContent() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Text( text = stringResource(R.string.welcome_message), style = MaterialTheme.typography.h4 ) Spacer(modifier = Modifier.height(16.dp)) DisplayLocalizedDate() } } @Composable fun DisplayLocalizedDate() { val currentDate = remember { LocalDate.now() } val dateFormatter = remember { DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG) } val formattedDate = remember(currentDate) { currentDate.format(dateFormatter) } Text( text = formattedDate, style = MaterialTheme.typography.body1 ) } Pour que cette application fonctionne correctement, vous devez \u00e9galement configurer les fichiers de ressources suivants : Dans res/values/strings.xml (anglais par d\u00e9faut) : <resources> <string name=\"app_name\">My Localized App</string> <string name=\"welcome_message\">Welcome to My Localized App!</string> </resources> Dans res/values-fr/strings.xml (pour le fran\u00e7ais) : <resources> <string name=\"app_name\">Mon Application Localis\u00e9e</string> <string name=\"welcome_message\">Bienvenue dans Mon Application Localis\u00e9e !</string> </resources> Assurez-vous d'avoir les d\u00e9pendances n\u00e9cessaires dans votre fichier build.gradle (Module : app) : dependencies { implementation \"androidx.compose.ui:ui:1.5.0\" implementation \"androidx.compose.material:material:1.5.0\" implementation \"androidx.compose.ui:ui-tooling-preview:1.5.0\" implementation \"androidx.activity:activity-compose:1.7.2\" } Cette application simple affiche : Un message de bienvenue localis\u00e9 La date actuelle format\u00e9e selon la locale de l'appareil L'application utilisera automatiquement les ressources appropri\u00e9es en fonction de la langue configur\u00e9e sur l'appareil de l'utilisateur. Si l'appareil est configur\u00e9 en fran\u00e7ais, il utilisera les cha\u00eenes de caract\u00e8res du fichier values-fr/strings.xml . Pour toute autre langue, il utilisera les cha\u00eenes par d\u00e9faut du fichier values/strings.xml . Pour tester diff\u00e9rentes langues, vous pouvez changer la langue de votre appareil ou de l'\u00e9mulateur dans les param\u00e8tres syst\u00e8me. L'application s'adaptera automatiquement \u00e0 la nouvelle langue sans n\u00e9cessiter de red\u00e9marrage. 915445 Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"10. Localisation"},{"location":"2.%20Android/10-localisation/#10-localisation","text":"Voici un guide pour int\u00e9grer la localisation dans une application Android d\u00e9velopp\u00e9e avec Jetpack Compose :","title":"10. Localisation"},{"location":"2.%20Android/10-localisation/#principes-generaux-de-la-localisation","text":"La localisation d'une application Android consiste \u00e0 adapter son contenu et son interface utilisateur \u00e0 diff\u00e9rentes langues et cultures. Voici les principes cl\u00e9s \u00e0 suivre : Externalisez toutes les cha\u00eenes de caract\u00e8res dans des fichiers de ressources. Utilisez des identifiants neutres pour les ressources (ex: \"welcome_message\" au lieu de \"english_welcome\"). \u00c9vitez de coder en dur du texte dans votre code. Tenez compte des diff\u00e9rences culturelles (formats de date, unit\u00e9s de mesure, etc.). Pr\u00e9voyez de l'espace suppl\u00e9mentaire dans votre interface pour les traductions plus longues. Testez votre application dans diff\u00e9rentes langues et configurations.","title":"Principes g\u00e9n\u00e9raux de la localisation"},{"location":"2.%20Android/10-localisation/#exemple-simple-avec-des-string-en-anglais-et-francais","text":"","title":"Exemple simple avec des String en anglais et fran\u00e7ais"},{"location":"2.%20Android/10-localisation/#etape-1-configurer-les-ressources-linguistiques","text":"1- Dans le dossier res , cr\u00e9ez un dossier values-fr pour les ressources en fran\u00e7ais. 2- Dans res/values/strings.xml (anglais par d\u00e9faut) : <resources> <string name=\"app_name\">My App</string> <string name=\"welcome_message\">Welcome to My App!</string> <string name=\"language_selection\">Select a language</string> </resources> 3- Dans res/values-fr/strings.xml : <resources> <string name=\"app_name\">Mon Application</string> <string name=\"welcome_message\">Bienvenue dans Mon Application !</string> <string name=\"language_selection\">S\u00e9lectionnez une langue</string> </resources>","title":"\u00c9tape 1 : Configurer les ressources linguistiques"},{"location":"2.%20Android/10-localisation/#etape-2-utiliser-les-chaines-localisees-dans-jetpack-compose","text":"@Composable fun WelcomeScreen() { Column( modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Text( text = stringResource(R.string.welcome_message), style = MaterialTheme.typography.h4 ) Spacer(modifier = Modifier.height(16.dp)) Text( text = stringResource(R.string.language_selection), style = MaterialTheme.typography.body1 ) } }","title":"\u00c9tape 2 : Utiliser les cha\u00eenes localis\u00e9es dans Jetpack Compose"},{"location":"2.%20Android/10-localisation/#formatage-des-dates","text":"Pour formater les dates en fonction de la locale de l'utilisateur, utilisez la classe DateTimeFormatter avec ofLocalizedDate() : import java.time.LocalDate import java.time.format.DateTimeFormatter import java.time.format.FormatStyle @Composable fun DisplayLocalizedDate() { val currentDate = LocalDate.now() val dateFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG) val formattedDate = remember(currentDate) { currentDate.format(dateFormatter) } Text( text = formattedDate, style = MaterialTheme.typography.body1 ) } Ce code affichera la date actuelle dans le format long appropri\u00e9 pour la locale de l'utilisateur. Par exemple : En anglais (US) : \"September 18, 2024\" En fran\u00e7ais : \"18 septembre 2024\" En suivant ces \u00e9tapes, votre application Jetpack Compose sera correctement localis\u00e9e en anglais et en fran\u00e7ais, avec la possibilit\u00e9 d'ajouter facilement d'autres langues \u00e0 l'avenir[1][2][4]. Citations: [1] https://www.translized.com/blog/android-localization-with-jetpack-compose---a-comprehensive-guide [2] https://phrase.com/blog/posts/localized-date-time-android/ [3] https://www.youtube.com/watch?v=VdwDawvfH98 [4] https://phrase.com/blog/posts/internationalizing-jetpack-compose-android-apps/ [5] https://www.adamormsby.com/posts/013-android-localization-formatting-dates/","title":"Formatage des dates"},{"location":"2.%20Android/10-localisation/#exemple-complet","text":"Voici un exemple complet d'une application simple utilisant Jetpack Compose avec localisation, sans les boutons pour changer la langue. Cette application affichera un message de bienvenue localis\u00e9 et la date actuelle format\u00e9e selon la locale de l'appareil. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.* import androidx.compose.material.* import androidx.compose.runtime.* import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.res.stringResource import androidx.compose.ui.unit.dp import java.time.LocalDate import java.time.format.DateTimeFormatter import java.time.format.FormatStyle class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyApp() } } } @Composable fun MyApp() { MaterialTheme { Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.background ) { LocalizedContent() } } } @Composable fun LocalizedContent() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Text( text = stringResource(R.string.welcome_message), style = MaterialTheme.typography.h4 ) Spacer(modifier = Modifier.height(16.dp)) DisplayLocalizedDate() } } @Composable fun DisplayLocalizedDate() { val currentDate = remember { LocalDate.now() } val dateFormatter = remember { DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG) } val formattedDate = remember(currentDate) { currentDate.format(dateFormatter) } Text( text = formattedDate, style = MaterialTheme.typography.body1 ) } Pour que cette application fonctionne correctement, vous devez \u00e9galement configurer les fichiers de ressources suivants : Dans res/values/strings.xml (anglais par d\u00e9faut) : <resources> <string name=\"app_name\">My Localized App</string> <string name=\"welcome_message\">Welcome to My Localized App!</string> </resources> Dans res/values-fr/strings.xml (pour le fran\u00e7ais) : <resources> <string name=\"app_name\">Mon Application Localis\u00e9e</string> <string name=\"welcome_message\">Bienvenue dans Mon Application Localis\u00e9e !</string> </resources> Assurez-vous d'avoir les d\u00e9pendances n\u00e9cessaires dans votre fichier build.gradle (Module : app) : dependencies { implementation \"androidx.compose.ui:ui:1.5.0\" implementation \"androidx.compose.material:material:1.5.0\" implementation \"androidx.compose.ui:ui-tooling-preview:1.5.0\" implementation \"androidx.activity:activity-compose:1.7.2\" } Cette application simple affiche : Un message de bienvenue localis\u00e9 La date actuelle format\u00e9e selon la locale de l'appareil L'application utilisera automatiquement les ressources appropri\u00e9es en fonction de la langue configur\u00e9e sur l'appareil de l'utilisateur. Si l'appareil est configur\u00e9 en fran\u00e7ais, il utilisera les cha\u00eenes de caract\u00e8res du fichier values-fr/strings.xml . Pour toute autre langue, il utilisera les cha\u00eenes par d\u00e9faut du fichier values/strings.xml . Pour tester diff\u00e9rentes langues, vous pouvez changer la langue de votre appareil ou de l'\u00e9mulateur dans les param\u00e8tres syst\u00e8me. L'application s'adaptera automatiquement \u00e0 la nouvelle langue sans n\u00e9cessiter de red\u00e9marrage. 915445 Note : Page r\u00e9dig\u00e9e en partie avec l'aide d'un assistant IA, principalement \u00e0 l'aide de Perplexity AI, avec les _LLM GPT-4 Omni et Claude 3.5 Sonnet . L'IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l'auteur._","title":"Exemple complet"}]}